//                                 twoway_lfitci_parse
//
//   A parser for adding a linear fit line with confidence intervals.  
//   Works with twoway.ado.

*! version 1.0.2  01jun2013

version 8

class {
    instance: 
	level	= 95
	std	= "stdp"
	fittype = "line"
	citype  = "rarea"
	fit	= 1		// indicator to plot fitted line
} , inherit(twoway_lfit_parse twoway_y2xview_parse)

			   // multiple inherit not needed if y3xview


// ---------------------------------------------------------------------------

program parse

	.points = 100

	_parse combop 0 : 0 , option(Level)    rightmost
	_parse combop 0 : 0 , option(FITType)  rightmost
	_parse combop 0 : 0 , option(CIType)   rightmost
	syntax [anything] [aw fw pw] [if] [in] [ ,			///
		Level(real `c(level)') STDP STDF STDR 			///
		FITPlot(string) CIPlot(string)				///
		TYPE(string) RECASTas(string) noFIT * ]

	if `"`type'"' != `""' {
		di as error "type() option not allowed"
		exit 198
	}
	if `"`recastas'"' != `""' {
		di as error "recastas() option not allowed"
		exit 198
	}

	local std `stdp' `stdf' `stdr'
	if `:word count `std'' > 1 {
		di as error "may not combine `std'"
		exit 198
	}
	if "`std'" != "" {
		.std = "`std'"
	}
	if `"`fitplot'"' != `""' {
		.fittype = `"`fitplot'"'
	}
	if `"`ciplot'"' != `""' {
		.citype = `"`ciplot'"'
	}
	.level	 = `level'
	if `"`fit'"' == "nofit" {
		.fit = 0
	}

	.Super(twoway_lfit_parse).parse `macval(anything)' [`weight'`exp'] ///
		`if' `in' , `macval(options)'
end



// ---------------------------------------------------------------------------
//	Creates a new serset and the view and returns its reference.
//	Assumes that the data in memory is the same as when parse was called.
//
//	Allows a touse(varname) option that further restricts the sample, 
//	restricts beyond the held .if and .in
//
//	Additional options to the .serset.new command may be specified, but
//	this is unlikely to be necessary.
//
//	If must_create_serset == 1, then this command MUST be used, 
//	otherwise the serset may be created by other means.

program log_create_serset

	syntax , LOG(name) SERSETNAME(string) [ TOUSE(passthru) * ]

	.log_touse , log(`log') `touse'

	local rest `.varlist'
	gettoken y rest : rest
	gettoken x rest : rest

	.`log'.Arrpush __NOLOG__ twoway__lfit_serset , 			  ///
		sersetname(`sersetname') touse(\`touse1') x(`x') y(`y')	  ///
		min(`.min') max(`.max')	points(`.points') atobs(`.atobs') ///
		predopts(`.predict_opts') regopts(`.regress_opts') 	  ///
		xtrans(`.xtrans') morevars(`rest')			  ///
		weight(`.wtype'`.wtexp') std(`.std') level(`.level')

	.`log'.Arrpush LogMapping .`sersetname'	// make _fr_runlog place 
						// mapping statement into 
						// permanent log.

	.wtype = ""			// so .Super.log_create_view will
	.wtexp = ""			// not try to add weight to serset

	if `.fit' {
		.n = 2			// so log_create_view gets called twice
	}
	else	.n = 1			// only call for ci
end


// ---------------------------------------------------------------------------
// not need if y3xview.
program log_create_view
	syntax [ , VIEW(integer 1) SERIESID(integer 1) * ]

	if `view' == 1 {					// CI
		.viewclass = "y2xview_g"
		local varlist `.varlist'
		gettoken pitch xvar : varlist
		.varlist = "lower_limit upper_limit `xvar'"
		.n = 1
		.Super(twoway_y2xview_parse).log_create_view ,		///
			view(1) style(ci) `macval(options)'
		.n = 2
		.varlist = "`varlist'"
	}
	else {							// fit
		.viewclass = "yxview"
		.n = 1
		.Super(twoway_lfit_parse).log_create_view ,		///
			view(1) seriesid(`=`seriesid'-1') `macval(options)'
		.n = 2
	}
end


// ---------------------------------------------------------------------------

program log_edits
	args log view i
	
	if `i' == 1 {
		.`log'.Arrpush .`view'.type.setstyle , style(`.citype') 
		.Super.log_edits `0'
	}

	if `i' == 2 {
		.`log'.Arrpush .`view'.type.setstyle , style(`.fittype')
		.Super.log_edits `log' `view' 1
	}
end
