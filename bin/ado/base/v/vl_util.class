*! version 1.0.0  30may2019

///////////////////////// Utilities for vl commands /////////////////////////
//
////////////////////////// Option checking utility //////////////////////////
//
//	.check_system_user_options [, SYStem user ]
//
/////////////////////// High-level parsing utilities ////////////////////////
//
//	.get_vlname_or_varlist {<name> | (<varlist>)} [, SYStem user ]
//
//	.get_vlnamelist_or_varlist {<namelist> | (<varlist>)} [, SYStem user fv list strok ]
//
//	.expand_fv_vlnamelist [<something>.]<vlname>#[#][<something>.]<vlname> ...
//
//////////////// Utilities for adding/changing vlname macros ////////////////
//
//	.move_vlsys_from_to <name_from> <name_to>
//
//	.add_new_vlname <name>
//
//	.modify_vluser <macname_out> : <name> <varlist>
//
//	.drop_vlsysname <name>
//
//	.drop_vlusername <name>
//
//	.drop_vlfvname <name>
//
//	.remove_varlist_from_vlsys <varlist>
//
//	.remove_varlist_from_vluser <varlist>
//
/////////////// Utility for setting vl macros from var chars ////////////////
//
//	.set_vl_macros_from_var_chars
//
//////////////// Utilities for erasing macros and _dta chars ////////////////
//
//	.erase_vl_macros	(macros only)
//
//	.erase_vlsys_macros	(macros only)
//
//	.erase_vluser_macros	(macros only)
//
//	.erase_vlfv_macros	(macros only)
//
//	.erase_vlnames		(macros and _dta chars)
//
//	.erase_vlsysnames	(macros and _dta chars)
//
//	.erase_vlusernames	(macros and _dta chars)
//
//	.erase_vlfvnames	(macros and _dta chars)
//
////////////////// Utilities for erasing vl variable chars //////////////////
//
//	.erase_vlsys_var_chars [<varlist>]
//
//	.erase_vluser_var_chars [<varlist>]
//
////////////////// .get utilities involving vlname macros ///////////////////
//
//	.get_vlsysnames <macname_out>
//
//	.get_vlusernames <macname_out>
//
//	.get_vlnames <macname_out>
//
//	.get_vlsysname <macname_out> : #
//
//	.get_vlusername <macname_out> : #
//
//	.get_number_of_vlsysnames <macname_out>
//
//	.get_number_of_vlusernames <macname_out>
//
//	.get_index_of_vlsysname <macname_out> : <name>
//
//	.get_index_of_vlusername <macname_out> : <name>
//
//	.get_index_of_sorted_vlusername <macname_out> : <name>
//
//	.get_desc_of_vlsysname <macname_out> : <name>
//
//	.set_desc_of_vlusername <vlusername> ["<desc>"]
//
//	.get_desc_of_vlusername <macname_out> : <name>
//
//////////////////// .get utilities involving variables /////////////////////
//
// 	.get_vlsysname_of_varname <macname_out> : <varname>
//
//	.get_vlusernames_of_varname <macname_out> : <varname>
//
//	.get_vlsys_desc_of_varname <macname_out> : <varname>
//
//	.get_vlsys_levels_of_varname <macname_out> : <varname>
//
//	.get_vlsys_varlist <macname_out>
//
//	.get_vluser_varlist <macname_out>
//
//	.get_numeric_variables <macname_out>
//
//	.get_max_length_names <macname_out> : <namelist>
//
////////////////// .get utilities for counts of variables ///////////////////
//
//	.get_nvars_in_data <macname_out>
//
//	.get_n_numeric_vars_in_data <macname_out>
//
//	.get_count_of_vlsysname <macname_out> : <name>
//
//	.get_count_of_vlusername <macname_out> : <name>
//
//	.get_count_of_vlsys <macname_out>
//
//	.get_count_of_vluser <macname_out>
//
//	.get_count_of_distinct_vluser <macname_out>
//
//	.get_diff_counts_of_vlsys <macname_out> : {<name> | _all}
//
//	.get_diff_counts_of_vluser <macname_out> : {<name> | _all}
//
//	.note_if_vlname_empty <name>
//
//////////////////////// .get miscellaneous utility /////////////////////////
//
//	.get_dups_of_string <macname_out> : # <string>
//
///////////////////////// .is miscellaneous utility /////////////////////////
//
//	.is_namelist_in_master <macname_out> : "<namelist>" "<master_namelist>"
//
//////////////// .is utilities for vlsys and vluser macros //////////////////
//
//	.set_vl_set
//
//	.is_version_set <macname_out>
//
//	.is_vlsys_set <macname_out>
//
//	.is_vluser_set <macname_out>
//
//	.is_vldummy <macname_out>
//
//	.is_vlsysname <macname_out> : <name>
//
//	.is_vlusername <macname_out> : <name>
//
//	.is_vlfvname <macname_out> : <name>
//
//	.is_vlname <macname_out> : <name>
//
//	.is_vlnamelist <macname_out> : <namelist>
//
////////////////////// .is utilities for variables //////////////////////////
//
//	.is_varlist <macname_out> : <varlist>
//
//	.is_numeric_variable <macname_out> : <varname>
//
//	.is_string_variable <macname_out> : <varname>
//
//////////// .assert utilities for checking vlsys or vluser set /////////////
//
//	.assert_vlsys_set
//
//	.assert_vluser_set
//
//	.assert_vlsys_or_vluser_set
//
//	.assert_vlchars_set
//
////////////////// .assert utilities for checking vlnames ///////////////////
//
//	.assert_vlname <name> [, SYStem user fv ]
//
//	.assert_vlnames <namelist> [, SYStem user fv ]
//
///////////////// .assert utilities for checking varlists ///////////////////
//
//	.assert_varlist <varlist> [, strok ]
//
//	.assert_numeric_varlist <varlist> [, list ]
//
//	.assert_variables_in_vlsys <varlist> [, move ]
//
//	.assert_variables_in_vluser <varlist>
//
//	.assert_variables_in_vl <varlist>
//
//	.assert_variables_not_in_vlsys <varlist>
//
////////////////// .assert utilities for low-level parsing //////////////////
//
//	.assert_colon <whatever>
//
//	.assert_eq_sign <whatever>
//
//	.assert_next_token_nothing <whatever>
//
//	.assert_operator <whatever>
//
/////////////////////////////////////////////////////////////////////////////

version 16

class vl_util {

	string vlsysnames	   // may or may not include vldummy
	string vlusernames
	string vlusernames_sorted  // sorted vlusernames
	string vlnames		   // union of vlsysnames and vlusernames 
	string vlfvnames	   // usernames for macros holding fv lists

	string allvlsysnames	   // macro names reserved for vlsys
	string reserved		   // all reserved macro names

	string vlsysmat		   // tempname of matrix
	string vlusermat	   // tempname of matrix

	double vlsys_set	   // not set = 0, set = 1, not checked = .
	double vluser_set	   // not set = 0, set = 1, not checked = .

	double n_vlsysnames	   // # names, not # variables
	double n_vlusernames	   // # names, not # variables

	double vlsys_nvars	   // # variables based on macros, not chars
	double vluser_nvars	   // # variables based on macros, not chars;
				   // note that vluser variables are counted 
				   // more than once when they belong to more 
				   // than one macro
}

program .new
	syntax , SYSMAT(name) USERMAT(name)

	local names vldummy       ///
		    vlcategorical ///
		    vlcontinuous  ///
		    vluncertain   ///
		    vlother       ///
		    vl__tmp__

	.allvlsysnames = "`names'"

	local other _not_system  ///
		    _not_user    ///
		    _string      ///
		    _user_string 

	.reserved = "`names' `other'"

	.vlsysmat  = "`sysmat'"
	.vlusermat = "`usermat'"

	.update
end

program .update
	local vlsysnames  : char _dta[_vlsysnames]
	local vlusernames : char _dta[_vlusernames]
	local vlfvnames   : char _dta[_vlfvnames]

	// Update vldummy in _dta[_vlsysnames].
	// They may be inconsistent because of a merge.
	// _dta[_vlsys_has_dummy] overrules _dta[_vlsysnames].

	local hasdum : char _dta[_vlsys_has_dummy]
	local vlsyshasdum : list posof "vldummy" in vlsysnames
	
	if ("`hasdum'" != "" & !`vlsyshasdum') {
		local vlsysnames vldummy `vlsysnames'
	}

	local vlnames `vlsysnames' `vlusernames'

	// Set counts of vlsys.

	local n_vlsysnames : list sizeof vlsysnames

	if (`n_vlsysnames' > 0) {

		mat `.vlsysmat' = J(1, `n_vlsysnames', .)

		mat colnames `.vlsysmat' = `vlsysnames'

		local total 0
		local i 0

		foreach vlsysname of local vlsysnames {

			local n : list sizeof global(`vlsysname')

			mat `.vlsysmat'[1, `++i'] = `n'

			local total = `total' + `n'
		}

		.vlsys_nvars = `total'
	}
	else {
		mat `.vlsysmat' = J(1, 1, .)

		.vlsys_nvars = 0
	}

	// Set counts of vluser.

	local n_vlusernames : list sizeof vlusernames

	if (`n_vlusernames' > 0) {

		mat `.vlusermat' = J(1, `n_vlusernames', .)

		mat colnames `.vlusermat' = `vlusernames'

		local total 0
		local i 0

		foreach vlusername of local vlusernames {
		
			local n : list sizeof global(`vlusername')

			matrix `.vlusermat'[1, `++i'] = `n'

			local total = `total' + `n'
		}
		
		.vluser_nvars = `total'
	}
	else {
		mat `.vlusermat' = J(1, 1, .)

		.vluser_nvars = 0
	}
	
	local sorted : copy local vlusernames
	local sorted : list sort sorted
	
	.vlsysnames         = "`vlsysnames'"
	.vlusernames        = "`vlusernames'"
	.vlfvnames          = "`vlfvnames'"
	.vlusernames_sorted = "`sorted'"
	.vlnames            = "`vlnames'"

	.vlsys_set  = (.)
	.vluser_set = (.)

	.n_vlsysnames  = `n_vlsysnames'
	.n_vlusernames = `n_vlusernames'
end

////////////////////////// Option checking utility //////////////////////////
//
//	.check_system_user_options [, SYStem user ]
//
/////////////////////////////////////////////////////////////////////////////

program .check_system_user_options, sclass
	syntax [, SYStem user ]

	if ("`system'" != "") {
		.assert_vlsys_set
	}

	if ("`user'" != "") {
		.assert_vluser_set
	}

	if ("`system'`user'" == "") {

		.is_vlsys_set is_sys

		if (`is_sys') {
			local system system
		}

		.is_vluser_set is_user

		if (`is_user') {
			local user user
		}
	}

	sreturn local system `system'
	sreturn local user   `user'
end

/////////////////////// High-level parsing utilities ////////////////////////
//
//	.get_vlname_or_varlist {<name> | (<varlist>)} [, SYStem user ]
//
//	.get_vlnamelist_or_varlist {<namelist> | (<varlist>)} [, SYStem user fv list strok ]
//
//	.expand_fv_vlnamelist [<something>.]<vlname>#[#][<something>.]<vlname> ...
//
/////////////////////////////////////////////////////////////////////////////

// Parses {<name> | (<varlist>)} [ {+ | -} ... ]
// or     {<name> | (<varlist>)} [ ... ]
//
// Checks that <name> is a vlname.
// Checks that <varlist> is a numeric varlist.
// If (*) or (_all), it is interpreted as all numeric variables.
// Removes duplicates from varlist.

program .get_vlname_or_varlist, sclass
	syntax [anything] [, SYStem user ]

	if (`"`anything'"' == "") {
		ErrorNoVLnamelistOrVarlist
	}

	gettoken first rest : anything, parse(" ()+-") match(par)

	if ("`par'" == "(") {  // varlist

		if (`"`first'"' == "") {
			ErrorNoVarlist
		}

		Expand_varlist `first'
		sreturn local varlist `s(varlist)'
		sreturn local vlname  // erase
	}
	else {  // vlname
		.assert_vlname `first', `system' `user' `fv'
		sreturn local vlname `first'
		sreturn local varlist  // erase
	}

	sreturn local rest `rest'
end

program ErrorNoVLnameOrVarlist
	di as err "nothing found where {it:vlname} or {bf:(}{it:varlist}{bf:)} expected"
	exit 198
end

program ErrorNoVarlist
	di as err "nothing found inside {bf:()} where {it:varlist} expected"
	exit 100
end

// Parses {<namelist> | (<varlist>)} {nothing}
//
// Checks that <namelist> is a vlnamelist.
// Checks that <varlist> is a numeric varlist unless -strok- specified.
// If (*) or (_all), it is interpreted as all numeric variables (unless
// -strok- specified).
// Removes duplicates from varlist.

program .get_vlnamelist_or_varlist, sclass
	syntax [anything] [, SYStem user fv list strok ]

	if (`"`anything'"' == "") {
		ErrorNoVLnamelistOrVarlist
	}

	gettoken first rest : anything, parse("()") match(par)

	if ("`par'" == "(") {  // varlist

		if (`"`first'"' == "") {
			ErrorNoVarlist
		}

		if (`"`rest'"' != "") {
			ErrorSomethingFound `rest'
		}

		Expand_varlist `first', `list' `strok'
		sreturn local varlist `s(varlist)'
		sreturn local vlnamelist  // erase
	}
	else {  // vlnamelist
		.assert_vlnames `first', `system' `user' `fv'
		sreturn local vlnamelist `first'
		sreturn local varlist  // erase
	}

	.assert_next_token_nothing `rest'
end

program ErrorNoVLnamelistOrVarlist
	di as err "nothing found where {it:vlnamelist} or {bf:(}{it:varlist}{bf:)} expected"
	exit 198
end

program ErrorSomethingFound
	di as err `"{p}{bf:`0'} found where nothing expected{p_end}"'
	exit 198
end

program Expand_varlist, sclass
	syntax anything [, list strok ]

	.is_namelist_in_master is_all : `"`anything'"' "_all *"

	if (`is_all') {
		if ("`strok'" != "") {
			unab varlist : _all
		}
		else {
			mata: GetNumericVariables("varlist")
		}
	}
	else {
 		.assert_varlist `anything', `list' `strok'

		unab varlist : `anything'

		// Remove duplicates.

		local nvars_before : list sizeof varlist
		local varlist      : list uniq varlist
		local nvars_after  : list sizeof varlist

		if (`nvars_before' != `nvars_after') {
			di as txt "{p 0 6 2}"
			di as txt "note: duplicate variables removed from"
			di as txt "{it:varlist}{p_end}"
		}
	}

	sreturn local varlist `varlist'
end

program .expand_fv_vlnamelist, sclass

	local vl_fv_exp `0'

	// [<something>.]<vlname>#[#][<something>.]<vlname> ...
	
	while (`"`0'"' != "") {
	
		local old1 `old2'
		local old2 `0'
	
		gettoken something 0 : 0, parse(" ().#") match(par)
		
		if (`"`lastword'"' != "") {
			SpaceAfter space : `"`old1'"' `"`lastword'"'
		}
		else if (`"`lastpar'"' != "") {
			SpaceAfterFound space : `"`old1'"' ")"
		}

		if (`"`something'"' == "." & "`space'" == "") {
			local fvexp `fvexp'`lastwordsp'`lastword'`lastparsp'`lastpar'.
			
			local lastword    // erase
			local lastwordsp  // erase
			local lastpar     // erase
			local lastparsp   // erase
		}
		else if ("`par'" == "(") {
			local lastpar `something'
			SpaceInFront lastparsp : `"`old1'"' "("
		}
		else {
			if (`"`lastword'"' != "") {
				ExpandVLnamelist vars : `lastword'
			
				local fvexp `fvexp'`lastwordsp'(`vars')
				
				local lastword    // erase
				local lastwordsp  // erase
			}
			
			if (`"`lastpar'"' != "") {
				ExpandVLnamelist vars : `lastpar'
				
				local fvexp `fvexp'`lastparsp'(`vars')
				
				local lastpar    // erase
				local lastparsp  // erase
			}
			
			if (`"`something'"' == "#") {
				local fvexp `fvexp'`space'#
			}
			else {
				local lastword   `something'
				local lastwordsp `"`space'"'
			}
		}
	}
		
	if (`"`lastword'"' != "") {
		ExpandVLnamelist vars : `lastword'
	
		local fvexp `fvexp'`lastwordsp'(`vars')
	}
	
	if (`"`lastpar'"' != "") {
		ExpandVLnamelist vars : `lastpar'
		
		local fvexp `fvexp'`lastparsp'(`vars')
	}

	local 0 `fvexp'
		
	syntax varlist(fv)
	
	sreturn local vl_fv_exp `vl_fv_exp'
	sreturn local varlist `varlist'
end
		
program SpaceAfter
	args macname colon s1 s2
	
	local p = ustrlen(`"`s2'"')
	
	if (usubstr(`"`s1'"', `p' + 1, 1) == " ") {

		c_local `macname' `" "'
	}
	else {
		c_local `macname'
	}
end
	
program SpaceAfterFound
	args macname colon s1 s2
	
	local p = ustrpos(`"`s1'"', `"`s2'"')
	
	if (usubstr(`"`s1'"', `p' + 1, 1) == " ") {

		c_local `macname' `" "'
	}
	else {
		c_local `macname'
	}
end
	
program SpaceInFront
	args macname colon s1 s2
	
	local p = ustrpos(`"`s1'"', `"`s2'"')
	
	if (usubstr(`"`s1'"', `p' - 1, 1) == " ") {

		c_local `macname' `" "'
	}
	else {
		c_local `macname'
	}
end
	
program ExpandVLnamelist
	gettoken macname 0 : 0
	gettoken colon   0 : 0
	
	while (`"`0'"' != "") {
		gettoken name 0 : 0 
	
		.is_vlname is_vlname : `name'
		
		if (`is_vlname') {
			local list `list' ${`name'}
		}
		else {
			local list `list' `name'
		}
	}
	
	c_local `macname' `list'
end		

//////////////// Utilities for adding/changing vlname macros ////////////////
//
//	.move_vlsys_from_to <name_from> <name_to>
//
//	.add_new_vlname <name>
//
//	.modify_vluser <macname_out> : <name> <varlist>
//
//	.drop_vlsysname <name>
//
//	.drop_vlusername <name>
//
//	.drop_vlfvname <name>
//
//	.remove_varlist_from_vlsys <varlist>
//
//	.remove_varlist_from_vluser <varlist>
//
/////////////////////////////////////////////////////////////////////////////

program .move_vlsys_from_to
	args name_from name_to

	// Add to name_to.

	global `name_to' : list global(`name_to') | global(`name_from')

	// Remove from other vlsys macros.

	local vlsysnames `.vlsysnames'

	local namelist : list vlsysnames - name_to

	foreach name of local namelist {
		global `name' : list global(`name') - global(`name_from')
	}

	// Update var chars.

	foreach x of global `name_to' {
		char `x'[_vlsysname] `name_to'
	}
end

program .add_new_vlname
	syntax name(name=name) [, fv ]
	
	// Maximum length is 27 characters because -vl dir- and -vl list-
	// return r(k_`name') and -vl sub- sets char _dta[_vl__<name>].
	
	if (udstrlen("`name'") > 27) {
		di as err "{bf:`name'} invalid {bf:vl} user name"
		di as err "{p 4 4 2}"
		di as err "{bf:vl} user names must be 27 characters or less."
		di as err "{p_end}"
		exit 198
	}

	local used `.vlusernames' `.vlfvnames'

	local is_in : list name in used

	if (`is_in') {
		di as err "{bf:vl} user name {bf:`name'} already exists"
		exit 110
	}

	local reserved `.reserved'

	local is_in : list name in reserved

	if (`is_in') {
		di as err "{bf:`name'} invalid {bf:vl} user name"
		di as err "{p 4 4 2}"
		di as err "{bf:`name'} is reserved for the {bf:vl} system."
		di as err "{p_end}"
		exit 198
	}
	
	global `name'  // erase any remnant macro

	char _dta[_vl_version_1] 1
	
	if ("`fv'" != "") {
		char _dta[_vlfvnames] `.vlfvnames' `name'
	}
	else {
		char _dta[_vlusernames] `.vlusernames' `name'
	}
	
	.update
end

program .modify_vluser
	gettoken macname 0       : 0
	gettoken colon   0       : 0
	gettoken name    varlist : 0

	// Erase name from varname[_vlusernames] char for variables that get
	// removed from name.

	local removed_vars : list global(`name') - varlist

	foreach x of local removed_vars {
		local vlusernames : char `x'[_vlusernames]
		local vlusernames : list vlusernames - name
		char `x'[_vlusernames] `vlusernames'
	}

	// Add name to varname[_vlusernames] char for variables that get
	// added to name.

	local added_vars : list varlist - global(`name')

	foreach x of local added_vars {
		local vlusernames : char `x'[_vlusernames]
		char `x'[_vlusernames] `vlusernames' `name'
	}

	// Update macro.

	global `name' `varlist'

	// Update _dta[_vluser_nvars]. Note that variables may be counted
	// more than once.

	.get_count_of_vlusername n_old : `name'

	local n_new : list sizeof global(`name')
	
	local d = `n_new' - `n_old'

	Update_char_dta_vluser_nvars `d'

	c_local `macname' `d'
end

program Update_char_dta_vluser_nvars
	args diff

	local n : char _dta[_vluser_nvars]

	if ("`n'" == "") {
		local n 0
	}

	confirm integer number `n'

	local n = `n' + `diff'

	char _dta[_vluser_nvars] `n'
end

program Update_char_dta_vlsys_nvars
	args diff

	local n : char _dta[_vlsys_nvars]

	if ("`n'" == "") {
		local n 0
	}

	confirm integer number `n'

	local n = `n' + `diff'

	char _dta[_vlsys_nvars] `n'
end

program .drop_vlsysname
	args name

	.assert_vlname `name', system

	.note_if_vlname_empty `name'

	local varlist : copy global `name'

	local n : list sizeof varlist

	// Erase only varname[_vlsysname] char.

	mata: EraseVarChars("_vlsysname", "varlist")

	Update_char_dta_vlsys_nvars -`n'

	global `name'

	if ("`name'" == "vldummy") {

		local vlsysnames `.vlsysnames'

		local vlsysnames : list vlsysnames - name

		char _dta[_vlsysnames] `vlsysnames'

		char _dta[_vlsys_has_dummy]
	}
end

program .drop_vlusername
	args name

	.assert_vlname `name', user

	.note_if_vlname_empty `name'

	.modify_vluser n : `name'  // varlist argument empty

	local vlusernames `.vlusernames'

	local vlusernames : list vlusernames - name

	char _dta[_vlusernames] `vlusernames'
end

program .drop_vlfvname
	args name

	.assert_vlname `name', fv

	.note_if_vlname_empty `name'

	local vlfvnames `.vlfvnames'

	local vlfvnames : list vlfvnames - name
	
	char _dta[_vlfvnames] `vlfvnames'
	
	global `name'  // erase

	char _dta[_vl__`name']   // erase
end

program .remove_varlist_from_vlsys
	syntax varlist(numeric)  // assumed distinct

	// Erase only varname[_vlsysname] char.

	mata: EraseVarChars("_vlsysname", "varlist")

	foreach name in `.vlsysnames' {
		global `name' : list global(`name') - varlist
	}

	local n : list sizeof varlist

	Update_char_dta_vlsys_nvars -`n'
end

program .remove_varlist_from_vluser
	syntax varlist(numeric)  // assumed distinct

	// Erase only varname[_vlusernames] char.

	mata: EraseVarChars("_vlusernames", "varlist")

	local n 0

	foreach name in `.vlusernames' {
		local n_old : list sizeof global(`name')

		global `name' : list global(`name') - varlist

		local n_new : list sizeof global(`name')

		local n = `n' + `n_new' - `n_old'
	}

	Update_char_dta_vluser_nvars `n'
end

/////////////// Utility for setting vl macros from var chars ////////////////
//
//	.set_vl_macros_from_var_chars
//
/////////////////////////////////////////////////////////////////////////////

program .set_vl_macros_from_var_chars

	.erase_vl_macros

	mata: SetGlobalsFromVarChars()
end

//////////////// Utilities for erasing macros and _dta chars ////////////////
//
//	.erase_vl_macros	(macros only)
//
//	.erase_vlsys_macros	(macros only)
//
//	.erase_vluser_macros	(macros only)
//
//	.erase_vlfv_macros	(macros only)
//
//	.erase_vlnames		(macros and _dta chars)
//
//	.erase_vlsysnames	(macros and _dta chars)
//
//	.erase_vlusernames	(macros and _dta chars)
//
//	.erase_vlfvnames	(macros and _dta chars)
//
/////////////////////////////////////////////////////////////////////////////

program .erase_vl_macros

	.erase_vlsys_macros
	.erase_vluser_macros
	.erase_vlfv_macros
end

program .erase_vlsys_macros

	foreach name in `.allvlsysnames' {
		global `name'
	}
end

program .erase_vluser_macros

	foreach name in `.vlusernames' {
		global `name'
	}

	// Always erase tmp global macro.

	global vl__tmp__
end

program .erase_vlfv_macros

	foreach name in `.vlfvnames' {
		global `name'
	}

	// Always erase tmp global macro.

	global vl__tmp__
end

program .erase_vlnames

	.erase_vlsysnames
	.erase_vlusernames
	.erase_vlfvnames
end

program .erase_vlsysnames

	.erase_vlsys_macros

	char _dta[_vlsysnames]
	char _dta[_vlsys_has_dummy]
	char _dta[_vlsysnames_desc]
	char _dta[_vl_levels_desc]
	char _dta[_vlsys_nvars]
end

program .erase_vlusernames

	.erase_vluser_macros

	char _dta[_vlusernames]
	char _dta[_vluser_nvars]
	char _dta[_vlusernames_desc]
end

program .erase_vlfvnames

	.erase_vlfv_macros
	
	foreach name in `.vlfvnames' {
		char _dta[_vl__`name']
	}

	char _dta[_vlfvnames]
end

////////////////// Utilities for erasing vl variable chars //////////////////
//
//	.erase_vlsys_var_chars [<varlist>]
//
//	.erase_vluser_var_chars [<varlist>]
//
/////////////////////////////////////////////////////////////////////////////

program .erase_vlsys_var_chars

	local var_chars "_vlsysname _vl_nlevels _vl_min _vl_max _vl_N"

	if (`"`0'"' == "") {
		mata: EraseVarChars("`var_chars'")
	}
	else {
		syntax varlist
		mata: EraseVarChars("`var_chars'", "varlist")
	}
end

program .erase_vluser_var_chars

	if (`"`0'"' == "") {
		mata: EraseVarChars("_vlusernames")
	}
	else {
		syntax varlist
		mata: EraseVarChars("_vlusernames", "varlist")
	}
end

////////////////// .get utilities involving vlname macros ///////////////////
//
//	.get_vlsysnames <macname_out>
//
//	.get_vlusernames <macname_out>
//
//	.get_vlnames <macname_out>
//
//	.get_vlsysname <macname_out> : #
//
//	.get_vlusername <macname_out> : #
//
//	.get_number_of_vlsysnames <macname_out>
//
//	.get_number_of_vlusernames <macname_out>
//
//	.get_index_of_vlsysname <macname_out> : <name>
//
//	.get_index_of_vlusername <macname_out> : <name>
//
//	.get_index_of_sorted_vlusername <macname_out> : <name>
//
//	.get_desc_of_vlsysname <macname_out> : <name>
//
//	.set_desc_of_vlusername <vlusername> ["<desc>"]
//
//	.get_desc_of_vlusername <macname_out> : <name>
//
/////////////////////////////////////////////////////////////////////////////

program .get_vlsysnames
	args macname
	c_local `macname' `.vlsysnames'
end

program .get_vlusernames
	args macname
	c_local `macname' `.vlusernames'
end

program .get_vlfvnames
	args macname
	c_local `macname' `.vlfvnames'
end

program .get_vlnames
	args macname
	c_local `macname' `.vlnames'
end

program .get_vlsysname
	args macname colon i

	if (`i' > 0) {
		local name : word `i' of `.vlsysnames'
	}

	c_local `macname' `name'
end

program .get_vlusername
	args macname colon i

	if (`i' > 0) {
		local name : word `i' of `.vlusernames'
	}

	c_local `macname' `name'
end

program .get_number_of_vlsysnames
	args macname

	c_local `macname' `.n_vlsysnames'
end

program .get_number_of_vlusernames
	args macname

	c_local `macname' `.n_vlusernames'
end

program .get_index_of_vlsysname
	args macname colon name

	local names `.vlsysnames'

	local index : list posof "`name'" in names

	c_local `macname' `index'
end

program .get_index_of_vlusername
	args macname colon name

	local names `.vlusernames'

	local index : list posof "`name'" in names

	c_local `macname' `index'
end

program .get_index_of_sorted_vlusername
	args macname colon name

	local names `.vlusernames_sorted'

	local index : list posof "`name'" in names
	
	c_local `macname' `index'
end

program .get_desc_of_vlsysname
	args macname colon name

	.assert_vlname `name', system

	local vldescs : char _dta[_vlsysnames_desc]

	local i : list posof "`name'" in vldescs

	if (`i' > 0) {
		local desc : word `++i' of `vldescs'
	}

	c_local `macname' `desc'
end

program .set_desc_of_vlusername
	args name desc

	.assert_vlname `name', user fv

	local vldescs : char _dta[_vlusernames_desc]

	local i : list posof "`name'" in vldescs

	if (`i' > 0) {  // erase existing label
		local old_desc : word `++i' of `vldescs'
		local old_desc `"`"`old_desc'"'"'
		local vldescs : list vldescs - old_desc
		local vldescs : list vldescs - name
	}

	if (`"`desc'"' != "") {
		char _dta[_vlusernames_desc] `"`vldescs' `name' `"`desc'"'"'
	}
	else {
		char _dta[_vlusernames_desc] `"`vldescs'"'
	}
end

program .get_desc_of_vlusername
	args macname colon name

	local vldescs : char _dta[_vlusernames_desc]

	local i : list posof "`name'" in vldescs

	if (`i' > 0) {
		local desc : word `++i' of `vldescs'
	}

	c_local `macname' `desc'
end

//////////////////// .get utilities involving variables /////////////////////
//
// 	.get_vlsysname_of_varname <macname_out> : <varname>
//
//	.get_vlusernames_of_varname <macname_out> : <varname>
//
//	.get_vlsys_desc_of_varname <macname_out> : <varname>
//
//	.get_vlsys_levels_of_varname <macname_out> : <varname>
//
//	.get_vlsys_varlist <macname_out>
//
//	.get_vluser_varlist <macname_out>
//
//	.get_numeric_variables <macname_out>
//
//	.get_max_length_names <macname_out> : <namelist>
//
/////////////////////////////////////////////////////////////////////////////

program .get_vlsysname_of_varname
	args macname colon varname

	confirm variable `varname'

	local insys : char `varname'[_vlsysname]

	c_local `macname' `insys'
end

program .get_vlusernames_of_varname
	args macname colon varname

	confirm variable `varname'

	local inusers : char `varname'[_vlusernames]

	c_local `macname' `inusers'
end

program .get_vlsys_desc_of_varname
	args macname colon varname

	confirm variable `varname'

	local nlevels : char `varname'[_vl_nlevels]

	if (`"`nlevels'"' == "") {
		c_local `macname'  // no description
		exit
	}

	cap confirm integer number `nlevels'
	if (c(rc) == 0) {
	
		if (`nlevels' == 1) {
			c_local `macname' "constant"
			exit
		}

		if (`nlevels' == 2) {

			local min : char `varname'[_vl_min]
			local max : char `varname'[_vl_max]

			if (`"`min'"' == "0" & `"`max'"' == "1") {

				c_local `macname' "0 and 1"
				exit
			}
		}

		c_local `macname' "integers >=0"
		exit
	}
	else if (c(rc) != 7) {
		error c(rc)
	}

	local vals .a .b .c .d .e .f .g .h .i .j .k .l .m .n .o .p .q .s .t .u .v .w .x .y .z

	local i : list posof "`nlevels'" in vals

	local descs : char _dta[_vl_levels_desc]

	if (`i' > 0) {
		local desc : word `i' of `descs'
	}

	c_local `macname' "`desc'"
end

program .get_vlsys_levels_of_varname
	args macname colon varname

	confirm variable `varname'

	local nlevels : char `varname'[_vl_nlevels]

	cap confirm integer number `nlevels'
	if (c(rc) == 0) {

		if (`nlevels' < 0) {
			local nlevels = -`nlevels'
			local nlevels >`nlevels'
		}
			
		c_local `macname' `nlevels'
	}
	else {
		c_local `macname'  // no levels
	}
end

program .get_vlsys_varlist
	args macname

	// .assert_vlsys_set or .is_vlsys_set should have already been
	// called and check for dropped variables done.
	// A variable can only be in one vlsys macro.

	foreach name in `.vlsysnames' {
		local varlist `varlist' ${`name'}
	}

	c_local `macname' `varlist'
end

program .get_vluser_varlist
	args macname

	// .assert_vluser_set or .is_vluser_set should have already been
	// called and check for dropped variables done.
	// A variable can be in more than one vlsys macro.

	foreach name in `.vlusernames' {
		local varlist : list varlist | global(`name')
	}

	c_local `macname' `varlist'
end

program .get_numeric_variables
	args macname

	mata: GetNumericVariables("varlist")

	c_local `macname' `varlist'
end

program .get_max_length_names
	gettoken macname 0     : 0
	gettoken colon   names : 0

	mata: MaxLengthNames("maxlength", "names", 8)

	c_local `macname' `maxlength'
end

////////////////// .get utilities for counts of variables ///////////////////
//
//	.get_nvars_in_data <macname_out>
//
//	.get_n_numeric_vars_in_data <macname_out>
//
//	.get_count_of_vlsysname <macname_out> : <name>
//
//	.get_count_of_vlusername <macname_out> : <name>
//
//	.get_count_of_vlsys <macname_out>
//
//	.get_count_of_vluser <macname_out>
//
//	.get_count_of_distinct_vluser <macname_out>
//
//	.get_diff_counts_of_vlsys <macname_out> : {<name> | _all}
//
//	.get_diff_counts_of_vluser <macname_out> : {<name> | _all}
//
//	.note_if_vlname_empty <name>
//
/////////////////////////////////////////////////////////////////////////////

program .get_nvars_in_data
	args macname

	mata: NumberOfVariables("nvars")

	c_local `macname' `nvars'
end

program .get_n_numeric_vars_in_data
	args macname

	mata: NumberOfNumericVariables("nvars")

	c_local `macname' `nvars'
end

program .get_count_of_vlsysname
	args macname colon name

	.assert_vlname `name', system

	local n = el(`.vlsysmat', 1, colnumb(`.vlsysmat', "`name'"))

	c_local `macname' `n'
end

program .get_count_of_vlusername
	args macname colon name

	.assert_vlname `name', user

	local n = el(`.vlusermat', 1, colnumb(`.vlusermat', "`name'"))

	c_local `macname' `n'
end

program .get_count_of_vlsys
	args macname

	c_local `macname' `.vlsys_nvars'
end

program .get_count_of_vluser
	args macname

	c_local `macname' `.vluser_nvars'
end

program .get_count_of_distinct_vluser
	args macname

	.get_vluser_varlist varlist

	local n : list sizeof varlist

	c_local `macname' `n'
end

program .get_diff_counts_of_vlsys
	args macname colon name

	// name is either _all or a vlsysname.

	if ("`name'" == "_all") {

		local diff 0
		local i 0

		foreach name in `.vlsysnames' {
			.get_count_of_vlsysname n_old : `name'
			local n_new : list sizeof global(`name')
			local diff = `diff' + `n_new' - `n_old'
		}
	}
	else {
		.get_count_of_vlsysname n_old : `name'
		local n_new : list sizeof global(`name')
		local diff = `n_new' - `n_old'
	}

	c_local `macname' `diff'
end

program .get_diff_counts_of_vluser
	args macname colon name

	// name is either _all or a vlusername.

	if ("`name'" == "_all") {

		local diff 0
		local i 0

		foreach name in `.vlusernames' {
			.get_count_of_vlusername n_old : `name'
			local n_new : list sizeof global(`name')
			local diff = `diff' + `n_new' - `n_old'
		}
	}
	else {
		.get_count_of_vlusername n_old : `name'
		local n_new : list sizeof global(`name')
		local diff = `n_new' - `n_old'
	}

	c_local `macname' `diff'
end

program .note_if_vlname_empty
	args name

	local n : list sizeof global(`name')

	if (`n' == 0) {
		di as txt "{p 0 6 2}"
		di as txt "note: {bf:$}{bf:`name'} contains no variables"
		di as txt "{p_end}"
	}
end

//////////////////////// .get miscellaneous utility /////////////////////////
//
//	.get_dups_of_string <macname_out> : # <string>
//
/////////////////////////////////////////////////////////////////////////////

program .get_dups_of_string
	args macname colon n svalue

	mata: DuplicateString("dups", `"`svalue'"', `n')

	c_local `macname' `"`dups'"'
end

///////////////////////// .is miscellaneous utility /////////////////////////
//
//	.is_namelist_in_master <macname_out> : "<namelist>" "<master_namelist>"
//
/////////////////////////////////////////////////////////////////////////////

program .is_namelist_in_master
	args macname colon namelist master

	local namelist : list uniq namelist
	local union    : list master | namelist
	local n_master : list sizeof master
	local n_union  : list sizeof union

	local is_in = (`n_master' == `n_union')

	c_local `macname' `is_in'
end

//////////////// .is utilities for vlsys and vluser macros //////////////////
//
//	.set_vl_set
//
//	.is_version_set <macname_out>
//
//	.is_vlsys_set <macname_out>
//
//	.is_vluser_set <macname_out>
//
//	.is_vldummy <macname_out>
//
//	.is_vlsysname <macname_out> : <name>
//
//	.is_vlusername <macname_out> : <name>
//
//	.is_vlfvname <macname_out> : <name>
//
//	.is_vlname <macname_out> : <name>
//
//	.is_vlnamelist <macname_out> : <namelist>
//
/////////////////////////////////////////////////////////////////////////////

program .set_vl_set

	// When flags are already set, no checks are done.

	if (`.vlsys_set' != . & `.vluser_set' != .) {
		exit
	}

	.is_version_set is_set

	if (`is_set') {

		// Either vlsys set or vluser set or both.

		Assert_vl_macros_ok, system

		Assert_vl_macros_ok, user

		Assert_varnames_in_data

		.vlsys_set  = ("`.vlsysnames'"  != "")
		.vluser_set = ("`.vlusernames'" != "")
	}
	else {
		.vlsys_set  = 0
		.vluser_set = 0
	}
end

program .is_version_set
	args macname

	// As a result of a merge, there could be _dta[_vl_version_1] and
	// _dta[_vl_version_`i'] where `i' > 1.

	local is_1 : char _dta[_vl_version_1]

	forvalues i = 2/99 {
		local is_2 : char _dta[_vl_version_`i']

		if ("`is_2'" != "") {
			continue, break
		}
	}

	if ("`is_1'" == "1" & "`is_2'" == "") {
		c_local `macname' 1
	}
	else if ("`is_1'" == "") {

		// There could be macros that need to be erased.
		// Other chars should not be there when _dta[_vl_version_1]
		// is not there, but .erase_vlnames erases them regardless.

		.erase_vlnames

		c_local `macname' 0
	}
	else {
		Error_newer_version
	}
end

program Error_newer_version

	di as err "{bf:vl} settings from a more recent version of {bf:vl} found"
	di as err "{p 4 4 2}"
	di as err "You need to {bf:update} your Stata."
	di as err "Type {helpb update}."
	di as err "{p_end}"
	exit 610
end

program .is_vlsys_set
	args macname

	if (`.vlsys_set' != .) {
		c_local `macname' `.vlsys_set'
		exit
	}

	.set_vl_set

	c_local `macname' `.vlsys_set'
end

program .is_vluser_set
	args macname

	if (`.vluser_set' != .) {
		c_local `macname' `.vluser_set'
		exit
	}

	.set_vl_set

	c_local `macname' `.vluser_set'
end

program .is_vldummy
	args macname
	
	local name  vldummy
	local names `.vlsysnames'

	local is_vldummy : list name in names

	c_local `macname' `is_vldummy'
end

program .is_vlsysname
	args macname colon name

	local names `.vlsysnames'

	local is_vlsysname : list name in names

	c_local `macname' `is_vlsysname'
end

program .is_vlusername
	args macname colon name

	local names `.vlusernames'

	local is_vlusername : list name in names

	c_local `macname' `is_vlusername'
end

program .is_vlfvname
	args macname colon name

	local names `.vlfvnames'

	local is_vlfvname : list name in names

	c_local `macname' `is_vlfvname'
end

program .is_vlname
	args macname colon name

	local names `.vlnames'

	local is_vlname : list name in names

	c_local `macname' `is_vlname'
end

program .is_vlnamelist
	gettoken macname 0 : 0
	gettoken colon   0 : 0

	cap syntax namelist
	if (c(rc) == 1) {
		error 1
	}
	else if (c(rc)) {
		c_local `macname' 0
		exit
	}

	.is_namelist_in_master is_in : "`namelist'" "`.vlnames'"

	c_local `macname' `is_in'
end

/////////////////////////////////////////////////////////////////////////////
//
//  Subroutines used by .set_vl_set:
//
//	Assert_vl_macros_ok, system
//
//	Assert_vl_macros_ok, user
//
//	Assert_varnames_in_data
//
//  Possible problems:
//
//	- User loads vl data, but forgets to run -vl rebuild-.
//	  Will be detected by Assert_vl_macros_ok. For example,
//
//		. use vl-data		<-- load vl-data
//		. vl move ...		<-- gives error
//
//		(vl chars exist, but no vl macros)
//
//	- Variable in vl, then dropped.
//	  Will be detected by Assert_varnames_in_data, which will give
//	  an error and tell user to run -vl rebuild-.
//
//	- vl chars exist, but vl macros do not match.
//	  Will be detected by Assert_varnames_in_data, which will give
//	  an error and tell user to run -vl rebuild-. For example,
//
//		. use non-vl-data
//		. vl set
//		. use vl-data, clear	<-- load different vl-data
//		. vl move ...		<-- gives error
//
//		(vl chars exist, but vl macros do not match)
//
//	- vl macros match variables in data, but vl chars not there.
//	  Will be detected by .set_vl_set. Not an error, just quietly
//	  erase macros. For example,
//
//		. use non-vl-data
//		. vl set
//		. use non-vl-data, clear   <-- load same dataset
//
//		(vl macros exist, but no vl chars)
//
//	- vl macros match variables in data, vl chars there, but they
//	  do not match. For example,
//
//		. use vl-data
//		. vl move ...
//		. use vl-data, clear   <-- load same dataset
//
//		(vl macros exist, but do not match vl chars)
//
//	  Will be detected in most cases (but not all) by
//	  .assert_vl_macro_ok. Not an error, just quietly erase macros.
//
//	- Merging:
//
//		master vl, using non-vl  <-- OK, nothing needs to be done
//
//		master non-vl, using vl  <-- no macros, detected by .assert_vl_macro_ok
//
//		master vl, using vl	 <-- not detectable, macros match _dta chars;
//					     user must know to run -vl rebuild-
//
/////////////////////////////////////////////////////////////////////////////

program Assert_vl_macros_ok
	syntax [, SYStem USER ]

	opts_exclusive "`system' `user'"

	local desc `system' `user'

	if ("`system'" != "") {
		local type sys
	}
	else {
		local type user
	}

	.get_count_of_vl`type' n_macro

	local n_char : char _dta[_vl`type'_nvars]

	// Not vl`type' set, or all variables removed from vl`type', which is ok.

	if (`n_macro' == 0 & (`"`n_char'"' == "0" | `"`n_char'"' == "")) {
		exit
	}

	// Not vl`type' set but macros exist.
	// Macros could be remnants from a previous vl dataset,
	// but a non-vl dataset is now in memory.
	// Quietly erase macros.

	if (`n_macro' > 0 & `"`n_char'"' == "") {
		.erase_vl`type'_macros
		exit
	}

	// vl`type' chars exist and macros exist.

	confirm integer number `n_char'

	if (`n_macro' == `n_char') {
		exit
	}

	if (`n_macro' == 0) {

		di as err "{bf:vl} `desc' macros not found"
	}
	else {

di as err "{bf:vl} `desc' macros do not match stored {bf:vl} characteristics"

	}

	Error_rebuild
	exit 459
end

program Assert_varnames_in_data

	local namelist `.vlnames'

	unab varlist : _all

	local ndropped 0

	foreach name of local namelist {
		local dropped  : list global(`name') - varlist
		local ndropped : list sizeof dropped

		if (`ndropped') {
			continue, break
		}
	}

	if (`ndropped')	{
		// Could be dropped variables or macros created from another
		// vl dataset. Error message must be neutral.

		local dvar : word 1 of `dropped'
		di as err "{p}variable {bf:`dvar'} not found{p_end}"

		Error_rebuild
		exit 111
	}
end

program Error_rebuild

di as err "{p 4 4 2}Run {bf: vl rebuild} to rebuild {bf:vl} macros.{p_end}"

end

////////////////////// .is utilities for variables //////////////////////////
//
//	.is_varlist <macname_out> : <varlist>
//
//	.is_numeric_variable <macname_out> : <varname>
//
//	.is_string_variable <macname_out> : <varname>
//
/////////////////////////////////////////////////////////////////////////////

program .is_varlist
	gettoken macname 0 : 0
	gettoken colon   0 : 0

	cap syntax varlist
	if (c(rc) == 1) {
		error 1
	}
	else if (c(rc)) {
		c_local `macname' 0
	}
	else  {
		c_local `macname' 1
	}
end

program .is_numeric_variable
	args macname colon varname

	.is_string_variable is_string : `varname'

	local numeric = !`is_string'

	c_local `macname' `numeric'
end

program .is_string_variable
	gettoken macname 0 : 0
	gettoken colon   0 : 0
	syntax varname

	local vartype : type `varlist'

	if (substr("`vartype'", 1, 3) == "str") {
		c_local `macname' 1
	}
	else {
		c_local `macname' 0
	}
end

//////////// .assert utilities for checking vlsys or vluser set /////////////
//
//	.assert_vlsys_set
//
//	.assert_vluser_set
//
//	.assert_vlsys_or_vluser_set
//
//	.assert_vlchars_set
//
/////////////////////////////////////////////////////////////////////////////

program .assert_vlsys_set

	.is_vlsys_set is_set

	if (!`is_set') {
		Error_not_vl_set
	}
end

program .assert_vluser_set

	.is_vluser_set is_set

	if (!`is_set') {
		Error_not_vluser_set
	}
end

program .assert_vlsys_or_vluser_set

	.set_vl_set

	if (!`.vlsys_set' & !`.vluser_set') {
		Error_not_vl_set
	}
end

program .assert_vlchars_set

	.is_version_set is_set

	if (!`is_set') {
		Error_not_vl_set
	}
end

program Error_not_vl_set

	di as err "data not {bf:vl set}"
	di as err "{p 4 4 2}"
	di as err "See {helpb vl:{bind:[D] vl}}."
	di as err "{p_end}"
	exit 459
end

program Error_not_vluser_set

	di as err "no {bf:vl} user macros exist"
	di as err "{p 4 4 2}"
	di as err "Run {bf:vl create} to create custom macros"
	di as err "that can be used with the {bf:vl} commands."
	di as err "See {helpb vl:{bind:[D] vl}}."
	di as err "{p_end}"
	exit 459
end

////////////////// .assert utilities for checking vlnames ///////////////////
//
//	.assert_vlname <name> [, SYStem user fv ]
//
//	.assert_vlnames <namelist> [, SYStem user fv ]
//
/////////////////////////////////////////////////////////////////////////////

program .assert_vlname
	syntax [anything] [, SYStem user fv ]

	.assert_vlnames `anything', `system' `user' `fv' one
end

program .assert_vlnames
	syntax [anything] [, SYStem user fv one ]

	local n : list sizeof anything

	if (`n' == 0) {
		Error_vlnames `0'
	}

	if (`n' > 1 & "`one'" != "") {
		di as err "one {it:vlname} expected but `n' specified"
		exit 103
	}

	if ("`system'" != "") {
		local names `.vlsysnames'
	}
	
	if ("`user'" != "") {
		local names `names' `.vlusernames'
	}

	if ("`fv'" != "") {
		local names `names' `.vlfvnames'
	}
	
	.is_namelist_in_master is_in : "`anything'" "`names'"

	if (!`is_in') {
		Error_vlnames `0'
	}
end

program	Error_vlnames
	syntax [anything] [, system user fv one ]
	
	if ("`system'" != "") {
		local names `.vlsysnames'
	}
	
	if ("`user'" != "") {
		local names `names' `.vlusernames'
	}

	if ("`fv'" != "") {
		local names `names' `.vlfvnames'
	}

	local n : list sizeof names

	if (`n' == 0) {
		di as err "{bf:vl} macros not found"
		exit 111
	}

	local anything : list uniq anything
	local anything : list anything - names

	gettoken name : anything
	
	if ("`user'" != "" & "`fv'" == "") {
	
		.is_vlfvname is_vlfvname : `name'
		
		if (`is_vlfvname') {
			di as err "{bf:`name'} not allowed"
			di as err "{p 4 4 2}"
			di as err "{it:vlusernames} containing factor variables"
			di as err "not allowed in this context"
			exit 198
		} 
	}

	if ("`name'" == "") {
		di as err "nothing found where " _c
	}
	else {
		di as err `"{bf:`name'} found where "' _c
	}

	if ("`system'" != "" & "`user'" == "") {
		di as err "{it:vlsysname} expected"
	}
	else if ("`system'" == "" & "`user'" != "") {
		di as err "{it:vlusername} expected"
	}
	else {
		di as err "{it:vlname} expected"
	}

	tokenize `names'

	if ("`system'" != "" & "`user'" == "" & "`fv'" == "") {
		local names = plural(`n', "vlsysname")
	}
	else if ("`system'" == "" & "`user'" != "") {
		local names = plural(`n', "vlusername")
	}
	else {
		local names = plural(`n', "vlname")
	}

	di as err "{p 4 4 2}"
	di as err "Allowed {it:`names'}"
	di as err plural(`n', "is", "are")

	if (`n' == 1) {
		di as err "{bf:`1'}."
	}
	else if (`n' == 2) {
		di as err "{bf:`1'} or {bf:`2'}."
	}
	else {
		local nm1 = `n' - 1

		forvalues i = 1/`nm1' {
			di as err "{bf:``i''},"
		}

		di as err "or {bf:``n''}."
	}

	di as err "{p_end}"

	di as err "{p 4 4 2}"
	di as err "{it:vlnames} are typed {it:without} the"
	di as err "leading dollar sign ({bf:$})."
	di as err "Example: {bf:vlcategorical} {it:not}"
	di as err "{bf:$}{bf:vlcategorical}."
	di as err "See {helpb vl:{bind:[D] vl}}."
	di as err "{p_end}"

	exit 198
end

///////////////// .assert utilities for checking varlists ///////////////////
//
//	.assert_varlist <varlist> [, list strok ]
//
//	.assert_numeric_varlist <varlist> [, list ]
//
//	.assert_variables_in_vlsys <varlist> [, move ]
//
//	.assert_variables_in_vluser <varlist>
//
//	.assert_variables_in_vl <varlist>
//
//	.assert_variables_not_in_vlsys <varlist>
//
/////////////////////////////////////////////////////////////////////////////

program .assert_varlist
	syntax [anything] [, list strok ]

	if ("`strok'" == "") {
		.assert_numeric_varlist `anything', `list'
	}
	else {
		syntax varlist [, * ]
	}
end

program .assert_numeric_varlist
	syntax [anything] [, list ]

	if ("`list'" == "") {
		syntax varlist(numeric) [, * ]
		exit
	}

	// Message for list.

	cap noi syntax varlist(numeric), list
	if (c(rc) == 109) {
		di as err "{p 4 4 2}"
		di as err "Option {bf:strok} can be specified to include"
		di as err "string variables in the listing."
		di as err "{p_end}"
		exit 109
	}
	else if (c(rc)) {
		exit c(rc)
	}
end

program .assert_variables_in_vlsys
	syntax varlist(numeric) [, move ]

	local varlist : list uniq varlist

	foreach name in `.vlsysnames' {
		local vlsysvars `vlsysvars' ${`name'}
	}

	.is_namelist_in_master is_in : "`varlist'" "`vlsysvars'"

	if (`is_in') {  // no new variables
		exit
	}

	local newvars : list varlist - vlsysvars
	local n       : list sizeof newvars

	di as err "one or more variables not in {bf:vl} system macros"

	di as err "{p 4 4 2}"

	if ("`move'" != "") {
		di as err "You requested that variables be moved across"
		di as err "classifications, but specified some that were not"
		di as err "in the classifications."
	}

	di as err "To add new variables to the classifications, run"
	di as err "{bf:vl set}."
	di as err "{p_end}"

	di as err "{p 4 4 2}"
	di as err "The"
	di as err plural(`n', "variable")
	di as err "not in {bf:vl} system macros"
	di as err plural(`n', "is", "are")
	di as err "{bf:`newvars'}."
	di as err "{p_end}"

	exit 111
end

program .assert_variables_in_vluser
	syntax varlist

	local varlist : list uniq varlist

	foreach name in `.vlusernames' {
		local vluservars `vluservars' ${`name'}
	}

	.is_namelist_in_master is_in : "`varlist'" "`vluservars'"

	if (`is_in') {  // no new variables
		exit
	}

	local newvars : list varlist - vluservars
	local n       : list sizeof newvars

	di as err "one or more variables not in {bf:vl} user macros"

	di as err "{p 4 4 2}"
	di as err "To add new variables to the classifications,"
	di as err "run {bf:vl create} or {bf:vl modify}."
	di as err "{p_end}"

	di as err "{p 4 4 2}"
	di as err "The"
	di as err plural(`n', "variable")
	di as err "not in {bf:vl} user macros"
	di as err plural(`n', "is", "are")
	di as err "{bf:`newvars'}."
	di as err "{p_end}"

	exit 111
end

program .assert_variables_in_vl
	syntax varlist

	local varlist : list uniq varlist
	
	foreach name in `.vlnames' {
		local vlvars `vlvars' ${`name'}
	}

	.is_namelist_in_master is_in : "`varlist'" "`vlvars'"

	if (`is_in') {  // no new variables
		exit
	}

	local newvars : list varlist - vlvars
	local n       : list sizeof newvars

	di as err "one or more variables not in {bf:vl} system or user macros"

	di as err "{p 4 4 2}"
	di as err "To add new variables to the classifications,"
	di as err "use the commands {bf:vl set}, {bf:vl create}, or"
	di as err "{bf:vl modify}."
	di as err "{p_end}"

	di as err "{p 4 4 2}"
	di as err "The"
	di as err plural(`n', "variable")
	di as err "not in {bf:vl} system or user macros"
	di as err plural(`n', "is", "are")
	di as err "{bf:`newvars'}."
	di as err "{p_end}"

	exit 111
end

program .assert_variables_not_in_vlsys
	syntax varlist [, short ]

	foreach name in `.vlsysnames' {
		local vlsysvars `vlsysvars' ${`name'}
	}

	local insys : list varlist & vlsysvars
	local n     : list sizeof insys

	if (`n' == 0) {  // all new variables
		exit
	}

	di as err "one or more already classified variables specified"

	di as err "{p 4 4 2}"
	di as err "You requested that variables be added to {bf:vl}'s"
	di as err "system classifications, but you specified `n'"
	di as err plural(`n', "variable")
	di as err "that"
	di as err plural(`n', "was", "were")
	di as err "already classified."
	di as err "{p_end}"

	if ("`short'" == "") {
		di as err "{p 4 4 2}"
		di as err "The already classified"
		di as err plural(`n', "variable is", "variables are")
		di as err "{bf:`insys'}."
		di as err "{p_end}"
	}

	exit 110
end

////////////////// .assert utilities for low-level parsing //////////////////
//
//	.assert_colon <whatever>
//
//	.assert_eq_sign <whatever>
//
//	.assert_next_token_nothing <whatever>
//
//	.assert_operator <whatever>
//
/////////////////////////////////////////////////////////////////////////////

//	Aborts with error when <op> is not + or -.

program .assert_colon
	// '.assert_eq_colon :'   gives an error.
	// '.assert_eq_colon ":"' is used instead.

	local 0 `0'  // strip quotes

	Assert_is_something `"`0'"' ":" "colon ({bf::})"
end

program .assert_eq_sign
	// '.assert_eq_sign ='   gives an error.
	// '.assert_eq_sign "="' is used instead.

	local 0 `0'  // strip quotes
	Assert_is_something `"`0'"' "=" "equals sign ({bf:=})"
end

program .assert_next_token_nothing
	gettoken token 0 : 0

	if (`"`token'"' != "") {
		di as err `"{bf:`token'} found where nothing expected"'
		exit 198
	}
end

program .assert_operator
	args op

	if (`"`op'"' != "+" & `"`op'"' != "-") {
		Error_assert_failure `"`op'"' "{bf:+} or {bf:-}"
	}
end

program Assert_is_something
	args whatever something description

	if (`"`whatever'"' == `"`something'"') {
		exit
	}

	Error_assert_failure `"`whatever'"' `"`description'"'
end

program Error_assert_failure
	args whatever description

	if (`"`whatever'"' == "") {
		di as err "nothing" _c
	}
	else {
		di as err `"{bf:`whatever'}"' _c
	}

	di as err `" found where `description' expected"'
	exit 198
end

////////////////////////////// Mata utilities ///////////////////////////////

version 16
mata:
mata set matastrict on

// Returns m_out filled in with svalue duplicated n times.
// If n <= 1, returns svalue.

void DuplicateString(string scalar m_out,
		     string scalar svalue,
		     real   scalar n)
{
	real scalar    i
	string scalar  dups

	dups = svalue

	for (i = 2; i <= n; ++i) {
		dups = dups + " " + svalue
	}

	st_local(m_out, dups)
}

// Erases the varname chars in charlist.
// By default, it erases chars for all variables in the data.
// Optionally, it only erases chars in local m_varlist.

void EraseVarChars(string scalar charlist, | string scalar m_varlist)
{
	real   scalar     i, j, nchar, nvar
	string scalar     macname, varname
	string rowvector  c, v

	c = tokens(charlist)

	nchar = length(c)

	if (args() == 1) {
		nvar = st_nvar()
	}
	else {
		v = tokens(st_local(m_varlist))
		nvar = length(v)
	}

	for (i = 1; i <= nvar; ++i) {

		if (args() == 1) {
			varname = st_varname(i)
		}
		else {
			varname = v[i]
		}

		for (j = 1; j <= nchar; ++j) {

			macname = varname + "[" + c[j] + "]"

			st_global(macname, "")
		}
	}
}

// Returns m_out filled in with all the numeric variables in the data.

void GetNumericVariables(string scalar m_out)
{
	real   scalar     i, j, nvar
	string rowvector  s

	st_local(m_out, "")

	nvar = st_nvar()

	s = J(1, nvar, "")

	j = 0

	for (i = 1; i <= nvar; ++i) {

		if (st_isnumvar(i)) {
			s[++j] = st_varname(i)
		}
	}

	st_local(m_out, invtokens(s))
}

void NumberOfVariables(string scalar m_nvars)
{
	st_local(m_nvars, strofreal(st_nvar()))
}

void NumberOfNumericVariables(string scalar m_nvars)
{
	real scalar  i, n, nvar

	st_local(m_nvars, "")

	nvar = st_nvar()

	n = 0

	for (i = 1; i <= nvar; ++i) {
		if (st_isnumvar(i)) {
			++n
		}
	}

	st_local(m_nvars, strofreal(n))
}

// Returns m_out filled in with the maximum length of the names in m_namelist.
// If this value is less than min, it returns min.

void MaxLengthNames(  string scalar m_out,
		      string scalar m_namelist,
		    | real   scalar min)
{
	real   scalar     maxlength
	string rowvector  s

	s = tokens(st_local(m_namelist))

	if (length(s) == 0) {
		st_local(m_out, strofreal(0))
		return
	}

	if (args() == 2) {
		min = 0
	}

	maxlength = max((max(udstrlen(s)), min))

	st_local(m_out, strofreal(maxlength))
}

// Set vlsys and vluser global macros from variable chars.

void SetGlobalsFromVarChars()
{
	real   scalar     i, j, nsys, nuser, nvar
	string scalar     varname, vlsysname
	string rowvector  v
	transmorphic      S, U

	st_global("_dta[_vlsys_nvars]", "")
	st_global("_dta[_vluser_nvars]", "")

	nvar = st_nvar()

	if (nvar == 0) {
		return
	}

	S = asarray_create()
	U = asarray_create()

	nsys  = 0
	nuser = 0

	for (i = 1; i <= nvar; ++i) {

		varname = st_varname(i)

		vlsysname = st_global(varname + "[_vlsysname]")

		if (vlsysname != "") {
			SetGlobal(vlsysname, varname, S)
			++nsys
		}

		v = tokens(st_global(varname + "[_vlusernames]"))

		for (j = 1; j <= length(v); ++j) {
			SetGlobal(v[j], varname, U)
			++nuser
		}
	}

	st_global("_dta[_vlsys_nvars]", strofreal(nsys))

	if (nuser > 0) {
		st_global("_dta[_vluser_nvars]", strofreal(nuser))
	}
}

void SetGlobal(string scalar vlname,
	       string scalar varname,
	       transmorphic  A)
{
	if (asarray_contains(A, vlname)) {
		st_global(vlname, st_global(vlname) + " " + varname)
	}
	else {
		asarray(A, vlname, 0)  // add to A
		st_global(vlname, varname)
	}
}

end

exit

Set by -vl set-:

	char _dta[_vl_version_1]	// equals 1; used for merge
	char _dta[_vlsysnames]
	char _dta[_vlsys_has_dummy]	// equals "1" or ""; used for merge
	char _dta[_vlsysnames_desc]
	char _dta[_vl_levels_desc]
	char _dta[_vlsys_nvars]

	char `varname'[_vlsysname]
	char `varname'[_vl_nlevels]
	char `varname'[_vl_min]
	char `varname'[_vl_max]
	char `varname'[_vl_N]

Set by -vl create-:

	char _dta[_vlusernames]
	char _dta[_vlusernames_desc]	// not updated when vlusername removed
	char _dta[_vluser_nvars]
	
set by -vl substitute-:

	char _dta[_vlfvnames]
	char _dta[_vl__<name>]		// _vl__ so "min" etc are allowed

END OF FILE

