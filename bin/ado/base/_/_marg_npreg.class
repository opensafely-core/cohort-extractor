*! version 1.1.5  06may2019

class _marg_npreg {

} , inherit(_marg_work)

program .new
	.vv = string(_caller())
	syntax name(name=tname id="tempname")
	if "`e(b)'" != "matrix" {
		error 301
	}
	if "`e(cmd2)'" != "" {
		.ecmd = "`e(cmd2)'"
	}
	else	.ecmd = "`e(cmd)'"
	if `"`e(marginsnotok)'"' == "_ALL" {
		di as err ///
		"command {bf:margins} not appropriate after {bf:`.ecmd'}"
		exit 322
	}
	if "`e(cmd)'" == "margins" {
		di as err ///
		"{bf:margins} cannot work with its own posted results"
		exit 322
	}
	.t_name	= "`tname'"
	.t_touse= "`tname'_touse"
	.t_sub	= "`tname'_sub"
	.t_esub	= "`tname'_esub"
	.t_wvar	= "`tname'_wvar"
	.t_marg	= "`tname'_marg"
	.t_at	= "`tname'_at"
	.t_cr	= "`tname'_cr"
	.t_grp	= "`tname'_grp"
	.t_gmat	= "`tname'_gmat"
	.t_phat	= "`tname'_phat"
	.t_dx	= "`tname'_dx"
	.t_dzb	= "`tname'_dzb"
	.t_altb	= "`tname'_altb"
	.t_H	= "`tname'_H"
	local covar `"`e(covariates)'"'
	local k : list sizeof covar
	if `k' {
		matrix `.t_altb' = J(1,`k',0)
		capture {
			matrix colna `.t_altb' = `covar'
		}
		if c(rc) {
			capture matrix drop `.t_altb'
			.t_altb = ""
		}
	}
	else	.t_altb = ""
	if `"`.t_altb'"' != "" {
		local margprop `"`e(marginsprop)'"'
		local prop noeb
		if `:list prop in margprop' {
			_ms_op_info `.t_altb'
			if r(tsops) {
				di as err ///
"{bf:margins} cannot work with time-series operators in " ///
"{bf:`.ecmd'} estimation results"
				exit 322
			}
			.FVTImatopt = `"matrix(`.t_altb')"'
		}
		.matopt = `"matrix(`.t_altb')"'
	}
	.is_xb[1]	= 0
	.eqno[1]	= 0
	.offset[1]	= 0
	.footnote	= `"`e(marginsfootnote)'"'
end

program .parse
	.est_cmd = `"`e(cmd)'"'
	.cmdline = `"`e(cmdline)'"'
	.ZERO = `"`0'"'
	syntax [anything] [if] [in] [fw aw iw pw] [,	///
			refit(passthru)			/// ignored
			Level(cilevel)			///
			grand				///
			ATMEANs				///
			ASBALanced			///
			ASOBServed			/// default
			SUBpop(passthru)		///
			by(passthru)			///
			over(passthru)			///
			within(passthru)		///
			EMPTYCells(string)		///
			NOWEIGHTs			///
			NOEsample			///
			post				///
			SAVing(string)			///
			NOSE				///
			VCE(passthru)			///
			NOCHAINrule CHAINrule		///
			chain2				/// NOT DOCUMENTED
			noestimcheck			///
			force				///
			vsquish				///
			PRedict(passthru)		/// -predict- options
			EXPression(string)		///
			numerical			/// NOT DOCUMENTED
			atslow				/// NOT DOCUMENTED
			dydx(passthru)			///
			eyex(passthru)			///
			dyex(passthru)			///
			eydx(passthru)			///
			CONTinuous			///
			NOATLegend			///
			MCOMPare(passthru)		///
			CONTRast			///
			CONTRast1(string)		///
			PWCOMPare			///
			PWCOMPare1(string)		///
			Reps(string)			///
			seed(string)			///
			ESTIMTOLerance(real 1e-5)	///
			DF(numlist max=1 >0 missingok)	///
			GENerate(name)			///
			ATVARs(varlist numeric)		/// -at()- options
			PLOT				///
			PLOTopts(string asis)		///
			*				///
			]
			
	.cuales = `"`anything'"'
	.deriva = `"`dydx'"'
	.mykp2  = "`e(covariates)'"
	
	if ("`grand'"!="" & "`asobserved'"=="") {
		local zeronovo `0'
		local zeronovo: list zeronovo - grand
		local 0 `zeronovo'
		.ZERO = `"`zeronovo'"'
		local grand ""
	}
	
	if ("`asobserved'"!="" & "`grand'"=="") {
		local zeronovo `0'
		local zeronovo: list zeronovo - asobserved
		local 0 `zeronovo'
		.ZERO = `"`zeronovo'"'
		local asobserved ""
	}
	
	if ("`asobserved'"!="" & "`grand'"!="") {
		local zeronovo `0'
		local zeronovo: list zeronovo - asobserved
		local zeronovo: list zeronovo - grand
		local 0 `zeronovo'
		.ZERO = `"`zeronovo'"'
		local asobserved ""
		local grand ""
	}
	
	if ("`emptycells'"!="") {
		display as error ///
		"option {bf:emptycells()} not allowed after {bf:npregress}"
		exit 198
	}
	
	local lgenerate : length local generate
	local lgmax 16
	if `lgenerate' > `lgmax' {
		di as err "{p}"
		di as err "invalid {bf:generate()} option;{break}"
		di as err "stub name may not exceed `lgmax' characters"
		di as err "{p_end}"
		exit 198
	}
	.genstub = "`generate'"
	if "`generate'" != "" {
		.use_in1 = 0
	}

	if _caller() >= 12 {
		if `estimtolerance' < 0 {
			di as err "invalid {bf:estimtolerance()} option;"
			di as err "negative values not allowed"
			exit 198
		}
		.est_tol = `estimtolerance'
	}

	if `:length local contrast1' {
		local contrast contrast
	}
	if `:length local pwcompare1' {
		local pwcompare pwcompare
	}
	opts_exclusive "`contrast' `pwcompare'"
	.has_contrast = "`contrast'" != ""
	.has_pwcompare = "`pwcompare'" != ""

	.level	= `level'
	_get_diopts diopts options, `options'
	.diopts = `"`diopts' `vsquish' level(`level')"'

	// check for invalid option combinations
	opts_exclusive `"`weight' `noweights'"'
	opts_exclusive `"`vce' `nose'"'
	opts_exclusive `"`chainrule' `nochainrule' `chain2'"'
	opts_exclusive `"`dydx' `eyex' `dyex' `eydx'"'
	
	local elasticities "`eyex'`dyex'`eydx'"
	if ("`elasticities'"!="") {
		display as error "option {bf:`elasticities'} is not allowed"
		di as err "{p 4 4 2}" 	
		di as smcl as err "Elasticities and" 
		di as smcl as err "semielasticities are not available" 
		di as smcl as err "after {bf:`e(cmd)'}."
		di as smcl as err "{p_end}"	
		exit 198		
	}
	if ("`pred'"!="") {
		display as error `"`a' `b'"'
		di as err "{p 4 4 2}" 
		di as smcl as err "{bf:predict} is not allowed after"	
		di as smcl as err " {bf:npregress}. Predicted values for the"		
		di as smcl as err " structural function and its standard" 
		di as smcl as err " error and for the gradients and their"
		di as smcl as err " standard errors are generated by default"
		di as smcl as err " by {bf:npregress}."
		di as smcl as err "{p_end}"
		exit 198	
	}
	.force	= "`force'" != ""
	.wtype	= "`weight'"
	.wexp	= "`exp'"
	.est_chk= "`estimcheck'" == ""
	.est_chk= 0
	if `.est_chk' {
		quietly _get_hmat `.t_H'
		if r(rc) {
			.t_H = ""
			.noHmat = 1
			.est_chk = 0
		}
	}

	// parse the multiple -predict()- options
	.first[1] = 1
	if `"`predict'"' != "" | `"`expression'"' == "" {
		if `"`predict'"' == "" & `.vv' >= 14 {
			local predict `"`e(marginsdefault)'"'
			.margdflt = `"`predict'"'
		}
		._parse_predict, `predict' `options'
		local options `"`r(options)'"'
	}

	// parse the multiple -at()- options
	.atlegend = "`noatlegend'"
	.atmean	= "`atmeans'" != ""
	if (e(cdnum)>1 & "`atmeans'" != ""){
		 display as error ///
		"incorrect {bf:margins} specification after" ///
		" {bf:npregress kernel}"
		di as err "{p 4 4 2}" 
		di as smcl as err "The kernel used for discrete"
		di as smcl as err " covariates is only well defined" 
		di as smcl as err " for the original values of the" 
		di as smcl as err " discrete covariates. The kernel is" 
		di as smcl as err " degenerate at values other than" 
		di as smcl as err " the original discrete levels," 
		di as smcl as err " such as the mean." 
		di as smcl as err "{p_end}"
		exit 198
	}
	opts_exclusive "`asbalanced' `asobserved'"
	._parse_atvarsopt `atvars'
	._parse_at, `options'
	._parse_emptycells, `emptycells'

	// multiple subpopulations
	opts_exclusive "`by' `over'"
	._parse_by, `by' `over' `within'

	if "`.empty'" == "" {
		.empty = "strict"
	}

	// managing the results
	.post	= "`post'" != ""
	if !`.post' {
		._parse_post_required, `diopts'
	}
	.saving	= "`saving'"

	// the -vce()- option
	if ("`nose'"=="" & `.has_pwcompare'==0) {
		local nose "nose"
	}
	.nose	= "`nose'"
	.se	= `:length local nose' == 0
	._parse_vce, `vce'
	if `"`.genstub'"' != "" {
		.gen = 1
	}

	if `.is_svy' & `.lin' {
		if `:length local noweights' {
			di as err "{p}" ///
"option {bf:noweights} not allowed with {bf:vce(unconditional)} " ///
"and {bf:svy} estimation results{p_end}"
			exit 198
		}
		._check_svyset
		local esubpop "`e(subpop)'"
	}

	if !`:length local noweights' {
		if `"`.wtype'"' == "" {
			if `"`e(marginswtype)'"' != "" {
				.wtype	= `"`e(marginswtype)'"'
				.wexp	= `"`e(marginswexp)'"'
			}
			else {
				.wtype	= `"`e(wtype)'"'
				.wexp	= `"`e(wexp)'"'
			}
		}
		local weight `"`.wtype'"'
		local exp `"`.wexp'"'
	}
	if `.is_svy' | "`.wtype'" == "iweight" {
		local zero zeroweight
	}

	local UCONS _cons
	// estimation sample
	.esample = "`noesample'" == ""
	if `.esample' | "`.vce'" == "unconditional" {
		if `.esample' | !`.force' {
			._check_esample
			quietly gen byte `.t_touse' = e(sample)
		}
		else {
			quietly gen byte `.t_touse' = 1
		}
		local IF : copy local if
		local if
		local IN : copy local in
		local in
		if `"`weight'"' == "" {
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse weights
		}
		if `:length local IF' {
			local if : copy local IF
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse {bf:if} restriction
		}
		if `:length local IN' {
			local in : copy local IN
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse {bf:in} range
		}
		if `.is_svy' {
			svymarkout `.t_touse'
			._check_touse {bf:svy} settings
		}
		local atvars : colna `.atlist[1]'
		local atvars : list atvars - UCONS
		if `:length local esubpop' {
			_svy_subpop `.t_touse' `.t_esub', ///
				subpop(`esubpop')
			._check_touse {bf:subpop()} option
			if `:length local exp' {
				gettoken EQUAL W : exp
				quietly replace `.t_esub' = 0 if `W' == 0
			}
			tempname subuse
			quietly gen byte `subuse' = `.t_esub'
			markout `subuse' `atvars'
			quietly replace `.t_touse' = 0 if `.t_esub' & !`subuse'
		}
		else {
			.t_esub = ""
			markout `.t_touse' `atvars'
		}
		._check_touse indepvars
	}
	else {
		marksample touse, novarlist `zero'
		rename `touse' `.t_touse'
		if `.is_svy' {
			svymarkout `.t_touse'
		}
		if `:length local esubpop' {
			_svy_subpop `.t_touse' `.t_esub', subpop(`esubpop')
		}
		else {
			.t_esub = ""
		}
		local atvars : colna `.atlist[1]'
		local atvars : list atvars - UCONS
		markout `.t_touse' `atvars'
	}

	if `:length local subpop' {
		tempname touse
		quietly gen byte `touse' = `.t_touse'
		_svy_subpop `touse' `.t_sub', `subpop'
		drop `touse'
		.subpop = `"`r(subpop)'"'
	}
	else {
		quietly gen byte `.t_sub' = `.t_touse'
	}

	// weights
	if "`.posts'" != "" {
		tempvar wvar
		svygen post double `wvar'	///
			[`.wtype'`.wexp']	///
			if `.t_touse',		///
			posts(`.posts')		///
			Postw(`.postw')
	}
	else if "`.wtype'" != "" {
		tempvar wvar
		quietly gen double `wvar' `.wexp'
	}

	if `:length local wvar' & `:length local zero' {
		quietly replace `.t_sub' = 0 if `wvar' == 0
		if "`.t_esub'" != "" {
			quietly replace `.t_esub' = 0 if `wvar' == 0
		}
	}

	if `:length local by' {
		quietly count if `.t_sub'
		local nsub = r(N)
		markout `.t_sub' `.by'
		quietly count if `.t_sub'
		if `nsub' != r(N) {
			if `:list sizeof by' > 1 {
				local vars "variables"
			}
			else	local vars "variable"
			local nsub = `nsub' - r(N)
			if `nsub' > 1 {
				local obs "observations"
			}
			else	local obs "observation"
			if "`.over'" != "" & "`.within'" != "" {
				local msg "over() or within()"
			}
			else if "`.over'" != "" {
				local msg "over()"
			}
			else {
				local msg "within()"
			}
			di as txt "{p 0 7}(note: " ///
"`nsub' `obs' dropped because of missing values in `msg' `vars')" ///
			"{p_end}"
		}
	}

	quietly count if `.t_sub'
	if r(N) == 0 {
		error 2000
	}
	if "`.wtype'" == "fweight" {
		._check_fweight
		sum `.t_touse' [`.wtype'`.wexp'] if `.t_touse', mean
		.nobs = r(sum_w)
		sum `.t_sub' [`.wtype'`.wexp'] if `.t_sub', mean
		.subnobs = r(sum_w)
	}
	else {
		quietly count if `.t_touse'
		.nobs	= r(N)
		quietly count if `.t_sub'
		.subnobs= r(N)
	}

	if `:length local wvar' {
		rename `wvar' `.t_wvar'
		if inlist("`.wtype'", "", "pweight") {
			.wt = "[iweight=`.t_wvar']"
		}
		else {
			.wt = "[`.wtype'=`.t_wvar']"
		}
		.wt_hold = `"`.wt'"'
	}

	local margprop `"`e(marginsprop)'"'
	local prop nochainrule
	if `:list prop in margprop' {
		local nochainrule nochainrule
	}

	if "`.t_altb'" == "" | `.at_b_dim' {
		// determine chainrule status for partial derivatives
		_ms_chainrule b if `.t_sub', eclass
		.cr_any	= r(any)
		.cr_all	= r(all)
		matrix `.t_cr' = r(chainrule)
		if !`.cr_any' {
			.cr_use = 0
		}
	}
	else {
		local nochainrule nochainrule
		local numerical numerical
	}

	// always use numerical derivatives
	if `:length local numerical' {
		.numeric = 1
	}

	// always use calculations across observations even when all 'at'
	// variables and 'margin' variables are fixed/constant
	if `:length local atslow' {
		.use_in1 = 0
	}

	// parse the prediction expression
	if `:length local expression' {
		display as error "option {bf:expression()} is not allowed" ///
			" after {bf:npregress}"
		exit 198
	}

	._check_predict

	if "`df'" != "" {
		if !missing(`df') {
			.df_r = `df'
		}
	}
	else if _caller() >= 13 {
		if `.is_pred' & !missing(e(df_r)) {
			local df_r = e(df_r)
			forval i = 1/`._pred.arrnels' {
				if !`.is_xb[`i']' {
					local df_r 0
					continue, break
				}
			}
			.df_r = `df_r'
		}
	}

	if `._pred.arrnels' == 0 {
		if `:length local chainrule' {
			di as err "option {bf:chainrule} not allowed"
			exit 198
		}
		if `:length local chain2' {
			di as err "option {bf:chain2} not allowed"
			exit 198
		}
		local nochainrule nochainrule
	}
	else if `:length local chainrule' | `:length local chain2' {
		local nochainrule
	}
	if "`nochainrule'" != "" {
		.cr_use = 0
	}
	else if `:length local chain2' & `.cr_any' {
		.cr_use2 = 1
	}

	// parse marginal effects and elasticities
	._parse_dydx, `dydx' `eyex' `dyex' `eydx' `continuous'

	// determine the margins at which to do our calculations
	local grand : length local grand
	if `:length local anything' {
		.hasm = 1
		._parse_margins `anything'
	}
	else {
		local grand 1
	}

	_get_mcompare margins, `mcompare'
	.mc_method	= `"`s(method)'"'
	.mc_all		= `"`s(adjustall)'"'
	.mcompareopt	= `"mcompare(`s(method)' `s(adjustall)')"'

	if `.has_contrast' {
		._parse_contrast_opts, `contrast1'
		.contrastoptsnp = `"`contrast1'"'
	}
	else {
		.contrastoptsnp = " "
	}
	if `.has_pwcompare' {
		._parse_pwcompare_opts, `pwcompare1'
	}
	if `grand' {
		local i = `.mlist.arrnels' + 1
		local margi "`.t_marg'`i'"
		.mlist[`i'] = "`margi'"
		matrix `margi' = 1
		matrix colna `margi' = _cons
	}

	if `"`.genstub'"' != "" {
	    if `.has_contrast' {
		di as err "option {bf:generate()} not allowed with contrasts"
			exit 198
	    }
	    if `.has_pwcompare' {
		di as err ///
		"option {bf:generate()} not allowed with pairwise comparisons"
		exit 198
	    }
	}

	._check_by_and_at
	if `.is_pred' {
		forval i = 1/`._pred.arrnels' {
			._check_exp if `.t_sub' `.wt', `nose' pred(`i')
		}
	}
	else {
		._check_exp if `.t_sub' `.wt', `nose'
	}

	if `"`.xvars'"' == "" {
		if `.noasobs' {
			.title	= "Adjusted predictions"
		}
		else {
			.title	= "Predictive margins"
		}
	}
	else {
		if `.noasobs' {
			.title	= "Conditional marginal effects"
		}
		else {
			.title	= "Average marginal effects"
		}
	}
	if `:length local saving' {
		_prefix_saving `saving'
		.saving		= "`s(filename)'"
		.sav_double	= "`s(double)'"
		.sav_replace	= "`s(replace)'"
	}
	local plot = `"`plot'"' != ""
	if `"`plotopts'"' != "" {
		local plot = 1
	}
	.plot		= `plot'
	.plotopts	= `"`plotopts'"'
end

program .destructor
	capture drop `.t_touse'
	capture drop `.t_sub'
	capture drop `.t_esub'
	capture drop `.t_wvar'
	local k = `.mlist.arrnels'
	forval i = 1/`k' {
		capture matrix drop `.mlist[`i']'
	}
	local k = `.atlist.arrnels'
	forval i = 1/`k' {
		capture matrix drop `.atlist[`i']'
	}
	capture matrix drop `.t_cr'
	capture drop `.t_grp'
	capture matrix drop `.t_gmat'
	local k = `._phat.arrnels'
	forval i = 1/`k' {
		capture drop `._phat[`i']'
	}
	local k = `.dxmlist.arrnels'
	forval i = 1/`k' {
		capture matrix drop `.dxmlist[`i']'
	}
	if "`.t_dzb'" != "" {
		capture drop `.t_dzb'*
	}
	if "`.t_altb'" != "" {
		capture matrix drop `.t_altb'
	}
	if "`.t_H'" != "" {
		capture matrix drop `.t_H'
	}
	local fin = e(kscores)*2 + 1
	local finito = 0
	if (e(kscores)==.) {
		local fin = 100
	}
	forvalues i=2/`fin' {
		capture drop __npreg__pre`i'
	} 
	.matopt == ""
	.FVTImatopt == ""
end

program .compute, rclass
	syntax [if] [in] [fw aw iw pw]	///
		[,	check		///
			GENerate(name)	///
			replace		///
			next		///
			pred(int 1)	///
		]

	set marginscmd on
	local ln0 0
	local check : length local check
	local next : length local next
	if `next' {
		local next = `.gen'
	}
	tempname t
	local n = `._pred.arrnels'
	if `n' {
		local y `._pred[`pred'].varname'
	}
	else {
		tempname y
		quietly gen double `y' = . in 1
	}
	local gen : length local generate
	if `gen' {
		if !`:length local replace' {
			confirm new var `generate'
		}
	}
	._repost
	if `.is_xb[`pred']' & ! `.numeric' {
		_ms_means b `if' `in' [`weight'`exp'], ///
			eclass fill0 `._pred[`pred'].eq'
		matrix `t' = r(means)
		return matrix db `t'
		return scalar constant = 0
		if `gen' | `next' | `.offset[`pred']'	///
		 | `.ey' | `.ex' | `.first[`pred']' {
			._pred[`pred'].Predict `if' `in'
			if `.ey' {
				if !`check' {
					capture assert `y' > 0 `if' `in'
					local ln0 = c(rc) != 0
				}
				quietly replace `y' = ln(`y') `in'
				if `check' {
					quietly replace `y' = 0 if missing(`y') `in'
				}
			}
			if `.ex' {
				quietly replace `y' = `.xvar'*`y' `in'
			}
			sum `y' `if' `in' [`weight'`exp'], mean
			return scalar b = r(mean)
			return scalar N = r(N)
		}
		else {
			matrix `t' = return(db)*e(b)'
			return scalar b = `t'[1,1]
			return scalar N = r(N)
		}
	}
	else if `.is_pred' {
		._pred[`pred'].Predict `if' `in'
		if `.ey' {
			if !`check' {
				capture assert `y' > 0 `if' `in'
				local ln0 = c(rc) != 0
			}
			quietly replace `y' = ln(`y') `in'
			if `check' {
				quietly replace `y' = 0 if missing(`y') `in'
			}
		}
		if `.ex' {
			quietly replace `y' = `.xvar'*`y' `in'
		}
		sum `y' `if' `in' [`weight'`exp'], mean
		return scalar b = r(mean)
		return scalar N = r(N)
		return scalar constant = r(max) == r(min)
	}
	else {
		forval i = 1/`n' {
			._pred[`i'].Predict `if' `in'
		}
		quietly replace `y' = `.gexp' `if' `in'
		if `.ey' {
			capture assert `y' > 0 `if' `in'
			if c(rc) {
				local ln0 = c(rc) != 0
			}
			quietly replace `y' = ln(`y') `if' `in'
			if `check' {
				quietly replace `y' = 0 if missing(`y') `in'
			}
		}
		if `.ex' {
			quietly replace `y' = `.xvar'*`y' `in'
		}
		sum `y' `if' `in' [`weight'`exp'], mean
		return scalar b = r(mean)
		return scalar N = r(N)
		return scalar constant = r(max) == r(min)
	}
	if `ln0' & !`check' {
		return scalar b = .
	}
	if `.first[`pred']' {
		if `.is_pred' == 1 {
			.plabel[1] = "`:variable label `y''"
		}
		else if `.is_pred' {
			.plabel[`pred'] = "`:variable label `y''"
		}
		.first[`pred'] = 0
	}
	if `next' {
		if `gen' {
			.copyvar `y', next
		}
		else {
			.copyvar `y', next rename
		}
	}
	if `gen' {
		capture drop `generate'
		rename `y' `generate'
	}
end

program .estimate, rclass
	tempname b err nobs
	local EBCOLNA : colf e(b)
	if `.hasby' {
		._make_group
	}
	._fill_at
	if ("`atlist'"=="" & `.hasat'==0) {
		tempname b1 V1 diagv1
		_margins_npregress `.ZERO' 
		.bfinf          = r(bfinf)
		matrix `b1'     = r(b1)
		matrix `V1'     = r(V1)
		matrix `diagv1' = `V1'
		local nombrex "`r(lista)'"
		local dydxnpreg "`r(dlist)'"
		local nombrex2 "`r(lista2)'"
		local exactzero = r(exactzero)
		matrix `err'= r(error)
	}
	if (`.hasat'==1) {
		tempname b1 V1 diagv1 ktaman V
		local ktaman "`r(ktaman)'"
		.bfinf          = r(bfinf)
		matrix `b1'     = r(b1)
		matrix `V1'     = r(V1)
		matrix `V'  = `V1'
		matrix `diagv1' = vecdiag(`V1')
		local nombrex "`r(lista)'"
		local dydxnpreg "`r(dlist)'"
		local exactzero = r(exactzero)
		matrix `err'= r(error)
	}
	._setup_contrast
	._setup_pwcompare

	preserve, changed
	if `.se' {
		tempname J V
	}
	local xvars `.xvars'
	local revar : length local xvars
	
	if `revar' {
		tempname ehold
		local notfvlist
		local oldname
		local kk 0
		foreach x of local xvars {
			_ms_parse_parts `x'
			if r(type) == "variable" {
				local ++kk
				local xvars`kk' `x'
				if "`r(ts_op)'" != "" {
					local tsopvars `tsopvars' `x'
					local tsbavars `tsbavars' `r(name)'
				}
				local oldname
			}
			else {
				local name `r(ts_op)'.`r(name)'
				if "`name'" != "`oldname'" {
					local ++kk
					local oldname : copy local name
					if "`r(ts_op)'" != "" {
					    local tsopvars `tsopvars' `x'
					    local tsbavars `tsbavars' `r(name)'
					}
				}
				local xvars`kk' `xvars`kk'' `x'
			}
		}
		local k_xterms = `kk'
	}
	else {
		local k_xterms 1
		local xvars _cons
		local tevi0: word 1 of `.ZERO'
		local tevi1 "in if"
		local tevi: list tevi0 & tevi1
		if ("`.cuales'"!="" & "`tevi'"=="" & `.hasat'==0 ){
			tempname b1 V1
			_margins_npregress `.ZERO'
			matrix `b1' = r(b1)
			matrix `V1' = r(V1)
			local   N  = r(N)
			local casouno "uno"	
		}
	}
	local k_mstat	= `._mstat.arrnels'
	forval j = 1/`k_xterms' {
		if `revar' {
			if `j' > 1 {
				_est unhold `ehold'
			}
			_est hold `ehold', copy  restore
			local XVARS : copy local xvars`j'
			if `:list XVARS in tsbavars' {
				local XVAR : copy local XVARS
				local XVARS `XVAR' `tsopvars'
			}
			else	local XVAR
			.xovars = "`XVARS'"
/*
			_fv_term_info `XVARS' if `.t_sub' `.wt',	///
				individuals tsrestripe `.fvrestripe'	///
				`.FVTImatopt'	
*/			
			_fv_term_info `XVARS' if `.t_sub' `.wt',	///
				individuals tsrestripe `.FVTImatopt'

			local k_terms = r(k_terms)
			local xvars
			local k 0
			.dxolist.Arrdropall
			.dxnlist.Arrdropall
			.dxmlist.Arrdropall
			.dxvlist.Arrdropall
			forval i = 1/`k_terms' {
				local dx `.t_dx'_`i'
				if r(type`i') == "variable" {
					gettoken x XVARS : XVARS
					local ++k
					.dxolist[`k'] = "`x'"
					matrix `dx' = r(mean`i')
					local x : colna `dx'
					local xvars `xvars' `x'
					.dxnlist[`k'] = "`x'"
				}
				else {
					matrix `dx' = r(level`i')
					.dxbase[`i'] = "`r(base`i')'"
					.dxhasbase = 1
					local r = rowsof(`dx')
					local x : colna `dx'
					forval kk = 1/`r' {
						gettoken x XVARS : XVARS
						local ++k
						.dxolist[`k'] = "`x'"
						local x : colna `dx'
						local lev = `dx'[`kk',1]
						local x `lev'.`x'
						local xvars `xvars' `x'
						.dxnlist[`k'] = "`x'"
					}
				}
				local x : colna `dx'
				.dxvlist[`i'] = "`x'"
				.dxmlist[`i'] = "`dx'"
			}
			forval i = 1/`k' {
			    if `"`.dxolist[`i']'"' != `"`.dxnlist[`i']'"' {
				set marginsrevars `.dxolist[`i']'
			    }
			}
			if `.restripe' {
				local xtra `"`.xtra_atvars'"'
				local XVARS `"`.xovars'"'
				local orig : list XVARS - xtra
				if `"`orig'"' != "" {
					_fv_term_info `orig',	///
						individuals	///
						tsrestripe
				}
			}
			.xrevars = "`xvars'"
			if `:length local XVAR' {
				local xvars : copy local XVAR
			}
		}
		foreach x of local xvars {
			forval i = 1/`k_mstat' {
				._mstat[`i'].check_revar
				._mstat[`i'].estimate `x'
				matrix `b' = nullmat(`b'), r(b)
				*matrix `err' = nullmat(`err'), r(error)
				matrix `nobs' = nullmat(`nobs'), r(N)
				if `.se' {
					matrix `J' = nullmat(`J') \ r(db)
				}
			}
		}
	}
	if `"`.xvars'"' != "" {
		if !`.hasby' & `.mlist.arrnels' == 1 {
			local restripe = `"`:colna `.mlist[1]''"' == "_cons"
			if `restripe' {
				local restripe = `.atlist.arrnels' == 1
			}
			if `restripe' {
				local restripe = rowsof(`.atlist[1]') == 1
			}
			if `restripe' {
				local restripe = !`.is_pred'	///
					| `._pred.arrnels' < 2
			}
			if `restripe' {
				local colna : coleq `b'
				matrix coleq `b' = _
				matrix colna `b' = `colna'
			}
		}
	}
	if (("`.over'"!=""|"`.within'"!="") & `.hasat'==0) {
		tempname b V b1 V1
		_margins_npregress `.ZERO'
		matrix `b'     = r(b0)
		matrix `V'     = r(V0)
		matrix `b1'    = r(b0)
		matrix `V1'    = r(V0)
		local nombrex "`r(lista)'"
	}
	local colna : colful `b'

	if ("`nombrex'"!="") {
		local colna "`nombrex'"
	}

	if  ("`dx'"!="" & "`.cuales'"=="" & `.hasat'==0) {
		tempname betanp indexnpr varnpdx J V 
		local kdxnp: list sizeof nombrex
		matrix `betanp'   = 1
		matrix `varnpdx'  = J(`kdxnp', `kdxnp', 0)
		local kv1np       = colsof(`V1')
		matrix `indexnpr' = 1
		local  jnp        = 1 
		forvalues i=1/`kdxnp' {
			if ("`nombrex2'"!="") {
				local laxnp: word `i' of `nombrex2'
			}
			else {
				local laxnp: word `i' of `nombrex'
			}
			_ms_parse_parts `laxnp'
			local nivel  = r(op)
			local labase = r(base)
			if ("`nivel'"!="" & `labase'==1) {
				matrix `betanp'   =  `betanp', 0
			}
			else {
				matrix `indexnpr' = `indexnpr', `i'
				matrix `betanp' = `betanp', `b1'[1, `jnp']
				local jnp = `jnp' + 1
			}
		}
		matrix `indexnpr' =  `indexnpr'[1, 2..colsof(`indexnpr')]
		/*mata: _pedazos_mat("`varnpdx'", "`diagv1'",	///
			"`indexnpr'", "`indexnpr'")*/
		matrix `b' = `betanp'[1, 2..colsof(`betanp')]
		matrix colnames `b' = `nombrex'
		/*matrix `V1'         = `varnpdx'
		matrix colnames `V1' = `nombrex'
		matrix rownames `V1' = `nombrex'*/
	}
	if  ("`dx'"!="" & "`.cuales'"!="") {
		if ("`nombrex'"=="") {
			local nombrex "`colna'"
		}
		*matrix `V'          = `V1'
		matrix colnames `b1' = `nombrex'
		matrix `b' = `b1'
		*matrix colnames `V' = `nombrex'
		*matrix rownames `V' = `nombrex'    
		*matrix `J' = `V' 
		local EBCOLNA "`nombrex'"
	}
	
	if ("`casouno'"!="") {
		matrix `b' = `b1'
		matrix colnames `b' = `colna'	
	}
	if (`.hasat'==1) {
		matrix `b' = `b1'
		matrix colnames `b' = `colna'	
	}
	
	local errk = colsof(`b')
	local errk2 = colsof(`err')
	
	if (`errk2'!=`errk') {
		if (`exactzero'==0) {
			matrix `err' = `b'*0
		}
		matrix coleq `err' = _
		matrix colna `err' = `colna'
	}
	else {
		matrix coleq `err' = _
		matrix colna `err' = `colna'
	}
	if `.se' {
		matrix roweq `J' = _
		matrix rowna `J' = `colna'
		matrix colna `J' = `EBCOLNA'
		tempname vnp 
		if ("`casouno'"!="" | `.hasat'==1| "`dx'"!=""| ///
			"`.over'"!="") {
			matrix `J' = `V1'
		}
		local nprows: colnames `b'
		local k      = rowsof(`J')
		matrix `vnp' = `J'
		forvalues i=1/`k' {
			local vnpa = `J'[`i',`i']
			matrix `vnp'[`i',`i'] = `vnpa'^2
		}
		matrix colnames `vnp' = `nprows'
		matrix rownames `vnp' = `nprows'
		matrix `V'       = `vnp'
		if ("`.cuales'"!="" & "`dx'"!="" |	///
			("`dx'"!="" &`.hasat'==1)) {
			matrix `V' = `V1'
			matrix `b' = `b1'
			matrix colna `b' = `nombrex'
			matrix colna `V' = `nombrex'
			matrix rowna `V' = `nombrex'
		}
	}
	._rename4generate `b'
	return add

	// Saved results
	return local title `"`.title'"'
	return scalar N = `.nobs'
	if `"`.subpop'"' != "" {
		return local subpop `"`.subpop'"'
		return scalar N_sub = `.subnobs'
	}
	else if `.subnobs' < `.nobs' {
		return scalar N_sub = `.subnobs'
	}
	return local model_vce	   "`.model_vce'"
	return local model_vcetype "`.model_vcetype'"
	if `.is_pred' {
	*	.reorder `b' `nobs' `err' `J' `V'
	}
	return matrix _N `nobs'
	if (`exactzero'==0) {
		matrix `err' = `b'*0
	}
	return hidden local exactzero `exactzero'
	return matrix b `b'
	return matrix error `err'
	if `.se' {
		if (`revar'==0 & `.hasat'==0 & ///
			("`.cuales'"==""|"`tevi'"!="")) {
			/*matrix colna `vnpreg' = `colna'
			matrix rowna `vnpreg' = `colna'
			return matrix V		`vnpreg'
			return local vce	"`.vce'"
			return local vcetype	"`.vcetype'"
			if "`.clustvar'" != "" {
				return local clustvar "`.clustvar'"
				return scalar N_clust = `.nclust'
			}
			if `.is_svy' {
				return local prefix svy
				return scalar N_psu = `.npsu'
				return scalar N_strata = `.nstr'
				if `.npost' {
					return scalar N_poststrata = `.npost'
				}
			}
			*/
		}
		else {
			if (("`.over'"!=""|"`.within'"!="")) {
				matrix `J' = I(colsof(`V'))
			}
			return matrix Jacobian	`J'
			return matrix V		`V'
			return local vce	"`.vce'"
			return local vcetype	"`.vcetype'"
			if "`.clustvar'" != "" {
				return local clustvar "`.clustvar'"
				return scalar N_clust = `.nclust'
			}
			if `.is_svy' {
				return local prefix svy
				return scalar N_psu = `.npsu'
				return scalar N_strata = `.nstr'
				if `.npost' {
					return scalar N_poststrata = `.npost'
				}
			}
		}
	}
	if `.df_r' {
		return scalar df_r = `.df_r'
	}
	return local margins `"`.margins'"'
	return scalar k_margins = `.k_m'
	local k_predict = `._pred.arrnels'
	if `.is_pred' {
		if `k_predict' == 1 {
			if `"`.plabel[1]'"' != "" {
				return historical(14) local predict_label ///
					`"`.plabel[1]'"'
				return historical(14) local predict_opts ///
					`"`._pred[1].args'"'
			}
		}
		forval i = 1/`k_predict' {
			return local predict`i'_label	///
				`"`.plabel[`i']'"'
			return local predict`i'_opts	///
				`"`._pred[`i'].args'"'
		}
		return scalar k_predict = `k_predict'
	}
	else	return scalar k_predict = 0
	if `.is_pred' {
		if `._pred.arrnels' == 1 {
			return local expression `"predict(`._pred[1].args')"'
		}
		else {
			return local expression `"predict()"'
		}
	}
	else if `"`.oexp'"' != "" {
		return local expression `"`.oexp'"'
	}
	if "`.xvars'" != "" {
		return local xvars `"`dydxnpreg'"'
		return local derivatives "`.coefttl'"
		if !`.dxhasbase' {
			return local continuous continuous
		}
	}
	return local by "`.by'"
	return local over "`.over'"
	return local within "`.within'"
	return scalar k_by = `.k_by'
	if `.hasby' {
		forval i = 1/`.k_by' {
			return local by`i' `"`.bylist[`i']'"'
		}
	}
	if `.hasat' | `.has_asbal' {
		tempname at atdim
		local k_at = `.atlist.arrnels'
		matrix `atdim' = J(1,`k_at',.)
		local j 0
		forval k = 1/`k_at' {
			matrix `at' = nullmat(`at') \ `.atlist[`k']'
			local slist `"`.atstat[`k']'"'
			local r = rowsof(`.atlist[`k']')/`.k_by'
			matrix `atdim'[1,`k'] = `r'
			forval i = 1/`r' {
				local ++j
				return local atstats`j' `"`slist'"'
			}
			return hidden local atspec`k' `"`slist'"'
			local atopt `"`.atopt[`k']'"'
			return hidden local atopt`k' `"`:list retok atopt'"'
		}
		local r_at = rowsof(`at')
		if `.hasby' {
			local r_at = `r_at' / `.k_by'
		}
		forval k = 1/`r_at' {
			if `.hasby' {
			    if `r_at' > 1 {
				forval j = 1/`.k_by' {
				    local rstripe `rstripe' ///
				    	`k'._at#`.bylist[`j']'
				}
			    }
			    else {
				forval j = 1/`.k_by' {
				    local rstripe `rstripe' `.bylist[`j']'
				}
			    }
			}
			else {
				local rstripe `rstripe' `k'._at
			}
		}
		matrix rownames `at' = `rstripe'
		return matrix at `at'
		return scalar k_at = `k_at'
		return hidden matrix atdims `atdim'
	}
	else	return scalar k_at = 0
	return local emptycells "`.empty'"
	if `.cr_use' | `.cr_a' {
		return matrix chainrule `.t_cr'
	}
	return hidden local predict	_no_predict
	return local est_cmd		`"`.est_cmd'"'
	return local est_cmdline	`"`.cmdline'"'
	return local cmdline	`"margins `.ZERO'"'
	return local cmd	"margins"
end

program .reorder
	args b nobs err J V

	local k_pred = `._pred.arrnels'
	if `k_pred' < 2 {
		exit
	}
	local skip 1
	if `.hasby' | `.hasat' {
		local skip 0
	}
	if `.mlist.arrnels' > 1 {
		local skip 0
	}
	else if `.mlist.arrnels' == 1 {
		if `"`:colna `.mlist[1]''"' != "_cons" {
			local skip 0
		}
	}
	if `skip' {
		exit
	}
	mata: st__marg_reorder(	`k_pred',	///
				"`b'",		///
				"`nobs'",	///
				"`err'",	///
				"`J'",		///
				"`V'")
end

program ._parse_post_required
	syntax [,	COEFLegend		///
			SELEGEND		///
			*			///
	]
	local LEGEND `coeflegend' `selegend'
	if "`LEGEND'" != "" {
		di as err ///
		"option {bf:`LEGEND'} not allowed without {bf:post} option"
		exit 198
	}
end

program ._parse_eq_opt, rclass
	syntax [, EQuation(string asis)]

	if `:length local equation' {
		gettoken eq1 rest : equation, parse(",")
		return local eq1 `"eq(`eq1')"'
		if `:length local reest' {
			gettoken comma eq2 : equation, parse(",")
			return local eq2 `"eq(`eq2')"'
		}
	}
	else {
		return local eq1 "eq(#1)"
	}
end

program ._check_est, rclass
	syntax [if] [in] [fw aw iw pw] [, mult(name) pred(int 0)]

	local next = `.gen'
	local pmax = `._pred.arrnels'
	if `pmax' == 0 {
		return scalar not_estimable = 0
		exit
	}

	if `pred' != 0 {
		local pmin = `pred'
		local pmax = `pred'
	}
	else	local pmin = 1

	tempname L LH t

	local margprop `"`e(marginsprop)'"'
	local prop addcons
	local addcons : list prop in margprop

	_ms_eq_info
	local keq = r(k_eq)
	forval j = 1/`keq' {
		local eqspec`j' "`r(eq`j')'"
		local eqopt`j' "eq(`r(eq`j')')"
		local eqk`j' = r(k`j')
	}
	forval j = 1/`keq' {
		capture _msparse `eqspec`j''
		if !c(rc) & r(omit) == 1 {
			local eqomitlist `"`eqomitlist' eq(#`j') `eqopt`j''"'
		}
	}

	local opts	eclass		///
			fill0		///
			ignoreomit	///
			allownotfound
	forval i = `pmin'/`pmax' {
		._parse_eq_opt, `._pred[`i'].eq'
		local eq1 `"`r(eq1)'"'
		local eq2 `"`r(eq2)'"'
		if `:list eq1 in eqomitlist' & `:list eq2 in eqomitlist' {
			continue
		}
		else if `:list eq1 in eqomitlist' {
			local eq1 : copy local eq2
			local eq2
		}
		else if `:list eq2 in eqomitlist' {
			local eq2
		}
		_ms_means b `if' `in' [`weight'`exp'], `opts' `eq1'
		matrix `L' = r(means)
		if `"`eq2'"' != "" {
			_ms_means b `if' `in' [`weight'`exp'], `opts' `eq2'
			matrix `L' = `L' + r(means)
		}
		if `:length local mult' {
mata:			st_matrix("`L'", st_matrix("`L'"):*st_matrix("`mult'"))
		}
		if `addcons' {
			if `keq' == 1 {
				matrix `L' = `L', 1
			}
			else {
				tempname b hold
				matrix `b' = e(b)
				matrix rename `L' `hold'
				local i0 0
				forval j = 1/`keq' {
				    local i1 = `i0' + `eqk`j''
				    local ++i0
				    matrix `L' = nullmat(`L'), ///
				    		`hold'[1,`i0'..`i1']
				    local hc = colnumb(`b', "`eqspec`j'':_cons")

	if missing(`hc') {
		if inlist("eq(#`j')", "`eq1'", "`eq2'") {
			matrix `L' = `L', 1
		}
		else if inlist("`eqspec`j''", "`eq1'", "`eq2'") {
			matrix `L' = `L', 1
		}
		else {
			matrix `L' = `L', 0
		}
	}

				    local i0 = `i1'
				}
			}
		}
		matrix `LH' = `L'*`.t_H'
		if mreldif(`L', `LH')  > `.est_tol' {
			capture drop `t'
			quietly gen `t' = 0
			.copyvar `t', next rename
			return scalar b = 0
			matrix `L' = 0*e(b)
			return matrix db `L'
			return scalar not_estimable = 1
			return scalar N = e(N)
			exit
		}
	}
	return scalar not_estimable = 0
end

program .est1
	syntax [if] [in] [, mult(passthru) pred(int 1)]

	if `.est_chk' {
		._check_est `if' `in' `.wt', `mult' pred(`pred')
		if r(not_estimable) {
			exit
		}
	}

	if "`.nose'" != "" {
		.compute `if' `in' `.wt', pred(`pred')
	}
	else if `.is_xb[`pred']' & !`.numeric' {
		.compute `if' `in' `.wt', next pred(`pred')
	}
	else {
		local deriv 0
		if `.is_pred' & `.numeric' == 0 {
			local deriv = `._pred[`pred'].deriv'
		}
		if `deriv' {
			.cr_a = 1
			._est1_db_cr_a `if' `in' `.wt', pred(`pred')
		}
		else if `.cr_use' {
			._est1_db_cr_n `if' `in' `.wt', pred(`pred')
		}
		else {
			._est1_db `if' `in' `.wt', pred(`pred')
		}
	}
end

program .est2
	syntax [if] [in], xvar(string) [mult(passthru) pred(passthru)]

	fvrevar `xvar', list
	set marginsdxvars `r(varlist)'
	_ms_parse_parts `xvar'
	if r(type) == "variable" {
		._est2_c `if' `in', xvar(`xvar') `mult' `pred'
	}
	else {
		._est2_d `if' `in', xvar(`xvar') `mult' `pred'
	}
end

program .get_dx_base, rclass
	syntax varname

	local i = `.dxvlist.arrindexof "`varlist'"'
	if `i' == 0 {
		di as err "`varlist' not found in list of indepvars"
		error 198
	}
	return scalar base = `.dxmlist[`i']'[`.dxbase[`i']',1]
end

program .estimate_and_report, rclass
	tempname b ehold bpw btemp
	local newcmd = "`e(cmd)'"
	.estimate
	matrix `b' = r(b)
	if "`r(V)'" == "matrix" {
		tempname V
		matrix `V' = r(V)
	}
	if !`.post' {
		_est hold `ehold'
	}

break {
capture noisily break {
	._post `b' `V'
	if `"`.saving'"' != "" {
		if !`.post' {
			local mypost post
		}
	}
	if `.has_contrast' {
		contrast `.contrast',	`.diopts'		///
					`.commonopts'		///
					`.contrastopts'		///
					`.mcompareopt'		///
					`.atlegend' 		///
					`mypost' npreturn
		return add
	}
	else if `.has_pwcompare' {
		pwcompare `.pwcompare',	`.diopts'		///
					`.commonopts'		///
					`.pwcompareopts'	///
					`.mcompareopt'		///
					`.atlegend' `mypost' 
	}
	else {
		return add
		if `.dxhasbase' {
			return local b
			matrix `b' = e(b)
			return matrix b `b'
			if "`r(V)"'" == "matrix" {
				return local V
				matrix `V' = e(V)
				return matrix V `V'
			}
		}
		_marg_report,	`.diopts'		///
				`.commonopts'		///
				`.mcompareopt'		///
				`.atlegend'				
		return add
	}
	return hidden local u_at_vars `"`.uatvars'"'
	._post_dims
	return hidden local marg_dims `"`e(marg_dims)'"'
	if `"`.saving'"' != "" {
		_marg_save,	saving(`"`.saving'"',	///
					`.sav_double'	///
					`.sav_replace')	///
				level(`.level')		///
				eclass
	}

	if `.plot' {
		marginsplot, `.plotopts'
	}

} // capture noisily break
	local rc = c(rc)

	if !`.post' {
		_est unhold `ehold'
	}

} // break
	exit `rc'
end

program ._repost, eclass
	if `"`.t_altb'"' == "" {
		exit
	}
	if `.at_b_dim' == 0 {
		exit
	}
	tempname b
	matrix `b' = `.t_altb'[1,1..`.at_b_dim']
	ereturn repost b=`b', rename
end

program ._post, eclass
	args b V
	local hasv : length local V
	if `hasv' {
		local postv "V=`V'"
	}
	
nobreak {

	local hold = c(emptycells)
	set emptycells keep

capture noisily break {
	if (`.bfinf'==1) {
		local binfv "buildfvinfo"
	}
	else {
		local binfv ""
	}
	ereturn post `b' `V' `.wt',		///
			esample(`.t_sub')	///
			findomitted		///
			noHmat	`binfv'
			
	if `"`.subpop'"' != "" {
		ereturn repost, esample(`.t_touse') 
	}

} // capture noisily break
	local rc = c(rc)

	set emptycells `hold'

} // nobreak
	if `rc' exit `rc'

	if `"`.footnote'"' != "" {
		ereturn hidden local footnote `"`.footnote'"'
	} 
	_r2e, noclear xmacros(cmd)
	ereturn hidden local u_at_vars `"`.uatvars'"'
	ereturn local cmd	"margins"
	ereturn local npcmd   "npregress"
	ereturn local contrastoptsnp "`.contrastoptsnp'"
end

program .ExtraDflt1, sclass
	syntax [, xb(passthru) EQuation(passthru) OUTcome(string asis) *]

	local extra _predict
	if `"`xb'"' != "" {
		local extra `extra' _xb
	}
	if `"`equation'"' != "" {
		local extra `extra' _equation
	}
	if `"`outcome'"' != "" {
		local extra `extra' _outcome
		gettoken dvar dval : outcome
		capture confirm name `dvar'
		if c(rc) == 0 {
			capture confirm integer number `dval'
			if c(rc) == 0 {
				local extra `extra' _equation
			}
		}
	}
	sreturn local extra `"`extra'"'
end

program .ExtraDflt, sclass
	args c_extra

	local 0 `", `.margdflt'"'
	syntax [, predict(string asis) *]
	.ExtraDflt1, `predict'
	local extra `"`s(extra)'"'
	local 0 `", `options'"'
	syntax [, predict(string asis) *]
	while `"`predict'"' != "" {
		.ExtraDflt1, `predict'
		if `"`extra'"' != `"`s(extra)'"' {
			exit
		}
		local 0 `", `options'"'
		syntax [, predict(string asis) *]
	}
	local extra : subinstr local extra "_xb" "_equation"
	local extra : list uniq extra
	c_local `c_extra' `"`extra'"'
end

program ._post_dims, eclass

	if `"`e(xvars)'"' != "" {
		local extra _deriv
	}

	// mlist -- build the list of margin variables
	if `"`e(margins)'"' != "" {
		_fv_term_info `e(margins)', noc
		local k = r(k_terms)
	}
	else	local k 0
	if `k' > 1 {
		local extra `extra' _term
	}
	forval i = 1/`k' {
		local colna : colna r(level`i')
		local mlist : list mlist | colna
	}
	local mlist : list uniq mlist
	local _CONS _cons
	local mlist : list mlist - _CONS

	// atlist -- build the list of at() variables
	tempname at_skip
	mata: st__marg_dims_check_at()
	if `has_at' {
		local atcolna : colna e(at)
		local extra `extra' _atopt
	}
	local i 0
	foreach at of local atcolna {
		local ++i
		if `at_skip'[1,`i'] {
			continue
		}
		_ms_parse_parts `at'
		local hasrcp = "`r(ts_op)'" != ""
		if `hasrcp' {
			local name at(`r(ts_op)'.`r(name)')
		}
		else {
			local name at(`r(name)')
		}
		if !`:list name in atlist' {
			local atlist `atlist' `name'
		}
	}

	// bylist -- build the list of by variables
	if `"`e(by)'"' != "" {
		local bylist `"`e(by)'"'
	}
	if `._pred.arrnels' > 1 {
		if `"`.margdflt'"' != "" {
			ExtraDflt extra_dflt 
		}
		else {
			local extra_dflt _predict
		}
	}

	if `.has_pwcompare' {
		local dims _pw0 _pw1 _pw `extra' `extra_dflt'
	}
	else {
		local dims `mlist' `atlist' `bylist' `extra' `extra_dflt'
	}
	local dims : list retok dims
	ereturn hidden local marg_dims `"`dims'"'
end

// subroutines for .parse ---------------------------------------------------

program ._parse_predict, rclass
	syntax [, PRedict(string asis) *]

	.is_pred = 2
	local i 0
	while `"`predict'"' != "" | `i' == 0 {
		forval j = 1/`i' {
			._pred[`j'].match, `predict'
			if r(match) == 1 {
				di as err "redundant {bf:predict()} option;"
				di as err ///
"more than one {bf:predict} option produces the same prediction"
				exit 198
			}
		}
		local ++i
		version `.vv' : ._pred[`i'] = ._marg_predict_npreg.new
		._pred[`i'].parse, `predict'
		.first[`i'] = 1

		local 0 `", `options'"'
		syntax [, PRedict(string asis) *]
	}
	return local options `"`options'"'
end

program ._parse_atvarsopt
	syntax [varlist(numeric default=none)]
	local covar `"`e(covariates)'"'
	local varlist : list uniq varlist
	local dim : list sizeof varlist
	if `dim' == 0 {
		if "`covar'" == "_NONE" {
			di as err "model contains no indepvars"
			exit 322
		}
		exit
	}

	_ms_eq_info, `.matopt'
	local k_eq = r(k_eq)

	foreach var of local varlist {
		local spec
		forval i = 1/`k_eq' {
			capture	_ms_extract_varlist `var', `.matopt' eq(#`i')
			if c(rc) == 0 {
				local spec `"`spec' `r(varlist)'"'
			}
			capture	_ms_extract_varlist i.`var', `.matopt' eq(#`i')
			if c(rc) == 0 {
				local spec `"`spec' `r(varlist)'"'
			}
		}
		if `"`spec'"' == "" {
			local spec : copy local var
		}
		else {
			local spec : list uniq spec
		}
		local speclist `speclist' `spec'
	}
	local speclist : list uniq speclist
	local dim : list sizeof speclist

	tempname b
	matrix `b' = J(1,`dim',0)
	matrix coleq `b' = _atvarsopt
	matrix colna `b' = `speclist'
	if "`covar'" == "_NONE" {
		capture matrix drop `.t_altb'
	}
	if `"`.t_altb'"' == "" {
		.t_altb	= "`tname'_altb"
		matrix `.t_altb' = e(b)
		.at_b_dim = `= colsof(`.t_altb')'
	}
	else {
		.restripe = 1
	}
	matrix `.t_altb' = nullmat(`.t_altb'), `b'
	.atvarsopt	= `"`varlist'"'
	.xtra_atvars	= `"`speclist'"'
	.matopt		= `"matrix(`.t_altb')"'
	.FVTImatopt	= `"matrix(`.t_altb')"'
end

program ._parse_at
	syntax [, asbalanced at(string) Reps(string) seed(string) *]

	if `:length local asbalanced' {
		local fprefix (asbalanced) _factor
		local cprefix (mean)
	}
	else if `.atmean' {
		local fprefix (mean) _factor
	}
	if `.atmean' {
		local cprefix (mean) _continuous
	}

	if `.force' {
		local force force
	}

	local matopt `"`.matopt'"'
	_ms_at_parse `fprefix' `cprefix' `at', asobserved `matopt' `force'	

	if "`r(at)'" == "" {
		if "`at'" != "" {
			di as err "model contains no indepvars"
			exit 322
		}
		local k 1
		local mat `.t_at'`k'
		matrix `mat' = J(1,1,1)
		matrix colna `mat' = _cons
		local atstat "asobserved"
	}
	else {
		local uatvars `"`r(atvars)'"'
		local uatvars : list uniq uatvars
		local k 1
		local mat `.t_at'`k'
		matrix `mat' = r(at)
		local atstat `"`r(statlist)'"'
	}
	.atlist[`k'] = "`mat'"
	.atstat[`k'] = `"`atstat'"'
	.atopt[`k'] = `"`fprefix' `cprefix' `at'"'
	._asbal[`k'] = strmatch("`r(statlist)'", "asbalanced")

	local 0 `", `options'"'
	syntax [, at(string) *]
	while `:length local at' {
		_ms_at_parse `fprefix' `cprefix' `at', ///
			asobserved `matopt' `force'
		local uatvars `"`uatvars' `r(atvars)'"'
		local uatvars : list uniq uatvars
		local ++k
		local mat `.t_at'`k'
		matrix `mat' = r(at)
		.atlist[`k'] = "`mat'"
		.atstat[`k'] = `"`r(statlist)'"'
		.atopt[`k'] = `"`fprefix' `cprefix' `at'"'
		._asbal[`k'] = strmatch("`r(statlist)'", "asbalanced")
		local 0 `", `options'"'
		syntax [, at(string) *]
	}
	if "`.t_altb'" != "" {
		local K = `._asbal.arrnels'
		forval k = 1/`K' {
			if `._asbal[`k']' {
				di as err ///
`"option {bf:asbalanced} not allowed with {bf:`.ecmd'} estimation results"'
				exit 322
			}
		}
	}
	.uatvars = `"`uatvars'"'

	syntax [, NULLOP]
end

program	._parse_by
	syntax [,	by(string)	///
			over(string)	///
			within(string)	///
	]

	local spec `by' `over' `within'

	local over `by' `over'
	.ocontrast = `"`over'"'
	_strip_contrast `over', notsops nointeractions opt(over)
	if r(contrast) {
		.has_contrast = 1
		.has_ocontrast = 1
	}
	local varlist `"`r(varlist)'"'
	local over
	foreach var of local varlist {
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1, .)
		}
		local over `over' `var'
	}

	.wcontrast = `"`within'"'
	_strip_contrast `within', notsops nointeractions opt(within)
	if r(contrast) {
		.has_contrast = 1
		.has_wcontrast = 1
	}
	local varlist `"`r(varlist)'"'
	local within
	foreach var of local varlist {
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1,.)
		}
		local within `within' `var'
	}

	// parse the combined specification, just in case there is a conflict
	_strip_contrast `.ocontrast' `.wcontrast'

	local by `over' `within'
	local by : list uniq by
	local within : list uniq within
	local over : list by - within
	.over	= "`over'"
	.within	= "`within'"
	.by	= "`by'"
	if `:length local within' {
		_ms_check_varlist i.(`within')
		if "`.empty'" == "" {
			.empty = "reweight"
		}
	}
	.hasby	= "`by'" != ""
end

program ._parse_emptycells
	capture syntax [, REWeight strict]
	if c(rc) {
		di as err "option {bf:emptycells()} invalid"
		exit 198
	}
	local empty `reweight' `strict'
	opts_exclusive "`empty'"
	.empty = "`empty'"
end

program ._parse_vce
	_vce_parse, opt(delta svy UNCONDitional): `0'
	local vce "`r(vce)'"
	if "`vce'" == "svy" {
		if `"`e(prefix)'"' != "svy" {
			di as err ///
"option {bf:vce(svy)} is allowed only with survey estimation results"
			exit 322
		}
		local vce unconditional
	}

	local vce none
	.model_vce = "`e(vce)'"
	.model_vcetype = "`e(vcetype)'"
	if `"`.model_vcetype'"' == "HAC" {
		.model_vcetype = "`e(vcetype)' `e(hac_kernel)' `e(hac_lag)'"
	}
	.is_svy = "`e(prefix)'" == "svy"
	if "`vce'" == "unconditional" {
		if `.is_svy' {
			.model_vce = "svy"
		}
		if "`.model_vce'" == "svy" {
			if `"`.wtype'"' != "" {
				di as err ///
"weights not allowed with survey estimation results"
				exit 101
			}
			quietly svyset
			if `"`r(settings)'"' == ", clear" {
				di as err ///
"data not set up for {bf:svy}, use {helpb svyset##|_new:svyset}"
				exit 459
			}
			if "`r(vce)'" != "linearized" {
				di as err "{bf:vce(`r(vce)')} is not supported"
				error 459
			}
			if "`e(vce)'" != "linearized" {
				di as err "{p}" ///
"option {bf:vce(unconditional)} is allowed only after estimation with "	///
"linearized standard errors{p_end}"
				exit 322
			}
			.posts	= "`r(poststrata)'"
			.postw	= "`r(postweight)'"
			.wtype	= "`r(wtype)'"
			.wexp	= "`r(wexp)'"
		}
		else if "`.model_vce'" == "cluster" {
			.clustvar = "`e(clustvar)'"
			.clopt = "cluster(`e(clustvar)')"
		}
		else if "`.model_vce'" == "robust" {
			if "`e(clustvar)'" != "" {
				.clustvar = "`e(clustvar)'"
			}
			else if "`e(group)'" != "" {
				.clustvar = "`e(group)'"
			}
			if "`.clustvar'" != "" {
				.clopt = "cluster(`.clustvar')"
			}
		}
		else {
			di as err "{p}" ///
"option {bf:vce(unconditional)} is allowed only after estimation with "	///
"robust, semirobust, or linearized standard errors{p_end}"
			exit 322
		}
	}
	else {
		local vce delta
	}
	.vce = "`vce'"
	if "`.model_vce'" == "svy" {
		.vcetype = "Linearized"
		.lin = 1
	}
	else if inlist("`vce'", "unconditional") {
		.vcetype = "Unconditional"
		.lin = 1
	}
	else {
		.vcetype = "Delta-method"
	}
	if `.lin' {
		._check_vce_not_supported "`e(cmd)'" "`e(cmd2)'"
		.gen = 1
		.use_in1 = 0
	}
end

program ._check_esample
	quietly count if e(sample)
	if r(N) == 0 {
		di as err ///
		"{bf:e(sample)} does not identify the estimation sample"
		exit 322
	}
	.nobs = r(N)
	if "`.vce'" == "unconditional" {
		if inlist("`.wtype'", "", "aweight", "pweight") {
			if (`.nobs' != e(N)) {
				display as error ///
				"data have changed since estimation"
				di as err "{p 4 4 2}" 
				di as smcl as err "{bf:margins} after"
				di as smcl as err " {bf:npregress} will not"
				di as smcl as err " work if your covariates or" 
				di as smcl as err " your dependent variable" 
				di as smcl as err " have changed since"
				di as smcl as err " estimation." 
				di as smcl as err "{p_end}"
				exit 198									
			}
		}
	}
end

program ._check_fweight
	if "`.vce'" == "unconditional" {
		sum `.t_touse' [fweight`.wexp'] if e(sample), mean
		if r(sum_w) != e(N) {
			local msg0 ///
"unconditional standard errors derived assuming full estimation sample;"
			local msg1 ///
"{bf:fweight}s do not sum to the number of observations posted in {bf:e(N)}"
			if `.force' {
				di as txt `"{p 0 7}(note: "' _c
				di as txt `"`msg0'{break}"' _c
				di as txt `"`msg1'){p_end}"'
			}
			else {
				di as err `"{p}`msg0'{break}"' _c
				di as err `"`msg1'{p_end}"'
				exit 459
			}
		}
	}
end

program ._check_touse
	if `.esample' & "`.vce'" == "unconditional" {
		local msg0 ///
"unconditional standard errors derived assuming full estimation sample;"
		local msg1 ///
`"`0' dropped observations from the estimation sample"'
		quietly count if `.t_touse'
		if `.nobs' != r(N) {
			if `.force' {
				.nobs = r(N)
				di as txt `"{p 0 7}(note: "' _c
				di as txt `"`msg0'{break}`msg1'){p_end}"'
				exit
			}
			di as err `"{p}`msg0'{break}"' `"`msg1'{p_end}"'
			exit 459
		}
	}
end

program ._check_svy_char
	assert `"`r(`0')'"' == `"`e(`0')'"'
end

program ._check_svyset
	quietly svyset
	capture {
		._check_svy_char stages
		._check_svy_char wtype
		._check_svy_char wexp
		._check_svy_char poststrata
		._check_svy_char postweight
		._check_svy_char singleunit
		local k = e(stages)
		forval i = 1/`k' {
			._check_svy_char su`i'
			._check_svy_char fpc`i'
			._check_svy_char strata`i'
		}
	}
	if c(rc) {
		local msg ///
"{bf:svyset} characteristics disagree with the {bf:svy} estimation results"
		if `.force' {
			di as txt "{p 0 7}(note: `msg'){p_end}"
			exit
		}
		di as err "`msg'"
		exit 322
	}
end

program ._parse_expression
	version 11
	local exp : copy local 0
	local i 0
	local oexp : list retokenize exp
	if !`:length local exp' {
		local exp "predict()"
	}
	while `:length local exp' {
		gettoken check exp : exp, /*
			*/ parse(`" "`'~:;,<>\/?!@|#$%^&*()-+=[]{}"') quotes
		if `"`check'"' != "predict" & `"`check'"' != "xb" {
			local gexp `"`gexp'`check'"'
			continue
		}
		gettoken paren : exp, parse(" (")
		if `"`paren'"' != "(" {             /* False alarm */
			local gexp `"`gexp'`check'"'
			continue
		}
		local match 0
		gettoken args exp : exp, match(par)
		forval j = 1/`i' {
			._pred[`j'].match, `args'
			if r(match) == 1 {
				local gexp `"`gexp'`._pred[`j'].varname'"'
				local match 1
				continue, break
			}
		}
		if `match' {
			continue
		}
		local ++i
		version `.vv' : ._pred[`i'] = ._marg_predict_npreg.new
		if `"`check'"' == "xb" {
			local args : subinstr local args " " "", all
			local term `"xb(`args')"'
			if `:length local args' {
				local eqopt eq(`args')
			}
			else	local eqopt
			._pred[`i'].parse, xb `eqopt'
		}
		else {                     /* check == "predict" */
			local term `"predict(`args')"'
			._pred[`i'].parse, `args'
		}
		local gexp `"`gexp'`._pred[`i'].varname'"'
	}
	if `._pred.arrnels' == 0 {
		di as txt ///
"{p 0 0 2}Warning: expression() does not contain predict() or xb().{p_end}"
	}
	.oexp = `"`oexp'"'
	.gexp = `"`gexp'"'

	if `._pred.arrnels' == 1 & `"`.gexp'"' == "`._pred[1].varname'" {
		.is_pred = 1
	}
	.numeric = 1
end

program ._check_predict
	version 11

	if `._pred.arrnels' == 1	///
	 & inlist(`"`.gexp'"', "", "`._pred[1].varname'") {
		.is_pred = 1
	}
	if !`.is_pred' {
		exit
	}
	local marg_ok 1
	forval ip = 1/`._pred.arrnels' {
		if `"`._pred[`ip'].opts'"' == "xb" {
			.is_xb[`ip'] = !`._pred[`ip'].notxb'
		}
		else {
			.is_xb[`ip'] = 0
		}
		if !`.force' {
			_check_e_margins margins, `._pred[`ip'].opts'
			if r(marginsok) == 0 {
				local marg_ok 0
			}
		}
		local hasoffset 0
		if `"`._pred[`ip'].offset'"' != "nooffset" {
			local coleq : coleq e(b), quote
			local coleq : list clean coleq
			local coleq : list uniq coleq
			local neq : list sizeof coleq
			local hasoffset = strlen("`e(offset)'")
			local done = `hasoffset'
			local i 1
			while !`done' {
				local hasoffset = strlen("`e(offset`i')'")
				local ++i
				local done = `i' > `neq' | `hasoffset'
			}
		}
		.offset[`ip'] = `hasoffset'
		if `.offset[`ip']' {
			.use_in1 = 0
		}
		if `.is_xb[`ip']' {
			local 0 `", `._pred[`ip'].eq'"'
			syntax [, EQuation(string)]
			if bsubstr("`equation'",1,1) == "#" {
				local eqno = bsubstr("`equation'",2,.)
				confirm integer number `eqno'
				.eqno[`ip'] = `eqno'
			}
			else if `:length local equation' {
				local coleq : coleq e(b), quote
				local coleq : list uniq coleq
				local eqno : list posof `"`equation'"' in coleq
				if `eqno' == 0 {
					di as err ///
					"equation `equation' not found"
					exit 303
				}
				.eqno[`ip'] = `eqno'
			}
			else {
				.eqno[`ip'] = 1
			}
		}
	}
	if !`.force' {
		.e_marginsok = `marg_ok'
	}
end

program ._parse_dydx
	syntax [,	dydx(string)		///
			eyex(string)		///
			dyex(string)		///
			eydx(string)		///
			continuous		///
	]

	.ey = "`eyex'" != "" | "`eydx'" != ""
	if `.ey' {
		local ey ey
	}
	.ex = "`eyex'" != "" | "`dyex'" != ""
	if `.ex' {
		local ex ex
	}
	if `:length local continuous' {
		.fvrestripe = "fvrestripe"
	}
	local matopt `"`.matopt'"'
	local xvars `dydx' `eyex' `dyex' `eydx'
	dydx_unab `xvars', `matopt'
	local xvars "`r(varlist)'"
	_ms_dydx_parse `xvars', `ey' `ex' `matopt'
	local xvars "`r(varlist)'"
	if `:list sizeof xvars' {
		if !`.cr_all' {
			.cr_use = 0
		}
	}
	.xvars = "`xvars'"
	.coefttl = cond(`.ey', "ey/", "dy/") + cond(`.ex', "ex", "dx")
	.dydxopt = cond(`.ey', "ey", "dy") + cond(`.ex', "ex", "dx")
	local old
	local k 0
	local note 0
	foreach x of local xvars {
		_ms_parse_parts `x'
		if r(type) == "factor" {
			if `.ex' {
				if `.ey' {
					local opt eyex
				}
				else	local opt dyex
				di as err ///
"factor variables not allowed in option {bf:`opt'()}"
				exit 198
			}
			local name `r(ts_op)'.`r(name)'
			if `"`name'"' != `"`old'"' {
				if `k' == 1 {
					.fvrestripe = "fvrestripe"
					local ++note
				}
				local old : copy local name
				local k 1
			}
			else {
				local ++k
			}
		}
	}
	if `k' == 1 {
		.fvrestripe = "fvrestripe"
		local ++note
	}
	if `note' & !`:length local continuous' {
		di as txt "{p 0 7}(note: " ///
"continuous option implied because a factor with only one level" ///
" was specified in the `.dydxopt'() option){p_end}"
	}
end

program .dydx_unab, rclass
	syntax [anything] [, matrix(passthru)]
	if "`matrix'" == "" {
		local matrix matrix(e(b))
		local COLNA : colna e(b)
	}
	else {
		local COLNA : colna `.t_altb'
	}
	foreach spec of local COLNA {
		_ms_parse_parts `spec'
		if inlist(r(type), "variable", "factor") {
			if r(name) == "_cons" {
				continue
			}
			if "`r(ts_op)'" != "" {
				local name `"`r(ts_op)'.`r(name)'"'
			}
			else	local name `"`r(name)'"'
			if `:list name in _ALL' == 0 {
				local _ALL `_ALL' `name'
			}
		}
		else if r(type) == "interaction" {
		    local k = r(k_names)
		    forval i = 1/`k' {
			if "`r(ts_op`i')'" != "" {
				local name `"`r(ts_op`i')'.`r(name`i')'"'
			}
			else	local name `"`r(name`i')'"'
			if `:list name in _ALL' == 0 {
				local _ALL `_ALL' `name'
			}
		    }
		}
	}
	if `.esample' {
		local if "if e(sample)"
	}
	local ZERO : copy local anything
	while `:length local ZERO' {
		gettoken 0 ZERO : ZERO, bind
		local len : length local 0
		if inlist(`"`0'"', "*", "_all") {
			local 0 : copy local _ALL
		}
		if bsubstr("_continuous",1,max(2,`len')) == `"`0'"' {
			local xvars `xvars' `0'
		}
		else if bsubstr("_factor",1,max(2,`len')) == `"`0'"' {
			local xvars `xvars' `0'
		}
		else {
			capture _unab `0', `matrix'
			if c(rc) == 0 {
				local 0 `"`r(varlist)'"'
			}
			local xvars `xvars' `0'
		}
	}
	return local varlist `"`xvars'"'
end

program .get_dx_oname
	args c_dx COLON dx
	local i = `.dxnlist.arrindexof "`dx'"'
	if `i' == 0 {
		di as err "{bf:`dx'} not found in list of indepvars"
		error 198
	}
	c_local `c_dx' `.dxolist[`i']'
end

program ._parse_margins
	syntax [anything]
	.umargins = `"`anything'"'
	_strip_contrast `anything'
	if r(contrast) {
		.has_contrast = 1
	}
	local varlist `"`r(varlist)'"'
	_fv_term_info `varlist' if `.t_touse' `.wt', noc
	local k = r(k_terms)
	local margins
	forval i = 1/`k' {
		._base[`i'] = r(base`i')
		.mlist[`i'] = "`.t_marg'`i'"
		matrix `.mlist[`i']' = r(level`i')
	}
	.k_m = `k'
	local 0 `"`r(varlist)'"'
	syntax varlist(fv ts)
	.margins = `"`varlist'"'
end

program ._get_common_subopts, sclass
	if `.has_contrast' {
		local noeffects NOEFFects
	}
	syntax [,			///
		CIeffects		///
		PVeffects		///
		`noeffects'		///
		EFFects			///
		SORT			///
		ATEQuations		///
		EQuation(passthru)	///
		post			///
		*			///
	]

	if "`noeffects'" != "" {
		opts_exclusive "`noeffects' `effects'"
		opts_exclusive "`noeffects' `cieffects'"
		opts_exclusive "`noeffects' `pveffects'"
	}
	local effects `cieffects' `pveffects' `effects' `noeffects'

	local equation `equation' `atequations'
	opts_exclusive `"`equation'"'
	if `"`equation'"' == "" {
		local equation atequations
	}

	if `:length local post' {
		.post = 1
	}
	else if `.post' {
		local post post
	}

	local opts `.commonopts' `effects' `sort' `post' `equation'
	local opts : list uniq opts
	.commonopts = `"`opts'"'
	sreturn clear
	sreturn local options `"`options'"'
end

program ._drop_common_subopts, sclass
	local 0 `", `.commonopts'"'
	syntax [, SORT *]
	.commonopts = `"`sort'"'
end

program ._parse_contrast_opts
	capture ._get_common_subopts `0'
	if c(rc) {
		local rc = c(rc)
		di as err "invalid {bf:contrast()} option;"
		._get_common_subopts `0'
		error `rc'	// [sic]
	}
	local 0 `", `s(options)'"'
	local OPTS	nowald			/// display options
			NOATlevels		///
			lincom			/// other options
			overall			///
			ATjoint			/// margins options
			ATcontrast(string)	///
			PREDictjoint		///
			PREDictcontrast(string)	///
			OVERjoint		///
			WITHINjoint		///
			noSVYadjust		///
			MARGINSWithin		///
						 // blank
	capture syntax [, `OPTS']
	if c(rc) {
		local rc = c(rc)
		di as err "invalid {bf:contrast()} option;"
		syntax [, `OPTS']
		error `rc'	// [sic]
	}
	local COPTS `wald' `noatlevels' `lincom' `overall' `svyadjust'
	if `:length local COPTS' {
		.has_contrast = 1
	}
	.contrastopts = "`COPTS'"

	if `:length local predictcontrast' {
		local predictjoint predictjoint
		local ucon = bsubstr(`"`predictcontrast'"',1,1) == "{"
		local dot = strpos(`"`predictcontrast'"', ".")
		if !(`ucon' | `dot') {
			local predictcontrast `predictcontrast'._predict
		}
		capture _pred_strip_contrast `predictcontrast', ///
			notsops noint opt(predictcontrast)
		if c(rc) {
			local rc = c(rc)
			di as err "invalid {bf:predictcontrast()} suboption;"
			_pred_strip_contrast `predictcontrast', ///
				notsops noint opt(predictcontrast)
			exit `rc'
		}
		local var `"`r(varlist)'"'
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1, .)
		}
		if `"`var'"' != "_predict" {
			di as err "invalid {bf:predictcontrast()} suboption;"
			di as err ///
`"{p 0 0 2}`predictcontrast' found where {bf:_predict} with optional "'	///
"contrast operators expected{p_end}"
			exit 198
		}
		.pcontrast = `"`predictcontrast'"'
	}

	if `:length local atcontrast' {
		local atjoint atjoint
		local ucon = bsubstr(`"`atcontrast'"',1,1) == "{"
		local dot = strpos(`"`atcontrast'"', ".")
		if !(`ucon' | `dot') {
			local atcontrast `atcontrast'._at
		}
		capture _at_strip_contrast `atcontrast', ///
			notsops noint opt(atcontrast)
		if c(rc) {
			local rc = c(rc)
			di as err "invalid {bf:atcontrast()} suboption;"
			_at_strip_contrast `atcontrast', ///
				notsops noint opt(atcontrast)
			exit `rc'
		}
		local var `"`r(varlist)'"'
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1, .)
		}
		if `"`var'"' != "_at" {
			di as err "invalid {bf:atcontrast()} suboption;"
			di as err ///
`"{p 0 0 2}`atcontrast' found where {bf:_at} with optional contrast "'	///
"operators expected{p_end}"
			exit 198
		}
		.atcontrast = `"`atcontrast'"'
	}

	if `:length local predictjoint' {
		.has_contrast = 1
		.has_pcontrast = 1
	}
	if `:length local atjoint' {
		.has_contrast = 1
		.has_atcontrast = 1
	}
	if `:length local overjoint' {
		.has_contrast = 1
		.has_ocontrast = 1
	}
	if `:length local withinjoint' {
		.has_contrast = 1
		.has_wcontrast = 1
	}
	if `:length local marginswithin' {
		.has_atmargins = 1
	}
end

program ._put_sharp, sclass
	while `:length local 0' {
		gettoken spec 0 : 0, parse(" {}")
		if "`spec'" == "{" {
			local result `result'`sharp'`spec'
			while "`spec'" != "}" {
				gettoken spec 0 : 0, parse(" {}")
				if "`spec'" == "" {
					error 198
				}
				local result `result' `spec'
			}
		}
		else {
			local result `result'`sharp'`spec'
		}
		local sharp "#"
	}
	sreturn local result `"`result'"'
end

program ._setup_contrast
	if `.has_contrast' == 0 {
		exit
	}

	if `.is_pred' == 2 {
		local k_pred = `._pred.arrnels'
		local pcontrast `"`.pcontrast'"'
		if `:length local pcontrast' == 0 {
			local pcontrast _predict
		}
		if `.has_pcontrast' {
			._put_sharp `pcontrast'
			local prefix `"`s(result)'"'
			local sharp0 "#"
		}
		else {
			local postfix "_predict"
			local sharp1 "#"
		}
	}
	else	local k_pred 0

	local k_at = `.atlist.arrnels'
	if `.atrows' > 1 {
		local atcontrast `"`.atcontrast'"'
		if `:length local atcontrast' == 0 {
			local atcontrast _at
		}
		if `.has_atcontrast' {
			._put_sharp `atcontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			local postfix "`postfix'`sharp1'_at"
			local sharp1 "#"
		}
	}

	local at_char
	local ocontrast `"`.ocontrast'"'
	if `:length local ocontrast' {
		if `.has_ocontrast' {
			._put_sharp `ocontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			._put_sharp `ocontrast'
			local postfix `"`postfix'`sharp1'`s(result)'"'
			local sharp1 "#"
			local at_char "@"
		}
	}

	local wcontrast `"`.wcontrast'"'
	if `:length local wcontrast' {
		if `.has_wcontrast' {
			._put_sharp `wcontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			._put_sharp `wcontrast'
			local postfix `"`postfix'`sharp1'`s(result)'"'
			local sharp1 "#"
			if "`at_char'" == "" {
				local at_char "|"
			}
		}
	}

	local umargins `"`.umargins'"'
	if `k_pred' | `k_at' {
		local umargins : subinstr local umargins "|" "@", all
		.umargins = `"`umargins'"'
		local at_char "@"
	}
	else if "`at_char'" == "" {
		local at_char "@"
	}
	if `.has_atmargins' {
		if `"`umargins'"' != "" {
			local postfix "(`umargins')`postfix'"
			local umargins
		}
	}
	if `:length local postfix' {
		local postfix "`at_char'`postfix'"
	}
	if `:length local prefix' {
		if `"`umargins'"' == "" {
			.contrast = `"`prefix'`postfix'"'
		}
		else {
			.contrast = `"`prefix'#(`umargins')`postfix'"'
		}
	}
	else if `"`umargins'"' != "" {
		.contrast = `"(`umargins')`postfix'"'
	}
	if `"`.contrast'"' == "" {
		.contrast = `"`umargins'"'
	}
	if `"`.contrast'"' == "" {
		di as txt ///
"{p 0 6 2}note: ignoring contrast options because there are no "	///
"margins for applying contrasts{p_end}"
		.has_contrast = 0
		._drop_common_subopts
	}
end

program ._parse_pwcompare_opts
	if `.has_contrast' {
		di as err ///
"option {bf:pwcompare} is not allowed with contrast operators"
		exit 198
	}
	capture ._get_common_subopts `0'
	if c(rc) {
		local rc = c(rc)
		di as err "invalid {bf:pwcompare()} option;"
		._get_common_subopts `0'
		error `rc'	// [sic]
	}
	local 0 `", `s(options)'"'
	local OPTS	CIMargins		/// display opts
			GROUPs			///
						 // blank
	capture syntax [, `OPTS']
	if c(rc) {
		local rc = c(rc)
		di as err "invalid {bf:pwcompare()} option;"
		syntax [, `OPTS']
		error `rc'	// [sic]
	}
	if `"`.mc_all'"' != "" & `"`groups'"' != "" {
		opts_exclusive "mcompare(`.mcall') pwcompare(`groups')"
	}

	.pwcompareopts = "`cimargins' `groups'"
end

program ._setup_pwcompare
	if `.has_pwcompare' == 0 {
		exit
	}

	if `.is_pred' == 2 {
		local prefix _predict
		local sharp "#"
	}

	if `.atrows' > 1 {
		local prefix `prefix'`sharp'_at
		local sharp "#"
	}

	local over `"`.over'"'
	if `:length local over' {
		._put_sharp `over'
		local prefix `prefix'`sharp'`s(result)'
		local sharp "#"
	}

	local within `"`.within'"'
	if `:length local within' {
		._put_sharp `within'
		local prefix `prefix'`sharp'`s(result)'
		local sharp "#"
	}

	if `:length local prefix' {
		if `"`.umargins'"' == "" {
			.pwcompare = `"`prefix'"'
		}
		else {
			.pwcompare = `"`prefix'#(`.umargins')"'
		}
	}
	else {
		.pwcompare = `"`.umargins'"'
	}
	if `"`.pwcompare'"' == "" {
		di as txt ///
"{p 0 6 2}note: ignoring pwcompare options because there are no "	///
"margins for making pairwise comparisons{p_end}"
		.has_pwcompare = 0
		._drop_common_subopts
	}
end

program ._check_by_and_at
	local k_at	= `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'

	forval i = 1/`k_marg' {
		local mvars : colna `.mlist[`i']'
		local mlist `mlist' `mvars'
	}
	local mlist : list uniq mlist

	local over `"`.over'"'
	local common : list mlist & over
	if `:length local common' {
		gettoken x : common
		di as err ///
"factor {bf:`x'} not allowed in {bf:over()} option if it is specified as a margin"
		exit 198
	}
	local within `"`.within'"'
	local common : list mlist & within
	if `:length local common' {
		gettoken x : common
		di as err ///
"factor {bf:`x'} not allowed in {bf:within()} option if it is specified as a margin"
		exit 198
	}

	if `k_marg' == 1 {
		local checkopt singlemargin
	}

	local k 0
	local noasobs 1
	forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		forval j = 1/`k_at' {
			local ++k
			._mstat[`k'] = ._marg_stat_npreg.new
			._mstat[`k'].set_parent	`.objkey'
			._mstat[`k'].set_at	`.atlist[`j']' `.atstat[`j']'
			._mstat[`k'].set_margin	`marg' `mlist'
			._mstat[`k'].check_at, `checkopt'
			if `noasobs' {
				local noasobs = r(noasobs)
			}
		}
	}
	.noasobs = `noasobs'
end

program ._check_exp, eclass
	syntax [if] [in] [fw iw pw aw] [, NOSE pred(passthru)]

	tempname ehold b V
	_est hold `ehold', copy restore

	marksample t_if, novarlist zero

	local wgt "[`weight'`exp']"
	.compute `if' `in' `wgt', check `pred'
	scalar `b' = r(b)
	if r(constant) {
		di as txt ///
"{p 0 0 2}Warning: prediction constant over observations.{p_end}"
	}
	local n = r(N)
	sum `t_if' `wgt' if `t_if', mean
	if r(N) > `n' {
		di as err "{p 0 0 2}"
		di as err ///
"missing predicted values encountered within the estimation sample"
		di as err "{p_end}"
		exit 322
	}

	if `"`nose'"' != "" | `.e_marginsok' {
		exit
	}

	preserve

	// reset e(V) to identity matrix
	matrix `V' = e(V)
	matrix `V' = I(colsof(`V'))
	ereturn repost V=`V'

	// remove all non-integer scalars in e()
	local scalars : e(scalars)
	foreach s of local scalars {
		if e(`s') != floor(e(`s')) {
			if "`s'" != "version" {
				ereturn local `s'
			}
		}
	}

	// set all depvars to zero
	local vlist `"`e(depvar)'"'
	local vlist : list uniq vlist
	local atvars `"`.atvarsopt'"'
	foreach var of local vlist {
		capture fvrevar `var', list
		if !c(rc) {
			local var `r(varlist)'
			if !`:list var in atvars' {
				capture replace `r(varlist)' = 0
			}
		}
	}
	capture {
		.compute `if' `in' `wgt', check `pred'
		assert reldif(`b', r(b)) < 1e-12
	}
	if c(rc) {
		if `"`.oexp'"' != "" {
			if `.is_pred' {
				local msg0 "prediction"
			}
			else {
				local msg0 "expression"
			}
		}
		else {
			local msg0 "prediction"
			if `._pred.arrnels' == 1 {
				if `"`._pred[1].opts'"' == "" {
					local msg0 "default prediction"
				}
			}
		}
		local msg1 ///
" is a function of possibly stochastic quantities other than {bf:e(b)}"
		if `.force' {
			di as txt `"{p 0 7}(note: `msg0' `msg1'){p_end}"'
			exit
		}
		di as err `"{p}`msg0' `msg1'{p_end}"'
		exit 498
	}
end

// subroutines for .compute -------------------------------------------------

program .copyvar
	syntax [varname(default=none)] [, next rename zero]
	local next : length local next
	if `next' {
		local next = `.gen'
	}
	if `next' {
		local rename : length local rename
		local zero : length local zero
		local n = `._phat.arrnels' + 1
		local phat "`.t_phat'`n'"
		._phat[`n'] = "`phat'"
		if `zero' {
			quietly gen byte `phat' = 0
		}
		else if `rename' {
			rename `varlist' `phat'
		}
		else {
			quietly gen double `phat' = `varlist'
		}
	}
end


program ._make_group, sort
	local by `.t_sub' `.by'
	sort `by'
	quietly by `by': gen `.t_grp' = _n == 1 & `.t_sub'
	mata: st__marg_make_group("`.t_gmat'", "`.by'", "`.t_grp'")
	.k_by = rowsof(`.t_gmat')
	if `.k_by' > 1 {
		local nby = colsof(`.t_gmat')
		quietly replace `.t_grp' = sum(`.t_grp') if `.t_sub'
		local GVARS "`.by'"
		forval i = 1/`.k_by' {
			local stripe
			local cross
			local gvars : copy local GVARS
			forval j = 1/`nby' {
				gettoken gvar gvars : gvars
				local level = `.t_gmat'[`i',`j']
				local stripe `stripe'`cross'`level'.`gvar'
				local cross "#"
			}
			.bylist[`i'] = "`stripe'"
		}
	}
	else {
		.hasby = 0
		drop `.t_grp'
		matrix drop `.t_gmat'
	}
end

program ._fill_at
	tempname npregatmat
	local npregatnames ""
	local k_at = `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'
	local k 1
	forval i = 1/`k_marg' {
		local idx 0
		forval j = 1/`k_at'{
			._mstat[`k'].set_at_idx0 `idx'
			local idx = `idx' + rowsof(`.atlist[`j']')
			local ++k
		}
	}
	local r_at 0
	tempname b1 V1
	forval i = 1/`k_at' {
		local r_at = `r_at' + rowsof(`.atlist[`i']')
		._mstat[`i'].fill_at `.atlist[`i']'
		.atstat[`i'] = `"`._mstat[`i'].atstat'"'
		matrix `npregatmat' = ///
			nullmat(`npregatmat') \ `.atlist[`i']'
		local aja = strltrim("`.atopt[`i']'")
		if ("`aja'"!="") {
			local npregatnames ///
				"`npregatnames' at(`.atopt[`i']')"
		}
	}
	if ("`npregatnames'"!="") {
		local npover ""
		if ("`.over'"!="") {
			local npover "over(`.over')"
		}
		if (`.has_pwcompare') {
			local npmypw "pwcompare"
		}
		_margins_npregress `.cuales' if `.t_touse', atmat(`npregatmat') 	///
			atnames(`npregatnames') `.deriva' `npover'	///
			`npmypw' 
		matrix `b1' = r(b1)
		matrix `V1' = r(V1)
	}

	.atrows = `r_at'
end

program ._est1_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_compute(`"`.objkey' `0'"')
end

program ._est1_db_cr
	syntax [if] [in] [fw pw iw aw/] [, NONEXT pred(int 1)]
	local deriv 0
	if `.is_pred' & `.numeric' == 0 {
		local deriv = `._pred[`pred'].deriv'
	}

	if `deriv' {
		.cr_a = 1
		._est1_db_cr_a `0'
	}
	else	._est1_db_cr_n `0'
end

program ._est1_db_cr_n
	syntax [if/] [in] [fw pw iw aw/] [, NONEXT pred(passthru)]
	tempname ehold
	_est hold `ehold', copy restore
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	mata: st__marg_cr_compute(`"`.objkey' `wgt'"', `"`if'"', `"`pred'"', "`.t_cr'")
end

program ._est1_db_cr_a, rclass
	syntax [if] [in] [fw pw iw aw] [, NONEXT pred(int 1)]
	if `"`nonext'"' == "" {
		local next next
	}

	local pvar `._pred[`pred'].varname'
	if `:length local weight' {
		local wgt [`weight'`exp']
	}

	tempname N b db

	_ms_eq_info
	local keq = r(k_eq)

	tempname b bi db dbi
	matrix `b' = e(b)

	if `.ey' {
		tempvar y
		._pred[`pred'].Predict `if' `in'
		rename `pvar' `y'
		quietly replace `y' = . if `y' <= 0 `in'
	}

	local uscons _cons
	local ouscons o._cons
	forval i = 1/`keq' {
		._pred[`pred'].Predict `if' `in', d1(#`i')
		matrix `bi' = `b'[1,"#`i':"]
		local xvars : colna `bi'
		local nocons
		if `:list uscons in xvars' {
			local xvars : list xvars - uscons
		}
		else if `:list ouscons in xvars' {
			local xvars : list xvars - ouscons
		}
		else	local nocons nocons
		if `.ey' {
			quietly replace `pvar' = `pvar'/`y' `if' `in'
		}
		quietly ///
		matrix vecaccum `dbi' = `pvar' `xvars' `if' `in' `wgt',	///
			anysumok `nocons'
		matrix `db' = nullmat(`db'), `dbi'/r(sum_w)
	}
	.compute `if' `in' `wgt', `next' pred(`pred')
	if "`next'" == "" {
		sum `pvar' `if' `in' `wgt', mean
	}
	else {
		local pvar "`._phat[`._phat.arrnels']'"
		sum `pvar' `if' `in' `wgt', mean
	}
	return scalar b = r(mean)
	return scalar N = r(N)
	return matrix db `db'
end

program ._est2_c, rclass
	syntax [if] [in], xvar(string) [mult(passthru) pred(int 1)]
	tempvar b nobs db npdb npb ndb npv
	if `.est_chk' {
		._check_est `if' `in' `.wt', `mult' pred(`pred')
		if r(not_estimable) {
			return add
			exit
		}
	}

	local xopt xvar(`xvar')

	local deriv 0
	if `.is_pred' & `.numeric' == 0 {
		local deriv = `._pred[`pred'].deriv'
	}

nobreak {

capture noisily break {

	if `deriv' {
		.cr_a = 1
		._est2_c_cr_a `if' `in', pred(`pred')
	}
	else if !`.cr_use' {
		tempvar hold
		local char
		capture local char : char `xvar'[tsrevar]
		rename `xvar' `hold'
		quietly gen double `xvar' = `hold'
		char `xvar'[tsrevar] `"`char'"'
	}
	else {
		.xvar = "1"
		._est2_c_cr_n `if' `in', pred(`pred')
	}

} // capture noisily break
	local rc = c(rc)

	if !`rc' {
capture noisily quietly break {

	.h	= 0
	.scale	= 0
	.xvar	= "`hold'"
	if `deriv' | `.cr_use' {
		_marg_dydx_ccompute_cr `.objkey' `if' `in' `.wt', ///
			`xopt' `.nose' next
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		if `.se' {
			matrix `db' = r(db)
		}
	}
	else if "`.nose'" != "" {
		_marg_dydx_ccompute `.objkey' `if' `in' `.wt', `xopt'
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		._est2_c_phat `if' `in', `xopt' next pred(`pred')
	}
	else {
		._est2_c_db `.objkey' `if' `in' `.wt', `xopt' pred(`pred')
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		matrix `db'	= r(db)
		._est2_c_phat `if' `in', `xopt' next pred(`pred')

	}

} // capture noisily quietly break
	local rc = c(rc)

	}

	if !`deriv' & !`.cr_use' {
		capture drop `xvar'
		rename `hold' `xvar'
	}

} // nobreak 
	if `rc' {
		exit `rc'
	}

	return scalar b = `b'
	return scalar N = `nobs'
	if `.se' {
		return matrix db `db'
	}
end

program ._est2_c_cr_a
	syntax [if] [in] [, pred(int 1)]
	capture drop `.t_dzb'*

	local y `._pred[`pred'].varname'
	local neq = rowsof(`.t_cr')
	tempname t
	forval i = 1/`neq' {
		// dpdxb
		._pred[`pred'].Predict `if' `in', d1(#`i')
		local d`i' `.t_dzb'_`i'
		rename `y' `d`i''
		forval j = 1/`i' {
			// d2pdxbdxb
			._pred[`pred'].Predict `if' `in', d1(#`i') d2(#`j')
			local d`i'_`j' `.t_dzb'_`i'_`j'
			rename `y' `d`i'_`j''
		}
	}
	if `.ey' == 0 {
		exit
	}
	._pred[`pred'].Predict `if' `in'
	quietly replace `y' = . if `y' <= 0 `in'
	forval i = 1/`neq' {
		quietly replace `d`i'' = `d`i''/`y' `if' `in'
		forval j = 1/`i' {
			quietly replace `d`i'_`j'' =		///
				-`d`i''*`d`j''			///
				+`d`i'_`j''/`y'			///
				`if' `in'
		}
	}
end

program ._est2_c_cr_n
	syntax [if] [in] [, pred(int 1)]
	capture drop `.t_dzb'*

	local cmd _est2_c_cr1
	if `.cr_use2' {
		local cmd _est2_c_cr2
	}

	local neq = rowsof(`.t_cr')
	tempname t
	local is_xb = `.is_xb[`pred']' & !`.numeric'
	if `is_xb' {
		if `.ey' {
			.ey = 0
			.compute `if' `in' `.wt', gen(`t') pred(`pred')
			.ey = 1
			local vt_i 1/`t'
			local vt_ij -1/`t'^2
			local ttype double
		}
		else {
			local vt_i 1
			local vt_ij 0
			local ttype byte
		}
		local eqno = `.eqno[`pred']'
	}
	forval i = 1/`neq' {
		local ti `.t_dzb'_`i'
		// dpdxb
		if !`is_xb' {
			quietly gen double `ti' = . in 1
		}
		else if `eqno' == `i' {
			quietly gen `ttype' `ti' = `vt_i'
		}
		else {
			quietly gen byte `ti' = 0
		}
		forval j = 1/`i' {
			// d2pdxbdxb
			local tij `.t_dzb'_`i'_`j'
			if !`is_xb' {
				quietly gen double `tij' = . in 1
			}
			else if `eqno' == `i' & `eqno' == `j' {
				quietly gen `ttype' `tij' = `vt_ij'
			}
			else {
				quietly gen byte `tij' = 0
			}
	
		}
	}
	if !`is_xb' {
		.`cmd' `.t_dzb' `if' `in' `.wt', pred(`pred')
	}
end

program ._est2_c_cr1
	tempname ehold
	_est hold `ehold', copy restore
	syntax name(name=t) [fw pw iw aw/] [if/] [in] [, pred(passthru)]
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	local cr `.t_cr'
	mata: st__marg_dydx_cr_compute(`"`.objkey' `wgt'"', `"`if'"', `"`pred'"', `.se')
end

program ._est2_c_cr2
	tempname ehold
	_est hold `ehold', copy restore
	syntax name(name=t) [fw pw iw aw/] [if/] [in] [, pred(passthru)]
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	local cr `.t_cr'
	mata: st__marg_dydx_cr2_compute(`"`.objkey' `wgt'"', `"`if'"', `"`pred'"', `.se')
end

program ._est2_c_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_dydx_ccompute(`"`0'"')
end

program ._est2_c_phat
	syntax [if] [in], xvar(string) [next pred(passthru)]

	local next : length local next
	if `next' & `.gen' {
		tempname d hold p1 p2
		scalar `d' = float(`.h'*`.scale')
		rename `xvar' `hold'
		quietly gen double `xvar' = `hold' - `d'
		.compute `if' `in' `.wt', gen(`p1') `pred'
		quietly replace `xvar' = `hold' + `d'
		.compute `if' `in' `.wt', gen(`p2') `pred'
		quietly replace `xvar' = (`p2' - `p1')/(2*`d')
		.copyvar `xvar', next rename
		rename `hold' `xvar'
	}
end

program ._est2_d, rclass
	syntax [if] [in], xvar(string) [mult(name) pred(passthru)]
	tempvar b nobs db npdb npb ndb npv
	_ms_parse_parts `xvar'
	local var `r(name)'
	local k = r(level)
	.get_dx_base `var'
	if `k' == r(base) {
		scalar `b'	= 0
		scalar `nobs'	= 0
		if `:length local mult' {
			matrix `mult' = 0*e(b)
		}
		if `.se' {
			matrix `db' = 0*e(b)
		}
		.copyvar, next zero
	}
	else {
		._est2_d1 `0'
		if r(not_estimable)==1 {
			return add
			exit
		}
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		if `.se' {
			matrix `db' = r(db)
		}
	}

	return scalar b = `b'
	return scalar N = `nobs'
	if `.se' {
		return matrix db `db'
	}
	return scalar not_estimable = 0
end

program ._est2_d1
	syntax [if] [in], xvar(passthru) [mult(passthru) pred(passthru)]
/*	if `.est_chk' | !`.se' | `:length local mult' | "`.vce'" == "unconditional" {

		if `.cr_use' | !`.se' {
			local next next
		}
		local estchk = cond(`.est_chk', "estimcheck", "")
		_marg_dydx_dcompute `.objkey' `if' `in' `.wt', ///
			`xvar' `next' `mult' `estchk' `pred'
		if r(not_estimable) == 1 {
			exit
		}
	}
	if `.se' {
		if `.cr_use' {
			._est2_d1_db_cr `if' `in' `.wt', `xvar' `mult' `pred'
		}
		else {
			._est2_d1_db `.objkey' `if' `in' `.wt', `xvar' `pred'
		}
	}
	*/
end

program ._est2_d1_db_cr, rclass
	syntax [fw pw iw aw] [if] [in],	///
		xvar(string)		///
		[ mult(name) pred(passthru) ]
	tempname p0 p1 n0 n1

	_ms_parse_parts `xvar'
	* xvar should NOT have tsops
	assert "`r(ts_op)'" == ""
	local var `r(name)'
	local k = r(level)
	.get_dx_base `var'
	local base = r(base)

	local BALVARS `"`.BALVARS'"'
	if `:length local BALVARS' {
		tempname mult0 mult1
		if "`.empty'" != "rweight" & `:length local mult' {
			local mult1 : copy local mult
		}
		local balopt balvars(`BALVARS')
	}
	if `.se' {
		tempname db0 db1
	}

	._compute1 `if' `in' [`weight'`exp'], xvar(`var') k(`base')	///
		`balopt' mult(`mult0') `pred'
	scalar `p0' = r(b)
	scalar `n0' = r(N)
	if `.se' {
		matrix `db0' = r(db)
		if `:length local mult0' {
			mata: st_matrix("`db0'",	///
					st_matrix("`db0'") :* ///
					abs(st_matrix("`mult0'")))
		}
	}

	._compute1 `if' `in' [`weight'`exp'], xvar(`var') k(`k')	///
		`balopt' mult(`mult1') `pred'
	scalar `p1' = r(b)
	scalar `n1' = r(N)
	if `.se' {
		matrix `db1' = r(db)
		if `:length local mult1' {
			mata: st_matrix("`db1'",	///
					st_matrix("`db1'") :* ///
					abs(st_matrix("`mult1'")))
		}
	}

	if `n0' != `n1' {
		di as err "{p}" ///
"inconsistent estimation sample levels `base' and `k' of factor {bf:`var'}" ///
		"{p_end}"
		exit 459
	}

	return scalar b = `p1' - `p0'
	return scalar N = `n1'
	return scalar not_estimable = 0
	if `.se' {
		matrix `db1' = `db1' - `db0'
		return matrix db `db1'
	}
	if `:length local mult' & "`.empty'" == "reweight" {
		local c = colsof(`mult1')
		matrix `mult' = `mult1' - `mult0'
		forval i = 1/`c' {
			if `mult0'[1,`i'] == 1 {
				matrix `mult'[1,`i'] = 1
			}
		}
	}
end

program ._balance, eclass
	gettoken mult balvars : 0
	tempname b
	_ms_balance `balvars', `.empty'
	matrix `b' = r(b)
	ereturn repost b=`b', rename
	matrix `mult' = r(mult)
end

program ._compute1
	syntax [fw pw iw aw] [if] [in],				///
		xvar(varname)					///
		k(integer)					///
		[	GENerate(passthru)			///
			mult(name)				///
			BALVARS(string)				///
			pred(passthru)				///
		]
	local wgt [`weight'`exp']

	if `:length local balvars' {
		tempname ehold
		_est hold `ehold', copy restore
		._balance `mult' `balvars' `k'.`xvar'
	}

nobreak {

capture noisily break {

	tempvar hold
	rename `xvar' `hold'
	quietly gen `xvar' = `k'

} // capture noisily break
	local rc = c(rc)

	if !`rc' {

capture noisily quietly break {

		._est1_db_cr `if' `in' `wgt', nonext `pred'

} // capture noisily quietly break
	local rc = c(rc)

	}

	capture confirm var `hold'
	if !c(rc) {
		capture drop `xvar'
		rename `hold' `xvar'
	}

} // nobreak
	exit `rc'
end

program ._est2_d1_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_dydx_dcompute(`"`0'"')
end

program ._rename4generate, rclass
	args b

	local stub `"`.genstub'"'

	if `"`stub'"' == "" {
		exit
	}

	local colna : colfullnames `b'
	if "`.xvars'" != "" {
		local xvars `"`.xvars'"'
	}
	else {
		local xvars _cons
	}

	local k_marg	= `.mlist.arrnels'
	local k_at	= `.atlist.arrnels'
	local k_predict	= `._pred.arrnels'
	if `k_predict' == 0 {
		local k_predict = 1
	}
	local vidx 0
	local k 0
	foreach x of local xvars {
	    forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		local k_l = rowsof(`marg')
		forval j = 1/`k_at' {
		    local at `.atlist[`j']'
		    local r_at = rowsof(`at')
		    local g 1
		    forval r = 1/`r_at' {
			forval l = 1/`k_l' {
			  forval predict = 1/`k_predict' {
			    local ++k
			    local phat `._phat[`k']'

			    local ++vidx
			    capture confirm new variable `stub'`vidx'
			    while c(rc) {
				local ++vidx
				capture confirm new variable `stub'`vidx'
			    }
			    gettoken bname colna : colna
			    _msparse `bname', noomit
			    local bname `"`r(stripe)'"'
			    label variable `phat' ///
			    	"margins generate variable for `bname'"
			    rename `phat' `stub'`vidx'

			    local vlist `vlist' `stub'`vidx'
			  }
			}
			if `.hasby' {
			    local g = mod(`g',`k_by') + 1
			}
		    }
		}
	    }
	}
	return local varlist `"`vlist'"'
end


exit
