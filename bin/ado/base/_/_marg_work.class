*! version 1.11.6  20dec2019
version 11

class _marg_work {
	string	vv	= "11"

	string	t_name	= ""		// tempnames
	string	t_touse	= ""
	string	t_sub	= ""
	string	t_esub	= ""
	string	t_wvar	= ""
	string	t_marg	= ""
	string	t_at	= ""
	string	t_cr	= ""
	string	t_grp	= ""
	string	t_gmat	= ""
	string	t_phat	= ""
	string	t_dx	= ""
	string	t_dzb	= ""
	string	t_altb	= ""
	string	t_H	= ""
	string	t_cm1	= ""

	string	matopt	= ""
	string	FVTImatopt	= ""

	double	esample	= 0

	string	ecmd	= ""

	string	est_cmd	= ""
	string	cmdline	= ""
	string	ZERO	= ""

	double	level	= 0
	string	diopts	= ""

	string	wtype	= ""		// weights
	string	wexp	= ""
	string	wt	= ""
	string	wt_hold	= ""

	array	atlist			// at()
	array	atstat
	array	atopt
	array	_asbal
	double	atmean		= 0
	double	hasat		= 0
	double	atrows		= 0
	double	noasobs		= 0
	string	atcol0		= ""
	string	atcol1		= ""
	double	has_asbal	= 0
	string	atlegend	= ""
	string	BALVARS		= ""
	string	uatvars		= ""
	string	atvarsopt	= ""
	double	at_b_dim	= 0
	string	xtra_atvars	= ""
	double	restripe	= 0

	string	by	= ""
	string	over	= ""
	string	within	= ""
	double	k_by	= 1
	double	hasby	= 0
	array	bylist

	string	empty	= ""

	string	subpop	= ""

	double	hascm		= 0		// [CM] information
	string	myaltvar	= ""
	string	altvar		= ""
	array	altlist
	array	altsel
	double	alt_seq		= 0
	double	naltsel		= 0
	double	altfirst	= -1
	array	outsel
	double	noutsel		= 0
	double	outfirst	= -1
	string	casevars	= ""
	array	altSpecAtvar
	array	hasAltSpecMarg
	array	hasAltSpecAt
	double	hasAltSpec	= 0
	array	altSpecXvar
	string	cm_casevar	= ""
	string	cm_panelvar	= ""
	array	cm_atlist			// at()
	array	cm_atstat
	array	cm_at_filled
	double	cm_rescale	= 1
	array	cm_sumw
	array	cm_N

	string	nose		= ""	// VCE
	double	se		= 0
	string	vce		= ""
	string	vcetype		= ""
	string	model_vce	= ""
	string	model_vcetype	= ""
	double	lin		= 0
	string	clustvar	= ""
	string	clopt		= ""
	double	nclust		= 0
	double	is_svy		= 0
	double	npop		= 0
	double	npsu		= 0
	double	nstr		= 0
	double	df_r		= 0
	double	npost		= 0
	string	posts		= ""
	string	postw		= ""
	string	calmethod	= ""
	string	calmodel	= ""
	string	calopts		= ""

	double	nobs	= 0
	double	subnobs	= 0

	string	margdflt	= ""
	array	_pred			// array of predictions in expression
	array	is_xb			// indicator: _pred[i] is xb
	array	eqno			// equation for xb in _pred[i]
	array	offset			// indicator: offset in xb
	string	oexp	= ""		// original expression
	string	gexp	= ""		// generate expression
	double	is_pred	= 0		// indicator: expression is predict
					// 2: means not expression
	array	plabel			// var label from predict/xb
	double	numeric	= 0		// indicator: numerical derivatives
	double	force	= 0
	double	e_marginsok = 0
	double	use_in1	= 1

	double	est_chk	= 0
	double	noHmat	= 0
	string	check_est_u	= ""

	double	cr_any	= 0		// chainrule
	double	cr_all	= 0
	double	cr_cons	= 0
	double	cr_use	= 1
	double	cr_use2	= 0
	double	cr_a	= 0

	array	_base			// base level index
	array	mlist			// margin matrix list
	double	k_m	= 0
	double	hasm	= 0
	string	margins	= ""

	string	umargins	= ""

	string	commonopts	= ""

	double	has_contrast	= 0
	string	contrast	= ""
	string  contrastopts	= ""
	double	has_ocontrast	= 0
	string	ocontrast	= ""
	double	has_wcontrast	= 0
	string	wcontrast	= ""
	double	has_atcontrast	= 0
	string	atcontrast	= ""
	double	has_pcontrast	= 0
	string	pcontrast	= ""
	double	has_atmargins	= 0
	double	has_outcontrast	= 0
	string	outcontrast	= ""
	double	has_altcontrast	= 0
	string	altcontrast	= ""

	double	has_pwcompare	= 0
	string	pwcompare	= ""
	string  pwcompareopts	= ""

	string  mc_all		= ""
	string  mc_method	= ""
	string  mcompareopt	= ""

	string	xvars		= ""	// x vars for dy/dx
	string	xovars		= ""
	string	xrevars		= ""
	double	ey		= 0
	double	ex		= 0
	string	fvrestripe	= ""
	string	xvar		= "1"	// current x for dy/dx
	array	dxolist			// (1) original names
	array	dxnlist			// (1) restripe names
	array	dxmlist			// (2) dx term matrices
	array	dxvlist			// (2) dx term varnames
	array	dxbase			// base level index for dx factor
	double	dxhasbase	= 0

	double	partial	= 0

	array	_mstat

	string	title	= ""
	string	coefttl	= ""
	string	dydxopt	= ""

	double	post	= 0

	string	saving		= ""
	string	sav_double	= ""
	string	sav_replace	= ""

	string	footnote	= ""

	double	plot		= 0
	string	plotopts	= ""

	double	est_tol	= 1e-7

	double	gen	= 0
	string	genstub	= ""
	array	_phat
	array	first

	double	h	= 0
	double	scale	= 0
	double	markout = 1
}

program .new
	.vv = string(_caller())
	syntax name(name=tname id="tempname")
	if "`e(b)'" != "matrix" {
		error 301
	}
	if "`e(cmd2)'" != "" {
		.ecmd = "`e(cmd2)'"
	}
	else	.ecmd = "`e(cmd)'"
	if `"`e(marginsnotok)'"' == "_ALL" {
		di as err ///
		"command {bf:margins} not appropriate after {bf:`.ecmd'}"
		exit 322
	}
	if "`e(cmd)'" == "margins" {
		di as err ///
		"{bf:margins} cannot work with its own posted results"
		exit 322
	}
	.t_name	= "`tname'"
	.t_touse= "`tname'_touse"
	.t_sub	= "`tname'_sub"
	.t_esub	= "`tname'_esub"
	.t_wvar	= "`tname'_wvar"
	.t_marg	= "`tname'_marg"
	.t_at	= "`tname'_at"
	.t_cr	= "`tname'_cr"
	.t_grp	= "`tname'_grp"
	.t_gmat	= "`tname'_gmat"
	.t_phat	= "`tname'_phat"
	.t_dx	= "`tname'_dx"
	.t_dzb	= "`tname'_dzb"
	.t_altb	= "`tname'_altb"
	.t_H	= "`tname'_H"
	.t_cm1	= "`tname'_cm1"
	local covar `"`e(covariates)'"'
	local k : list sizeof covar
	if `k' {
		if "`covar'" == "_NONE" {
			local covar _cons
		}
		matrix `.t_altb' = J(1,`k',0)
		capture {
			matrix colna `.t_altb' = `covar'
		}
		if c(rc) {
			capture matrix drop `.t_altb'
			.t_altb = ""
		}
	}
	else	.t_altb = ""
	local margprop `"`e(marginsprop)'"'
	if `"`.t_altb'"' != "" {
		if `:list posof "noeb" in margprop' {
			_ms_op_info `.t_altb'
			if r(tsops) {
				di as err ///
"{bf:margins} cannot work with time-series operators in " ///
"{bf:`.ecmd'} estimation results"
				exit 322
			}
			.FVTImatopt = `"matrix(`.t_altb')"'
		}
		.matopt = `"matrix(`.t_altb')"'
	}
	if `:list posof "cm" in margprop' {
		.hascm = 1
	}
	.is_xb[1]	= 0
	.eqno[1]	= 0
	.offset[1]	= 0
	.footnote	= `"`e(marginsfootnote)'"'
end

program .destructor
	capture drop `.t_touse'
	capture drop `.t_sub'
	capture drop `.t_esub'
	capture drop `.t_wvar'
	local k = `.mlist.arrnels'
	forval i = 1/`k' {
		capture matrix drop `.mlist[`i']'
	}
	if `.hascm' {
		capture drop `.t_cm1'
		local k = `.cm_atlist.arrnels'
		forval i = 1/`k' {
			capture matrix drop `.cm_atlist[`i']'
		}
		if `"`.altvar'"' != `"`.myaltvar'"' {
			capture drop `.myaltvar'
			capture label drop `.myaltvar'
		}
	}
	else {
		local k = `.atlist.arrnels'
		forval i = 1/`k' {
			capture matrix drop `.atlist[`i']'
		}
	}
	capture matrix drop `.t_cr'
	capture drop `.t_grp'
	capture matrix drop `.t_gmat'
	local k = `._phat.arrnels'
	forval i = 1/`k' {
		capture drop `._phat[`i']'
	}
	local k = `.dxmlist.arrnels'
	forval i = 1/`k' {
		capture matrix drop `.dxmlist[`i']'
	}
	if "`.t_dzb'" != "" {
		capture drop `.t_dzb'*
	}
	if "`.t_altb'" != "" {
		capture matrix drop `.t_altb'
	}
	if "`.t_H'" != "" {
		capture matrix drop `.t_H'
	}
	.matopt == ""
	.FVTImatopt == ""
end

program .parse
	.est_cmd = `"`e(cmd)'"'
	.check_est_u = `"`e(margins_check_est)'"'
	.cmdline = `"`e(cmdline)'"'
	.ZERO = `"`0'"'
	syntax [anything] [if] [in] [fw aw iw pw] [,	///
			Level(cilevel)			///
			grand				///
			ATMEANs				///
			ASBALanced			///
			ASOBServed			/// default
			SUBpop(passthru)		///
			by(passthru)			///
			over(passthru)			///
			within(passthru)		///
			EMPTYCells(string)		///
			NOWEIGHTs			///
			NOEsample			///
			post				///
			SAVing(string)			///
			NOSE				///
			VCE(passthru)			///
			NOCHAINrule CHAINrule		///
			chain2				/// NOT DOCUMENTED
			noestimcheck			///
			force				///
			vsquish				///
			PRedict(passthru)		/// -predict- options
			EXPression(string)		///
			numerical			/// NOT DOCUMENTED
			atslow				/// NOT DOCUMENTED
			marginsallok			/// NOT DOCUMENTED
			dydx(passthru)			///
			eyex(passthru)			///
			dyex(passthru)			///
			eydx(passthru)			///
			CONTinuous			///
			NOATLegend			///
			MCOMPare(passthru)		///
			CONTRast			///
			CONTRast1(string)		///
			PWCOMPare			///
			PWCOMPare1(string)		///
			ESTIMTOLerance(real 1e-5)	///
			DF(numlist max=1 >0 missingok)	///
			GENerate(name)			///
			ATVARs(varlist numeric)		/// -at()- options
			PLOT				///
			PLOTopts(string asis)		///
			*				///
		]

	if `.hascm' {
		._parse_cmopts, `options'
		local options `"`s(options)'"'
	}

	local lgenerate : length local generate
	local lgmax 16
	if `lgenerate' > `lgmax' {
		di as err "{p}"
		di as err "invalid {bf:generate()} option;{break}"
		di as err "stub name may not exceed `lgmax' characters"
		di as err "{p_end}"
		exit 198
	}
	.genstub = "`generate'"
	if "`generate'" != "" {
		.use_in1 = 0
	}

	if _caller() >= 12 {
		if `estimtolerance' < 0 {
			di as err "invalid {bf:estimtolerance()} option;"
			di as err "negative values not allowed"
			exit 198
		}
		.est_tol = `estimtolerance'
	}

	local margprop `"`e(marginsprop)'"'
	if `:list posof "atslow" in margprop' {
		local atslow atslow
	}

	if `:length local contrast1' {
		local contrast contrast
	}
	if `:length local pwcompare1' {
		local pwcompare pwcompare
	}
	opts_exclusive "`contrast' `pwcompare'"
	.has_contrast = "`contrast'" != ""
	.has_pwcompare = "`pwcompare'" != ""

	.level	= `level'
	_get_diopts diopts options, `options'
	.diopts = `"`diopts' `vsquish' level(`level')"'

	// check for invalid option combinations
	opts_exclusive `"`weight' `noweights'"'
	opts_exclusive `"`vce' `nose'"'
	opts_exclusive `"`chainrule' `nochainrule' `chain2'"'
	opts_exclusive `"`dydx' `eyex' `dyex' `eydx'"'

	.force	= "`force'" != ""
	.wtype	= "`weight'"
	.wexp	= "`exp'"
	.est_chk= "`estimcheck'" == ""
	if `.est_chk' {
		_get_hmat `.t_H'
		if r(rc) {
			.t_H = ""
			.noHmat = 1
			.est_chk = 0
		}
	}

	// parse the multiple -predict()- options
	.first[1] = 1
	if `"`predict'"' != "" | `"`expression'"' == "" {
		if `"`predict'"' == "" & `.vv' >= 14 {
			local predict `"`e(marginsdefault)'"'
			.margdflt = `"`predict'"'
		}
		._parse_predict, `predict' `options'
		local options `"`r(options)'"'
	}
	// parse the prediction expression
	if `:length local expression' {
		opts_exclusive "expression() `predict'"
		._parse_expression `expression'
		if !`:length local chainrule' & !`:length local chain2' {
			local nochainrule nochainrule
		}
	}
	._check_predict
	if "`marginsallok'" != "" {
		.e_marginsok = 1
	}
	._check_predict_markout

	// parse the multiple -at()- options
	.atlegend = "`noatlegend'"
	.atmean	= "`atmeans'" != ""
	opts_exclusive "`asbalanced' `asobserved'"
	._parse_atvarsopt `atvars'
	._parse_at, `asbalanced' `options'
	._parse_emptycells, `emptycells'

	local UCONS _cons
	local atvars : colna `.atlist[1]'
	local atvars : list atvars - UCONS

	// multiple subpopulations
	opts_exclusive "`by' `over'"
	._parse_by, `by' `over' `within'

	if "`.empty'" == "" {
		.empty = "strict"
	}

	// managing the results
	.post	= "`post'" != ""
	if !`.post' {
		._parse_post_required, `diopts'
	}
	.saving	= "`saving'"

	// the -vce()- option
	if `"`e(V)'"' == "" {
		if `"`vce'"' != "" {
			di as err "option {bf:`vce'} not allowed"
			exit 322
		}
		local nose nose
	}
	.nose	= "`nose'"
	.se	= `:length local nose' == 0
	._parse_vce, `vce'
	if `"`.genstub'"' != "" {
		.gen = 1
	}

	if `.is_svy' & `.lin' {
		if `:length local noweights' {
			di as err "{p}" ///
"option {bf:noweights} not allowed with {bf:vce(unconditional)} " ///
"and {bf:svy} estimation results{p_end}"
			exit 198
		}
		._check_svyset
		local esubpop "`e(subpop)'"
	}

	if !`:length local noweights' {
		if `"`.wtype'"' == "" {
			if `"`e(marginswtype)'"' != "" {
				.wtype	= `"`e(marginswtype)'"'
				.wexp	= `"`e(marginswexp)'"'
			}
			else {
				.wtype	= `"`e(wtype)'"'
				.wexp	= `"`e(wexp)'"'
			}
		}
		local weight `"`.wtype'"'
		local exp `"`.wexp'"'
	}
	if `.is_svy' | "`.wtype'" == "iweight" {
		local zero zeroweight
	}

	// estimation sample
	.esample = "`noesample'" == ""
	local has_t_sub 0
	if `.esample' | "`.vce'" == "unconditional" {
		if `.esample' | !`.force' {
			._check_esample
			quietly gen byte `.t_touse' = e(sample)
		}
		else {
			quietly gen byte `.t_touse' = 1
		}
		local IF : copy local if
		local if
		local IN : copy local in
		local in
		if `"`weight'"' == "" {
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse weights
		}
		if `:length local IF' {
			local if : copy local IF
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse {bf:if} restriction
		}
		if `:length local IN' {
			local in : copy local IN
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse {bf:in} range
		}
		if `.is_svy' {
			svymarkout `.t_touse'
			._check_touse {bf:svy} settings
		}
		if `:length local esubpop' {
			_svy_subpop `.t_touse' `.t_esub', ///
				subpop(`esubpop')
			._check_touse {bf:subpop()} option
			if `:length local exp' {
				gettoken EQUAL W : exp
				quietly replace `.t_esub' = 0 if `W' == 0
			}
			tempname subuse
			quietly gen byte `subuse' = `.t_esub'
			if `.markout' {
				markout `subuse' `atvars'
			}
			quietly replace `.t_touse' = 0 if `.t_esub' & !`subuse'
		}
		else {
			.t_esub = ""
			if `.markout' {
				markout `.t_touse' `atvars'
			}
		}
		._check_touse indepvars
	}
	else {
		if "`e(marginsmark)'" != "" {
			`e(marginsmark)' `.t_touse' `.t_sub'	///
				`if' `in'			///
				[`weight'`exp'], `zero'		///
				subpop(`subpop')		///
				over(`.over')			///
				within(`.within')
			local has_t_sub 1
		}
		else {
			marksample touse, novarlist `zero'
			rename `touse' `.t_touse'
			if `.is_svy' {
				svymarkout `.t_touse'
			}
			if `.markout' {
				markout `.t_touse' `atvars'
			}
		}
		if `:length local esubpop' {
			_svy_subpop `.t_touse' `.t_esub', subpop(`esubpop')
		}
		else {
			.t_esub = ""
		}
	}

	if `has_t_sub' == 0 {
		if `:length local subpop' {
			tempname touse
			quietly gen byte `touse' = `.t_touse'
			_svy_subpop `touse' `.t_sub', `subpop'
			.subpop = `"`r(subpop)'"'
			drop `touse'
		}
		else {
			quietly gen byte `.t_sub' = `.t_touse'
		}
	}

	// weights
	if "`.posts'" != "" {
		tempvar wvar
		svygen post double `wvar'	///
			[`.wtype'`.wexp']	///
			if `.t_touse',		///
			posts(`.posts')		///
			postw(`.postw')
	}
	else if "`.calmethod'" != "" {
		tempvar wvar
		svycal `.calmethod'		///
			`.calmodel'		///
			[`.wtype'`.wexp']	///
			if `.t_touse',		///
			generate(`wvar')	///
			`.calopts'
	}
	else if "`.wtype'" != "" {
		tempvar wvar
		quietly gen double `wvar' `.wexp'
	}

	if `:length local wvar' & `:length local zero' {
		quietly replace `.t_sub' = 0 if `wvar' == 0
		if "`.t_esub'" != "" {
			quietly replace `.t_esub' = 0 if `wvar' == 0
		}
	}

	if `.hasby' {
		quietly count if `.t_sub'
		local nsub = r(N)
		markout `.t_sub' `.by'
		quietly count if `.t_sub'
		if `nsub' != r(N) {
			if `:word count `.by'' > 1 {
				local vars "variables"
			}
			else	local vars "variable"
			local nsub = `nsub' - r(N)
			if `nsub' > 1 {
				local obs "observations"
			}
			else	local obs "observation"
			if "`.over'" != "" & "`.within'" != "" {
				local msg "over() or within()"
			}
			else if "`.over'" != "" {
				local msg "over()"
			}
			else {
				local msg "within()"
			}
			di as txt "{p 0 7}(note: " ///
"`nsub' `obs' dropped because of missing values in `msg' `vars')" ///
			"{p_end}"
		}
	}

	quietly count if `.t_sub'
	if r(N) == 0 {
		error 2000
	}
	if "`.wtype'" == "fweight" {
		._check_fweight
		sum `.t_touse' [`.wtype'`.wexp'] if `.t_touse', mean
		.nobs = r(sum_w)
		sum `.t_sub' [`.wtype'`.wexp'] if `.t_sub', mean
		.subnobs = r(sum_w)
	}
	else {
		quietly count if `.t_touse'
		.nobs	= r(N)
		quietly count if `.t_sub'
		.subnobs= r(N)
	}

	if `:length local wvar' {
		rename `wvar' `.t_wvar'
		if inlist("`.wtype'", "", "pweight") {
			.wt = "[iweight=`.t_wvar']"
		}
		else {
			.wt = "[`.wtype'=`.t_wvar']"
		}
		.wt_hold = `"`.wt'"'
	}

	if `:list posof "nochainrule" in margprop' {
		local nochainrule nochainrule
	}

	if "`.t_altb'" == "" | `.at_b_dim' {
		// determine chainrule status for partial derivatives
		_ms_chainrule b if `.t_sub', eclass
		.cr_any		= r(any)
		.cr_all		= r(all)
		.cr_cons	= r(_cons)
		matrix `.t_cr' = r(chainrule)
		if !`.cr_any' {
			.cr_use = 0
		}
	}
	else {
		local nochainrule nochainrule
		if `:list posof "nonumerical" in margprop' == 0 {
			local numerical numerical
		}
	}

	// always use numerical derivatives
	if `:length local numerical' {
		.numeric = 1
	}

	// always use calculations across observations even when all 'at'
	// variables and 'margin' variables are fixed/constant
	if `:length local atslow' {
		.use_in1 = 0
	}

	if "`df'" != "" {
		if !missing(`df') {
			.df_r = `df'
		}
	}
	else if _caller() >= 13 {
		if `.is_pred' & !missing(e(df_r)) {
			local df_r = e(df_r)
			forval i = 1/`._pred.arrnels' {
				if !`.is_xb[`i']' {
					local df_r 0
					continue, break
				}
			}
			.df_r = `df_r'
		}
	}

	if `._pred.arrnels' == 0 {
		if `:length local chainrule' {
			di as err "option {bf:chainrule} not allowed"
			exit 198
		}
		if `:length local chain2' {
			di as err "option {bf:chain2} not allowed"
			exit 198
		}
		local nochainrule nochainrule
	}
	else if `:length local chainrule' | `:length local chain2' {
		local nochainrule
	}
	if "`nochainrule'" != "" {
		.cr_use = 0
	}
	else if `:length local chain2' & `.cr_any' {
		.cr_use2 = 1
	}

	// parse marginal effects and elasticities
	._parse_dydx, `dydx' `eyex' `dyex' `eydx' `continuous'

	// determine the margins at which to do our calculations
	local grand : length local grand
	if `:length local anything' {
		.hasm = 1
		._parse_margins `anything'
	}
	else {
		local grand 1
	}

	_get_mcompare margins, `mcompare'
	.mc_method	= `"`s(method)'"'
	.mc_all		= `"`s(adjustall)'"'
	.mcompareopt	= `"mcompare(`s(method)' `s(adjustall)')"'

	if `.has_contrast' {
		._parse_contrast_opts, `contrast1'
	}
	if `.has_pwcompare' {
		._parse_pwcompare_opts, `pwcompare1'
	}
	if `grand' {
		local i = `.mlist.arrnels' + 1
		local margi "`.t_marg'`i'"
		.mlist[`i'] = "`margi'"
		.hasAltSpecMarg[`i'] = 0
		matrix `margi' = 1
		matrix colna `margi' = _cons
	}

	if `"`.genstub'"' != "" {
	    if `.has_contrast' {
		di as err "option {bf:generate()} not allowed with contrasts"
			exit 198
	    }
	    if `.has_pwcompare' {
		di as err ///
		"option {bf:generate()} not allowed with pairwise comparisons"
		exit 198
	    }
	}

	if `.hascm' == 0 {
		._check_by_and_at
	}
	else {
		._check_by_and_at_cm
	}
	if `.is_pred' {
		forval i = 1/`._pred.arrnels' {
			._check_exp if `.t_sub' `.wt', `nose' pred(`i')
		}
	}
	else {
		._check_exp if `.t_sub' `.wt', `nose'
	}

	if `"`.xvars'"' == "" {
		if `.noasobs' {
			.title	= "Adjusted predictions"
		}
		else {
			.title	= "Predictive margins"
		}
	}
	else {
		if `.noasobs' {
			.title	= "Conditional marginal effects"
		}
		else {
			.title	= "Average marginal effects"
		}
	}
	if `:length local saving' {
		_prefix_saving `saving'
		.saving		= "`s(filename)'"
		.sav_double	= "`s(double)'"
		.sav_replace	= "`s(replace)'"
	}
	local plot = `"`plot'"' != ""
	if `"`plotopts'"' != "" {
		local plot = 1
	}
	.plot		= `plot'
	.plotopts	= `"`plotopts'"'

	if `.hascm' {
		// do not use 'in 1' for computation
		.use_in1 = 0

		// do not use chain-rule for computing derivatives
		.cr_use = 0
	}
end

program .compute, rclass
	if `.hascm' {
		local outcome outcome(int -1)
		local altidx altidx(int 0)
	}
	if `.is_pred' {
		local xvar xvar(varname)
		local j1 j1(passthru)
		local j2 j2(passthru)
	}
	syntax [if] [in] [fw aw iw pw]	///
		[,	check		///
			GENerate(name)	///
			replace		///
			next		///
			pred(int 1)	///
			`outcome'	///
			`altidx'	///
			`xvar'		///
			`j1'		///
			`j2'		///
		]

	if `.hascm' {
		if `outcome' > -1 {
			local ifxtra "&`.myaltvar'==`outcome'"
		}
		if `altidx' > 0 {
			local altidxopt altidx(`altidx')
		}
	}

	set marginscmd on
	local ln0 0
	local check : length local check
	local next : length local next
	if `next' {
		local next = `.gen'
	}
	tempname t
	local n = `._pred.arrnels'
	if `n' {
		local y `._pred[`pred'].varname'
	}
	else {
		tempname y
		quietly gen double `y' = . in 1
	}
	local gen : length local generate
	if `gen' {
		if !`:length local replace' {
			confirm new var `generate'
		}
	}
	if `.at_b_dim' {
		._repost
	}
	if `.is_xb[`pred']' & ! `.numeric' {
		if `"`j1'"' != "" {
			di as err "internal error in margins;"
			di as err "j1() used with xb"
			error 9999
		}
		if `"`j2'"' != "" {
			di as err "internal error in margins;"
			di as err "j2() used with xb"
			error 9999
		}
		_ms_means b `if' `ifxtra' `in' [`weight'`exp'], ///
			eclass fill0 `._pred[`pred'].eq'
		if r(N) == 0 {
			.return_not_estimable
			return add
			exit
		}
		matrix `t' = r(means)
		return matrix db `t'
		return scalar constant = 0
		if `gen' | `next' | `.offset[`pred']'	///
		 | `.ey' | `.ex' | `.first[`pred']' {
			._pred[`pred'].Predict `if' `in'
			if `.ey' {
				if !`check' {
					capture assert `y' > 0 `if' `in'
					local ln0 = c(rc) != 0
				}
				quietly replace `y' = ln(`y') `in'
				if `check' {
					quietly replace `y' = 0 if missing(`y') `in'
				}
			}
			if `.ex' {
				quietly replace `y' = `.xvar'*`y' `in'
			}
			sum `y' `if' `ifxtra' `in' [`weight'`exp'], mean
			return scalar b = r(mean)
			return scalar N = r(N)
			return scalar sum_w = r(sum_w)
		}
		else {
			matrix `t' = return(db)*e(b)'
			return scalar b = `t'[1,1]
			return scalar N = r(N)
			return scalar sum_w = r(sum_w)
		}
	}
	else if `.is_pred' {
		if `"`j1'`j2'"' != "" {
			if "`weight'" != "" {
				local wgt [iw`exp']
			}
			if `.hascm' {
				if `outcome' > -1 {
					local outopt outcome(`outcome')
				}
			}
			if `"`j2'"' != "" {
				if `.ey' & `.ex' {
					local j2 `j2' eyex(`xvar')
				}
				else if `.ey' {
					local j2 `j2' eydx(`xvar')
				}
				else if `.ex' {
					local j2 `j2' dyex(`xvar')
				}
				else {
					local j2 `j2' dydx(`xvar')
				}
			}
			._pred[`pred'].Predict		///
				`if' `in' `wgt',	///
				`outopt'		///
				`altidxopt'		///
				`j1'			///
				`j2'
		}
		else {
			._pred[`pred'].Predict		///
				`if' `in' `wgt',	///
				`outopt'
		}
		if "`j2'" != "" {
			if !`check' {
				capture assert `y' < . `if' `in'
				local ln0 = c(rc) != 0
			}
			else {
				quietly replace `y' = 0 if missing(`y') `in'
			}
		}
		if `.ey' & "`j2'" == "" {
			if !`check' {
				capture assert `y' > 0 `if' `in'
				local ln0 = c(rc) != 0
			}
			quietly replace `y' = ln(`y') `in'
			if `check' {
				quietly replace `y' = 0 if missing(`y') `in'
			}
		}
		if `.ex' & "`j2'" == "" {

		if !inlist("`altidx'","", "0") {
			tempvar aidx
			sort `.cm_casevar' `.cm_panelvar'
			local by `"quietly by `.cm_casevar' `.cm_panelvar':"'
			`by' ///
			gen `aidx' = sum(cond( ///
			`.myaltvar' == `.altlist[`altidx']', ///
				_n, 0))
			`by' replace `y' = `.xvar'[`aidx'[_N]]*`y'
		}
		else {
			quietly replace `y' = `.xvar'*`y' `in'
		}

		}
		sum `y' `if' `ifxtra' `in' [`weight'`exp'], mean
		if r(N) == 0 {
			.return_not_estimable
			return add
			exit
		}

		return scalar b = r(mean)
		return scalar N = r(N)
		return scalar constant = r(max) == r(min)
		return scalar sum_w = r(sum_w)
	}
	else {
		if `"`j1'"' != "" {
			di as err "internal error in margins;"
			di as err "j1() used with expression()"
			error 9999
		}
		if `"`j2'"' != "" {
			di as err "internal error in margins;"
			di as err "j2() used with expression()"
			error 9999
		}
		forval i = 1/`n' {
			._pred[`i'].Predict `if' `in'
		}
		set expr_revar on
		quietly replace `y' = `.gexp' `if' `in'
		set expr_revar off
		if `.ey' {
			capture assert `y' > 0 `if' `in'
			if c(rc) {
				local ln0 = c(rc) != 0
			}
			quietly replace `y' = ln(`y') `if' `in'
			if `check' {
				quietly replace `y' = 0 if missing(`y') `in'
			}
		}
		if `.ex' {
			quietly replace `y' = `.xvar'*`y' `in'
		}
		sum `y' `if' `in' [`weight'`exp'], mean
		if r(N) == 0 {
			.return_not_estimable
			return add
			exit
		}
		return scalar b = r(mean)
		return scalar N = r(N)
		return scalar constant = r(max) == r(min)
		return scalar sum_w = r(sum_w)
	}
	if `ln0' & !`check' {
		return scalar b = .
	}
	if `.first[`pred']' {
		if `.is_pred' == 1 {
			.plabel[1] = "`:variable label `y''"
		}
		else if `.is_pred' {
			.plabel[`pred'] = "`:variable label `y''"
		}
		.first[`pred'] = 0
	}
	if `next' {
		if `gen' {
			.copyvar `y', next
		}
		else {
			.copyvar `y', next rename
		}
	}
	if `gen' {
		capture drop `generate'
		rename `y' `generate'
	}

end

program .estimate, rclass
	tempname b err nobs

	local EBCOLNA : colf e(b)
	if `.hasby' {
		._make_group
	}
	if `.hascm' == 0 {
		._fill_at
	}
	else {
		._setup_cm
		._fill_at_cm
	}
	._setup_contrast
	._setup_pwcompare

	preserve, changed
	if `.se' {
		tempname J V
	}

	local xvars `.xvars'
	local revar : length local xvars
	if `revar' {
		tempname ehold
		local notfvlist
		local oldname
		local kk 0
		foreach x of local xvars {
			_ms_parse_parts `x'
			if r(type) == "variable" {
				local ++kk
				local xvars`kk' `x'
				if "`r(ts_op)'" != "" {
					local tsopvars `tsopvars' `x'
					local tsbavars `tsbavars' `r(name)'
				}
				local oldname
			}
			else {
				local name `r(ts_op)'.`r(name)'
				if "`name'" != "`oldname'" {
					local ++kk
					local oldname : copy local name
					if "`r(ts_op)'" != "" {
					    local tsopvars `tsopvars' `x'
					    local tsbavars `tsbavars' `r(name)'
					}
				}
				local xvars`kk' `xvars`kk'' `x'
			}
		}
		local k_xterms = `kk'
	}
	else {
		local k_xterms 1
		local xvars _cons
		.altSpecXvar[1] = 0
	}

	local k_mstat	= `._mstat.arrnels'

	forval j = 1/`k_xterms' {
		if `revar' {
			if `j' > 1 {
				_est unhold `ehold'
			}
			_est hold `ehold', copy restore
			local XVARS : copy local xvars`j'
			if `:list XVARS in tsbavars' {
				local XVAR : copy local XVARS
				local XVARS `XVAR' `tsopvars'
			}
			else	local XVAR
			.xovars = "`XVARS'"
			_fv_term_info `XVARS' if `.t_sub' `.wt',	///
				individuals tsrestripe `.fvrestripe'	///
				`.FVTImatopt'
			local k_terms = r(k_terms)
			local xvars
			local k 0
			.dxolist.Arrdropall
			.dxnlist.Arrdropall
			.dxmlist.Arrdropall
			.dxvlist.Arrdropall
			forval i = 1/`k_terms' {
				local dx `.t_dx'_`i'
				if r(type`i') == "variable" {
					gettoken x XVARS : XVARS
					local ++k
					.dxolist[`k'] = "`x'"
					matrix `dx' = r(mean`i')
					local x : colna `dx'
					local xvars `xvars' `x'
					.dxnlist[`k'] = "`x'"
				}
				else {
					matrix `dx' = r(level`i')
					.dxbase[`i'] = "`r(base`i')'"
					.dxhasbase = 1
					local r = rowsof(`dx')
					local x : colna `dx'
					forval kk = 1/`r' {
						gettoken x XVARS : XVARS
						local ++k
						.dxolist[`k'] = "`x'"
						local x : colna `dx'
						local lev = `dx'[`kk',1]
						local x `lev'.`x'
						local xvars `xvars' `x'
						.dxnlist[`k'] = "`x'"
					}
				}
				local x : colna `dx'
				.dxvlist[`i'] = "`x'"
				.dxmlist[`i'] = "`dx'"
			}
			forval i = 1/`k' {
			    if `"`.dxolist[`i']'"' != `"`.dxnlist[`i']'"' {
				set marginsrevars `.dxolist[`i']'
			    }
			}
			if `.restripe' {
				local xtra `"`.xtra_atvars'"'
				local XVARS `"`.xovars'"'
				local orig : list XVARS - xtra
				if `"`orig'"' != "" {
					_fv_term_info `orig',	///
						individuals	///
						tsrestripe
				}
			}
			.xrevars = "`xvars'"
			if `:length local XVAR' {
				local xvars : copy local XVAR
			}
		}
		foreach x of local xvars {
			forval i = 1/`k_mstat' {

	if 0`.altSpecXvar[`j']' == 0 | `._mstat[`i'].altstripe' {

				._mstat[`i'].check_revar
				._mstat[`i'].estimate `x'

				matrix `b' = nullmat(`b'), r(b)
				matrix `err' = nullmat(`err'), r(error)
				matrix `nobs' = nullmat(`nobs'), r(N)
				if `.se' {
					matrix `J' = nullmat(`J') \ r(db)
				}

	}
	else {

			local k_alt `.altlist.arrnels'
			forval a = 1/`k_alt' {
				if `.altsel[`a']' == 0 {
					continue
				}

				._mstat[`i'].check_revar
				._mstat[`i'].estimate `x', ///
				    alternative(`.myaltvar'==`.altlist[`a']')

				matrix `b' = nullmat(`b'), r(b)
				matrix `err' = nullmat(`err'), r(error)
				matrix `nobs' = nullmat(`nobs'), r(N)
				if `.se' {
					matrix `J' = nullmat(`J') \ r(db)
				}
			}

	}

			}
		}
	}
	if `"`.xvars'"' != "" {
		if !`.hasby' & `.mlist.arrnels' == 1 {
			local restripe = `"`:colna `.mlist[1]''"' == "_cons"
			if `restripe' {
				local restripe = `.atlist.arrnels' == 1
			}
			if `restripe' {
				local restripe = rowsof(`.atlist[1]') == 1
			}
			if `restripe' {
				local restripe = !`.is_pred'	///
					| `._pred.arrnels' < 2
			}
			if `restripe' & `.hascm' {
				if `.noutsel' > 1 {
					local restripe 0
				}
				else if `.hasAltSpec' {
					local restripe 0
				}
			}
			if `restripe' {
				local colna : coleq `b'
				matrix coleq `b' = _
				matrix colna `b' = `colna'
			}
		}
	}
	local colna : colful `b'
	matrix coleq `err' = _
	matrix colna `err' = `colna'
	if `.se' {
		matrix roweq `J' = _
		matrix rowna `J' = `colna'
		matrix colna `J' = `EBCOLNA'
		if `.lin' {
			if `.hascm' == 0 {
				._linearize `b' `J' `V'
			}
			else {
				._linearize_cm `b' `J' `V'
			}
		}
		else {
			matrix `V' = `J' * e(V) * `J''
			if `.is_svy' {
				.npop	= e(N_pop)
				.npsu	= e(N_psu)
				.nstr	= e(N_strata)
				.df_r	= e(df_r)
				if !missing(e(N_poststrata)) {
					.npost = e(N_poststrata)
				}
			}
		}
		matrix colna `V' = `colna'
		matrix rowna `V' = `colna'
	}

	._rename4generate `b'
	return add

	// Saved results
	return local title `"`.title'"'
	return scalar N = `.nobs'
	if `"`.subpop'"' != "" {
		return local subpop `"`.subpop'"'
		return scalar N_sub = `.subnobs'
	}
	else if `.subnobs' < `.nobs' {
		return scalar N_sub = `.subnobs'
	}
	return local model_vce	   "`.model_vce'"
	return local model_vcetype "`.model_vcetype'"
	if `.is_pred' {
		.reorder `b' `nobs' `err' `J' `V'
	}
	return matrix _N `nobs'
	return matrix b `b'
	return matrix error `err'
	if `.se' {
		return matrix Jacobian	`J'
		return matrix V		`V'
		return local vce	"`.vce'"
		return local vcetype	"`.vcetype'"
		if "`.clustvar'" != "" {
			return local clustvar "`.clustvar'"
			return scalar N_clust = `.nclust'
		}
		if `.is_svy' {
			return local prefix svy
			if `.npop' {
				return scalar N_pop = `.npop'
			}
			return scalar N_psu = `.npsu'
			return scalar N_strata = `.nstr'
			if `.npost' {
				return scalar N_poststrata = `.npost'
			}
		}
	}
	if `.df_r' {
		return scalar df_r = `.df_r'
	}
	return local margins `"`.margins'"'
	return scalar k_margins = `.k_m'
	return hidden scalar numeric = `.numeric'
	local k_predict = `._pred.arrnels'
	if `.is_pred' {
		if `k_predict' == 1 {
			if `"`.plabel[1]'"' != "" {
				return historical(14) local predict_label ///
					`"`.plabel[1]'"'
				return historical(14) local predict_opts ///
					`"`._pred[1].args'"'
			}
			return local expression `"predict(`._pred[1].args')"'
		}
		else {
			return local expression `"predict()"'
		}
		forval i = 1/`k_predict' {
			return local predict`i'_label	///
				`"`.plabel[`i']'"'
			return local predict`i'_opts	///
				`"`._pred[`i'].args'"'
			return hidden scalar is_xb`i' = `.is_xb[`i']'
			return hidden scalar deriv`i' = `._pred[`i'].deriv'
			return hidden scalar j1_`i' = `._pred[`i'].j1'
			return hidden scalar j2_`i' = `._pred[`i'].j2'
			return hidden scalar outcomeIsEq`i' = `._pred[`i'].outcomeIsEq'
		}
		return scalar k_predict = `k_predict'
	}
	else {
		if `"`.oexp'"' != "" {
			return local expression `"`.oexp'"'
			return hidden local expression_used `"`.gexp'"'
		}
		return scalar k_predict = 0
	}
	if "`.xvars'" != "" {
		return local xvars `"`.xvars'"'
		return local derivatives "`.coefttl'"
		if !`.dxhasbase' {
			return local continuous continuous
		}
	}
	return local by "`.by'"
	return local over "`.over'"
	return local within "`.within'"
	return scalar k_by = `.k_by'
	if `.hasby' {
		forval i = 1/`.k_by' {
			return local by`i' `"`.bylist[`i']'"'
		}
	}
	if `.hasat' | `.has_asbal' {
		._post_atopt
		return add
		if `.hascm' == 0 {
			._post_at
		}
		else {
			._post_at_cm
		}
		return add
	}
	else	return scalar k_at = 0
	return local emptycells "`.empty'"
	if `.cr_use' | `.cr_a' {
		return matrix chainrule `.t_cr'
	}
	if `.hascm' {
		._post_cm_info
		return add
	}
	return hidden local predict	_no_predict
	return local est_cmd		`"`.est_cmd'"'
	return local est_cmdline	`"`.cmdline'"'
	return local cmdline	`"margins `.ZERO'"'
	return local cmd	"margins"
end

program ._post_atopt, rclass
	tempname at atdim
	local k_at = `.atopt.arrnels'
	forval k = 1/`k_at' {
		local slist `"`.atstat[`k']'"'
		return hidden local atspec`k' `"`slist'"'
		local atopt `"`.atopt[`k']'"'
		return hidden local atopt`k' `"`:list retok atopt'"'
	}
end

program ._post_at, rclass
	tempname at atdim
	local k_at = `.atlist.arrnels'
	matrix `atdim' = J(1,`k_at',.)
	local j 0
	forval k = 1/`k_at' {
		matrix `at' = nullmat(`at') \ `.atlist[`k']'
		local slist `"`.atstat[`k']'"'
		local r = rowsof(`.atlist[`k']')/`.k_by'
		matrix `atdim'[1,`k'] = `r'
		forval i = 1/`r' {
			local ++j
			return local atstats`j' `"`slist'"'
		}
	}
	matrix rownames `at' = `rstripe'
	return matrix at `at'
	return scalar k_at = `k_at'
	return hidden matrix atdims `atdim'
end

program ._post_at_cm, rclass
	tempname at atdim
	local k_at = `.cm_atlist.arrnels'
	matrix `atdim' = J(1,`k_at',.)
	local j 0
	forval k = 1/`k_at' {
		matrix `at' = nullmat(`at') \ `.cm_atlist[`k']'
		local slist `"`.cm_atstat[`k']'"'
		local r = rowsof(`.cm_atlist[`k']')/`.k_by'
		matrix `atdim'[1,`k'] = `r'
		forval i = 1/`r' {
			local ++j
			return local atstats`j' `"`slist'"'
		}
	}
	return matrix at `at'
	return scalar k_at = `k_at'
	return hidden matrix atdims `atdim'
end

program ._post_cm_info, rclass
	tempname altvals
	matrix `altvals' = J(1,`.naltsel',.)
	local k_alt = `.altlist.arrnels'
	local j 0
	forval i = 1/`k_alt' {
		if `.altsel[`i']' {
			local ++j
			matrix `altvals'[1,`j'] = `.altlist[`i']'
			if `.naltsel' == 1 {
				local vlbl : label (`.altvar') `.altlist[`i']'
				return hidden local alternative `"`vlbl'"'
			}
		}
		if `.outsel[`i']' {
			if `.noutsel' == 1 {
				local vlbl : label (`.altvar') `.altlist[`i']'
				return hidden local outcome `"`vlbl'"'
			}
		}
		return local alt`i' `"`e(alt`i')'"'
	}
	return scalar k_alt = `k_alt'
	return matrix altvals `altvals'
	return local altvar `"`.altvar'"'
	return hidden local marginsprop "cm"
end

program .reorder
	args b nobs err J V

	local k_pred = `._pred.arrnels'
	if `k_pred' < 2 {
		exit
	}
	local skip 1
	if `.hasby' | `.hasat' {
		local skip 0
	}
	if `.mlist.arrnels' > 1 {
		local skip 0
	}
	else if `.mlist.arrnels' == 1 {
		if `"`:colna `.mlist[1]''"' != "_cons" {
			local skip 0
		}
	}
	if `skip' {
		exit
	}
	mata: st__marg_reorder(	`k_pred',	///
				"`b'",		///
				"`nobs'",	///
				"`err'",	///
				"`J'",		///
				"`V'")
end

program ._parse_cmopts, sclass
	syntax [, ALTernatives(string asis) OUTcomes(string asis) *]
	sreturn local options `"`options'"'

	// CM information required to be in -e()-
	if `"`e(case)'"' == "" {
		di as err "case variable not found;"
		di as err "{p 0 0 2}"
		di as err "the current estimation results do not identify"
		di as err "the case variable in a way that"
		di as err "{cmd:margins} understands"
		di as err "{p_end}"
		exit 301
	}
	if `"`e(altvar)'"' == "" {
		di as err "alternative variable not found;"
		di as err "{p 0 0 2}"
		di as err "the current estimation results do not identify"
		di as err "the alternative variable in a way that"
		di as err "{cmd:margins} understands"
		di as err "{p_end}"
		exit 301
	}

	confirm variable `e(case)'
	.cm_casevar = "`e(case)'"

        if `"`e(panelid)'"' != "" {
	        confirm variable `e(panelid)'
	        .cm_panelvar = "`e(panelid)'"
        }
	confirm variable `e(altvar)'
	.altvar = "`e(altvar)'"
	.myaltvar = "`e(altvar)'"

	local alttype : type `.altvar'
	tempname altvals
	if substr(`"`alttype'"',1,3) == "str" {
		.myaltvar = "`.t_name'_altvar"
		gen byte `.myaltvar' = 0
		local k_alt = e(k_alt)
		matrix `altvals' = J(1,`k_alt',.)
		label define `.myaltvar' 0 ""
		forval i = 1/`k_alt' {
			quietly ///
			replace `.myaltvar' = `i' ///
				if `.altvar' == `"`e(alt`i')'"'
			matrix `altvals'[1,`i'] = `i'
			local colna `"`colna' `"`e(alt`i')'"'"'
			label define `.myaltvar' `i' `"`e(alt`i')'"', add
		}
		label values `.myaltvar' `.myaltvar'
		matrix colna `altvals' = `colna'
	}
	else if "`e(altvals)'" == "matrix" {
		matrix `altvals' = e(altvals)
	}
	else {
		di as err "alternative level value information not found"
		exit 301
	}
	local altvar `"`.myaltvar'"'

	if `"`e(casevars)'"' != "" {
		fvrevar `e(casevars)', list
		local vlist `"`r(varlist)'"'
		.casevars = "`:list uniq vlist'"
	}

	local alternatives : list retok alternatives
	local len : length local alternatives
	if substr(`"simultaneous"',1,max(3,`len')) == `"`alternatives'"' {
		local alternatives
	}
	else {
		.alt_seq = 1
	}
	local 0 : copy local alternatives
	capture syntax [anything(everything name=alternatives)]	[, NULLOP]
	if c(rc) {
		di as err "option {bf:alternatives()} incorrectly specified"
		exit 198
	}
	local alternatives : list uniq alternatives
	local allalternatives 0
	if `:list posof "_all" in alternatives' {
		local ALL  "_all"
		local alternatives : list alternatives - ALL
		local allalternatives 1
	}
	if `:list posof "*" in alternatives' {
		local STAR "*"
		local alternatives : list alternatives - STAR
		local allalternatives 1
	}
	local 0 : copy local outcomes
	capture syntax [anything(everything name=outcomes)] [, ALTSUBpop]
	if c(rc) {
		di as err "option {bf:outcomes()} incorrectly specified"
		exit 198
	}
	local outcomes : list uniq outcomes
	local alloutcomes 0
	if `:list posof "_all" in outcomes' {
		local ALL  "_all"
		local outcomes : list outcomes - ALL
		local alloutcomes 1
	}
	if `:list posof "*" in outcomes' {
		local STAR "*"
		local outcomes : list outcomes - STAR
		local alloutcomes 1
	}

	// Input:
	// 	altvar		-- macro, copy of .myaltvar
	// 	altvals		-- local macro, matrix name
	//	alternatives	-- local macro, from option
	//	outcomes	-- local macro, from option
	// Output: (all local macros)
	// 	k		-- number of alt values
	//	altval#		-- #th alt value
	//	altsel#		-- indicates if #th alt value was selected
	//	outsel#		-- indicates if #th alt value was selected
	mata: st_marg4cm_search_alt()
	local naltsel 0
	local noutsel 0
	forval i = 1/`k' {
		.altlist[`i'] = `altval`i''
		.altsel[`i'] = `altsel`i''
		.outsel[`i'] = `outsel`i''
		if `altsel`i'' {
			local ++naltsel
		}
		if `outsel`i'' {
			local ++noutsel
		}
	}
	.naltsel = `naltsel'
	.noutsel = `noutsel'
	.outcontrast = `"`outcomes'"'
	if "`altsubpop'" != "" {
		.cm_rescale = 0
	}
end

program ._parse_post_required
	syntax [,	COEFLegend		///
			SELEGEND		///
			*			///
	]
	local LEGEND `coeflegend' `selegend'
	if "`LEGEND'" != "" {
		di as err ///
		"option {bf:`LEGEND'} not allowed without {bf:post} option"
		exit 198
	}
end

program ._parse_eq_opt, rclass
	syntax [, EQuation(string asis)]

	if `:length local equation' {
		gettoken eq1 rest : equation, parse(",")
		return local eq1 `"eq(`eq1')"'
		if `:length local reest' {
			gettoken comma eq2 : equation, parse(",")
			return local eq2 `"eq(`eq2')"'
		}
	}
	else {
		return local eq1 "eq(#1)"
	}
end

program .return_not_estimable, rclass
	tempname t
	quietly gen `t' = 0
	.copyvar `t', next rename
	return scalar b = 0
	matrix `t' = 0*e(b)
	return matrix db `t'
	return scalar not_estimable = 1
	return scalar N = e(N)
	return scalar sum_w = 1
end

program ._check_est, rclass
	if `"`.check_est_u'"' == "" {
		._check_est_u `0'
		return add
		exit
	}
	syntax [if] [in] [fw aw iw pw] [, mult(passthru) pred(int 0)]

	local pmax = `._pred.arrnels'
	if `pmax' == 0 {
		return scalar not_estimable = 0
		exit
	}

	if `pred' != 0 {
		local pmin = `pred'
		local pmax = `pred'
	}
	else	local pmin = 1

	forval i = `pmin'/`pmax' {
		`.check_est_u' `if' `in' [`weight'`exp'],	///
			`mult'					///
			tol(`.est_tol')				///
			`._pred[`i'].eq'			///
			`._pred[`i'].opts'
		if r(not_estimable) != 0 {
			.return_not_estimable
			return add
			exit
		}
	}
	return scalar not_estimable = 0
end

program ._check_est_u, rclass
	syntax [if] [in] [fw aw iw pw] [, mult(name) pred(int 0)]

	local pmax = `._pred.arrnels'
	if `pmax' == 0 {
		return scalar not_estimable = 0
		exit
	}

	if `pred' != 0 {
		local pmin = `pred'
		local pmax = `pred'
	}
	else	local pmin = 1

	tempname L LH

	local margprop `"`e(marginsprop)'"'
	local addcons : list posof "addcons" in margprop

	_ms_lf_info
	local keq = r(k_lf)
	forval j = 1/`keq' {
		local eqspec`j' "`r(lf`j')'"
		local eqopt`j' "eq(`r(lf`j')')"
		local eqk`j' = r(k`j')
		local cons`j' = r(cons`j')
	}
	forval j = 1/`keq' {
		capture _msparse `eqspec`j''
		if !c(rc) & r(omit) == 1 {
			local eqomitlist `"`eqomitlist' eq(#`j') `eqopt`j''"'
		}
	}

	local opts	eclass		///
			fill0		///
			ignoreomit	///
			allownotfound
	forval i = `pmin'/`pmax' {
		._parse_eq_opt, `._pred[`i'].eq'
		local eq1 `"`r(eq1)'"'
		local eq2 `"`r(eq2)'"'
		if `:list eq1 in eqomitlist' & `:list eq2 in eqomitlist' {
			continue
		}
		else if `:list eq1 in eqomitlist' {
			local eq1 : copy local eq2
			local eq2
		}
		else if `:list eq2 in eqomitlist' {
			local eq2
		}
		_ms_means b `if' `in' [`weight'`exp'], `opts' `eq1'
		matrix `L' = r(means)
		if `"`eq2'"' != "" {
			_ms_means b `if' `in' [`weight'`exp'], `opts' `eq2'
			matrix `L' = `L' + r(means)
		}
		if `:length local mult' {
mata:			st_matrix("`L'", st_matrix("`L'"):*st_matrix("`mult'"))
		}
		if `addcons' {
			if `keq' == 1 & `cons1' == 0 {
				matrix `L' = `L', 1
			}
			else {
				tempname hold
				matrix rename `L' `hold'
				local i0 0
				forval j = 1/`keq' {
				    local i1 = `i0' + `eqk`j''
				    local ++i0
				    matrix `L' = nullmat(`L'), ///
						`hold'[1,`i0'..`i1']

	if `cons`j'' == 0 {
		if inlist("eq(#`j')", "`eq1'", "`eq2'") {
			matrix `L' = `L', 1
		}
		else if inlist("`eqspec`j''", "`eq1'", "`eq2'") {
			matrix `L' = `L', 1
		}
		else if inlist("eq(`eqspec`j'')", "`eq1'", "`eq2'") {
			matrix `L' = `L', 1
		}
		else {
			matrix `L' = `L', 0
		}
	}

				    local i0 = `i1'
				}
			}
		}
		matrix `LH' = `L'*`.t_H'
		if mreldif(`L', `LH')  > `.est_tol' {
			.return_not_estimable
			return add
			exit
		}
	}
	return scalar not_estimable = 0
end

program .est1
	if `.hascm' {
		local outcome outcome(passthru)
	}
	syntax [if] [in] [, mult(passthru) pred(int 1)] `outcome'

	if `.est_chk' {
		._check_est `if' `in' `.wt', `mult' pred(`pred')
		if r(not_estimable) {
			exit
		}
	}

	if "`.nose'" != "" {
		.compute `if' `in' `.wt', pred(`pred') `outcome'
	}
	else if `.is_xb[`pred']' & !`.numeric' {
		.compute `if' `in' `.wt', next pred(`pred') `outcome'
	}
	else {
		local cr_use = `.cr_use'
		if `cr_use' {
			if `.cr_cons' == 0 {
				_ms_chainrule b `if' `in', eclass
				if r(any) == 0 {
					local cr_use = 0
				}
				else {
					tempname crhold
					matrix `crhold' = `.t_cr'
					matrix `.t_cr' = r(chainrule)
				}
			}
		}
		local deriv 0
		local j1 0
		if `.is_pred' & `.numeric' == 0 {
			local deriv = `._pred[`pred'].deriv'
			local j1 = `._pred[`pred'].j1'
		}
		if `j1' {
			._est1_db_j `if' `in' `.wt', pred(`pred') `outcome'
		}
		else if `deriv' {
			.cr_a = 1
			._est1_db_cr_a `if' `in' `.wt', pred(`pred') `outcome'
		}
		else if `cr_use' {
			capture drop `._pred[`pred'].varname'
			._est1_db_cr_n `if' `in' `.wt', pred(`pred') `outcome'
		}
		else {
			._est1_db `if' `in' `.wt', pred(`pred') `outcome'
		}
		if `"`crhold'"' != "" {
			matrix drop `.t_cr'
			matrix rename `crhold' `.t_cr'
		}
		if r(N) == 0 {
			.return_not_estimable
			exit
		}
	}
end

program .est2
	if `.hascm' {
		local outcome outcome(passthru)
		local alternative alternative(passthru)
		local altidx altidx(passthru)
	}
	syntax [if] [in], xvar(string) `outcome' ///
		[mult(passthru) pred(passthru) `alternative' `altidx']

	fvrevar `xvar', list
	set marginsdxvars `r(varlist)'
	_ms_parse_parts `xvar'
	if r(type) == "variable" {
		._est2_c `if' `in', xvar(`xvar') `mult' `pred' ///
			`outcome' `alternative' `altidx'
	}
	else {
		._est2_d `if' `in', xvar(`xvar') `mult' `pred' ///
			`outcome' `alternative'
	}
end

program .get_dx_base, rclass
	syntax varname

	local i = `.dxvlist.arrindexof "`varlist'"'
	if `i' == 0 {
		di as err "`varlist' not found in list of indepvars"
		error 198
	}
	return scalar base = `.dxmlist[`i']'[`.dxbase[`i']',1]
end

program .estimate_and_report, rclass
	tempname b ehold
	.estimate
	matrix `b' = r(b)
	if "`r(V)'" == "matrix" {
		tempname V
		matrix `V' = r(V)
	}
	if !`.post' {
		_est hold `ehold'
	}

break {
capture noisily break {

	._post `b' `V'
	if `"`.saving'"' != "" {
		if !`.post' {
			local mypost post
		}
	}
	if `.has_contrast' {
		contrast `.contrast',	`.diopts'		///
					`.commonopts'		///
					`.contrastopts'		///
					`.mcompareopt'		///
					`.atlegend' `mypost'
		return add
	}
	else if `.has_pwcompare' {
		pwcompare `.pwcompare',	`.diopts'		///
					`.commonopts'		///
					`.pwcompareopts'	///
					`.mcompareopt'		///
					`.atlegend' `mypost'
		return add
	}
	else {
		return add
		if `.dxhasbase' {
			return local b
			matrix `b' = e(b)
			return matrix b `b'
			if "`r(V)"'" == "matrix" {
				return local V
				matrix `V' = e(V)
				return matrix V `V'
			}
		}
		_marg_report,	`.diopts'		///
				`.commonopts'		///
				`.mcompareopt'		///
				`.atlegend'
		return add
	}
	return hidden local u_at_vars `"`.uatvars'"'
	._post_dims
	return hidden local marg_dims `"`e(marg_dims)'"'
	if `"`.saving'"' != "" {
		version `.vv' :				///
		_marg_save,	saving(`"`.saving'"',	///
					`.sav_double'	///
					`.sav_replace')	///
				level(`.level')		///
				eclass
	}

	if `.plot' {
		marginsplot, `.plotopts'
	}

} // capture noisily break
	local rc = c(rc)

	if !`.post' {
		_est unhold `ehold'
	}

} // break
	exit `rc'
end

program ._repost, eclass
	tempname b
	matrix `b' = `.t_altb'[1,1..`.at_b_dim']
	matrix `b'[1,1] = e(b)
	ereturn repost b=`b', rename
end

program ._post, eclass
	args b V

nobreak {

	set emptycells keep	// original setting auto restored

capture noisily break {

	ereturn post `b' `V' `.wt',			///
				esample(`.t_sub')	///
				findomitted		///
				buildfvinfo		///
				noHmat

	if `"`.subpop'"' != "" {
		ereturn repost, esample(`.t_touse')
	}

	if `.hascm' {
		if `"`.altvar'"' == "`.myaltvar'" {
			local vl : value label `.altvar'
			if `"`vl'"' != "" & `.noutsel' > 1 {
				capture label copy `vl' _outcome, eclass
			}
		}
		else {
			capture label copy `.myaltvar' _outcome, eclass
			capture label copy `.myaltvar' `.altvar', eclass
		}
	}

} // capture noisily break
	local rc = c(rc)

} // nobreak
	if `rc' exit `rc'

	if `"`.footnote'"' != "" {
		ereturn hidden local footnote `"`.footnote'"'
	}

	_r2e, noclear xmacros(cmd)
	ereturn hidden local u_at_vars `"`.uatvars'"'
	ereturn local cmd	"margins"
end

program .ExtraDflt1, sclass
	syntax [, xb(passthru) EQuation(passthru) OUTcome(string asis) *]

	local extra _predict
	if `"`xb'"' != "" {
		local extra `extra' _xb
	}
	if `"`equation'"' != "" {
		local extra `extra' _equation
	}
	if `"`outcome'"' != "" {
		local extra `extra' _outcome
		gettoken dvar dval : outcome
		capture confirm name `dvar'
		if c(rc) == 0 {
			capture confirm integer number `dval'
			if c(rc) == 0 {
				local extra `extra' _equation
			}
		}
	}
	sreturn local extra `"`extra'"'
end

program .ExtraDflt, sclass
	args c_extra

	local 0 `", `.margdflt'"'
	syntax [, predict(string asis) *]
	.ExtraDflt1, `predict'
	local extra `"`s(extra)'"'
	local 0 `", `options'"'
	syntax [, predict(string asis) *]
	while `"`predict'"' != "" {
		.ExtraDflt1, `predict'
		if `"`extra'"' != `"`s(extra)'"' {
			exit
		}
		local 0 `", `options'"'
		syntax [, predict(string asis) *]
	}
	local extra : subinstr local extra "_xb" "_equation"
	local extra : list uniq extra
	c_local `c_extra' `"`extra'"'
end

program ._post_dims, eclass

	if `"`e(xvars)'"' != "" {
		local extra _deriv
	}

	// mlist -- build the list of margin variables
	if `"`e(margins)'"' != "" {
		_fv_term_info `e(margins)', noc
		local k = r(k_terms)
	}
	else	local k 0
	if `k' > 1 {
		local extra `extra' _term
	}
	forval i = 1/`k' {
		local colna : colna r(level`i')
		local mlist : list mlist | colna
	}
	local mlist : list uniq mlist
	local _CONS _cons
	local mlist : list mlist - _CONS

	// atlist -- build the list of at() variables
	tempname at_skip
	mata: st__marg_dims_check_at()
	if `has_at' {
		local atcolna : colna e(at)
		local extra `extra' _atopt
	}
	local i 0
	foreach at of local atcolna {
		local ++i
		if `at_skip'[1,`i'] {
			continue
		}
		_ms_parse_parts `at'
		local hasrcp = "`r(ts_op)'" != ""
		if `hasrcp' {
			local name at(`r(ts_op)'.`r(name)')
		}
		else {
			local name at(`r(name)')
		}
		if !`:list name in atlist' {
			local atlist `atlist' `name'
		}
	}

	// bylist -- build the list of by variables
	if `"`e(by)'"' != "" {
		local bylist `"`e(by)'"'
	}
	if `._pred.arrnels' > 1 {
		if `"`.margdflt'"' != "" {
			ExtraDflt extra_dflt
		}
		else {
			local extra_dflt _predict
		}
	}

	if `.has_pwcompare' {
		local dims _pw0 _pw1 _pw `extra' `extra_dflt'
	}
	else {
		local dims `mlist' `atlist' `bylist' `extra' `extra_dflt'
	}
	local dims : list retok dims
	ereturn hidden local marg_dims `"`dims'"'
end

// subroutines for .parse ---------------------------------------------------

program ._parse_predict, rclass
	syntax [, PRedict(string asis) *]

	.is_pred = 2
	local i 0
	while `"`predict'"' != "" | `i' == 0 {
		forval j = 1/`i' {
			._pred[`j'].match, `predict'
			if r(match) == 1 {
				di as err "redundant {bf:predict()} option;"
				di as err ///
"more than one {bf:predict} option produces the same prediction"
				exit 198
			}
		}
		local ++i
		version `.vv' : ._pred[`i'] = ._marg_predict.new
		._pred[`i'].parse, `predict'
		.first[`i'] = 1

		local 0 `", `options'"'
		syntax [, PRedict(string asis) *]
	}
	return local options `"`options'"'
end

program ._parse_atvarsopt
	syntax [varlist(numeric default=none)]

	local covar `"`e(covariates)'"'
	local varlist : list uniq varlist
	local dim : list sizeof varlist
	if `dim' == 0 {
		exit
	}
	else if `: list sizeof covar' == 0 {
		local covar `"`e(atvars_nochainrule)'"'
		if `: list sizeof covar' == 0 {
			exit
		}
	}

	_ms_lf_info, `.matopt'
	local k_eq = r(k_lf)

	foreach var of local varlist {
		local spec
		forval i = 1/`k_eq' {
			capture	_ms_extract_varlist `var', `.matopt' eq(#`i')
			if c(rc) == 0 {
				local spec `"`spec' `r(varlist)'"'
			}
			capture	_ms_extract_varlist i.`var', `.matopt' eq(#`i')
			if c(rc) == 0 {
				local spec `"`spec' `r(varlist)'"'
			}
		}
		if `"`spec'"' == "" {
			local spec : copy local var
		}
		else {
			local spec : list uniq spec
		}
		local speclist `speclist' `spec'
	}
	local speclist : list uniq speclist
	local dim : list sizeof speclist

	tempname b
	matrix `b' = J(1,`dim',0)
	matrix coleq `b' = _atvarsopt
	matrix colna `b' = `speclist'
	if "`covar'" == "_NONE" {
		capture matrix drop `.t_altb'
	}
	if `"`.t_altb'"' == "" {
		.t_altb	= "`.t_name'_altb"
		matrix `.t_altb' = e(b)
		.at_b_dim = `= colsof(`.t_altb')'
		c_local nochainrule nochainrule
	}
	else {
		.restripe = 1
	}
	matrix `.t_altb' = nullmat(`.t_altb'), `b'
	.atvarsopt	= `"`varlist'"'
	.xtra_atvars	= `"`speclist'"'
	.matopt		= `"matrix(`.t_altb')"'
	.FVTImatopt	= `"matrix(`.t_altb')"'
end

program ._check_at_for_alt
	args var stat
	_ms_parse_parts `var'
	if `"`r(name)'"' != `"`.altvar'"' {
		exit
	}
	local atopt "option {bf:at()}"
	if `.atmean' & `"`stat'"' == "mean" {
		di as err "option {bf:atmeans} not allowed;"
	}
	else {
		di as err "`atopt' invalid;"
	}
	di as err ///
	"alternative variable {bf:`.altvar'} is not allowed" ///
	" to be changed by `atopt'"
	exit 198
end

program ._parse_at
	syntax [, asbalanced at(string) *]

	if `:length local asbalanced' {
		local fprefix (asbalanced) _factor
		local cprefix (mean)
	}
	else if `.atmean' {
		local fprefix (mean) _factor
	}
	if `.atmean' {
		local cprefix (mean) _continuous
	}

	if `.force' {
		local force force
	}

	local matopt `"`.matopt'"'

	_ms_at_parse `fprefix' `cprefix' `at', ///
		asobserved `matopt' `force'
	if "`r(at)'" == "" {
		if "`at'" != "" {
			di as err "model contains no indepvars"
			exit 322
		}
		local k 1
		local mat `.t_at'`k'
		matrix `mat' = J(1,1,1)
		matrix colna `mat' = _cons
		local atstat "asobserved"
	}
	else {
		local uatvars `"`r(atvars)'"'
		local uatvars : list uniq uatvars
		local k 1
		local mat `.t_at'`k'
		matrix `mat' = r(at)
		local atstat `"`r(statlist)'"'
	}
	.atlist[`k'] = "`mat'"
	.atstat[`k'] = `"`atstat'"'
	.atopt[`k'] = `"`fprefix' `cprefix' `at'"'
	._asbal[`k'] = strmatch("`r(statlist)'", "asbalanced")

	local 0 `", `options'"'
	syntax [, at(string) *]
	while `:length local at' {
		_ms_at_parse `fprefix' `cprefix' `at', ///
			asobserved `matopt' `force'
		local uatvars `"`uatvars' `r(atvars)'"'
		local uatvars : list uniq uatvars
		local ++k
		local mat `.t_at'`k'
		matrix `mat' = r(at)
		.atlist[`k'] = "`mat'"
		.atstat[`k'] = `"`r(statlist)'"'
		.atopt[`k'] = `"`fprefix' `cprefix' `at'"'
		._asbal[`k'] = strmatch("`r(statlist)'", "asbalanced")
		local 0 `", `options'"'
		syntax [, at(string) *]
	}

	if "`.t_altb'" != "" {
		local K = `._asbal.arrnels'
		forval k = 1/`K' {
			if `._asbal[`k']' {
				di as err ///
`"option {bf:asbalanced} not allowed with {bf:`.ecmd'} estimation results"'
				exit 322
			}
		}
	}
	.uatvars = `"`uatvars'"'

	if `.hascm' {
		local casevars `.casevars'
		local atvars : colna `.atlist[1]'
		local atdim : list sizeof atvars
		local has_alt_in_at 0
		forval j = 1/`atdim' {
			gettoken var atvars : atvars
			_ms_parse_parts `var'
			if `:list posof "`r(name)'" in casevars' {
				.altSpecAtvar[`j'] = 0
			}
			else {
				.altSpecAtvar[`j'] = `.alt_seq'
			}
			if `"`r(name)'"' == `"`.altvar'"' {
				local has_alt_in_at 1
			}
		}
		local k `.atlist.arrnels'
		forval i = 1/`k' {
			local atvars : colna `.atlist[1]'
			local atstat `.atstat[`i']'
			.hasAltSpecAt[`i'] = 0
			forval j = 1/`atdim' {
				gettoken var  atvars : atvars
				gettoken stat atstat : atstat, bind
				if `"`stat'"' != "asobserved" {
					if `has_alt_in_at' {
						._check_at_for_alt `var' `stat'
					}
					if `.altSpecAtvar[`j']' {
						.hasAltSpecAt[`i'] = 1
						if `has_alt_in_at' == 0 {
							continue, break
						}
					}
				}
			}
		}
	}

	syntax [, NULLOP]
end

program	._parse_by
	syntax [,	by(string)	///
			over(string)	///
			within(string)	///
	]

	local spec `by' `over' `within'

	local over `by' `over'
	.ocontrast = `"`over'"'
	_strip_contrast `over', notsops nointeractions opt(over)
	if r(contrast) {
		.has_contrast = 1
		.has_ocontrast = 1
	}
	local varlist `"`r(varlist)'"'
	local k : list sizeof varlist
	if `k' > c(max_it_fvars) {
		di as err "invalid over() option;"
		di as err "too many terms in interaction"
		exit 103
	}
	local over
	foreach var of local varlist {
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1, .)
		}
		local over `over' `var'
	}

	.wcontrast = `"`within'"'
	_strip_contrast `within', notsops nointeractions opt(within)
	if r(contrast) {
		.has_contrast = 1
		.has_wcontrast = 1
	}
	local varlist `"`r(varlist)'"'
	local within
	foreach var of local varlist {
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1,.)
		}
		local within `within' `var'
	}

	// parse the combined specification, just in case there is a conflict
	_strip_contrast `.ocontrast' `.wcontrast'

	local by `over' `within'
	local by : list uniq by
	local within : list uniq within
	local over : list by - within
	.over	= "`over'"
	.within	= "`within'"
	.by	= "`by'"
	if `:length local within' {
		_ms_check_varlist i.(`within')
		if "`.empty'" == "" {
			.empty = "reweight"
		}
	}
	.hasby	= "`by'" != ""
end

program ._parse_emptycells
	capture syntax [, REWeight strict]
	if c(rc) {
		di as err "option {bf:emptycells()} invalid"
		exit 198
	}
	local empty `reweight' `strict'
	opts_exclusive "`empty'"
	.empty = "`empty'"
end

program ._parse_vce
	_vce_parse, opt(delta svy UNCONDitional): `0'
	local vce "`r(vce)'"
	if "`vce'" == "svy" {
		if `"`e(prefix)'"' != "svy" {
			di as err ///
"option {bf:vce(svy)} is allowed only with survey estimation results"
			exit 322
		}
		local vce unconditional
	}
	.model_vce = "`e(vce)'"
	.model_vcetype = "`e(vcetype)'"
	if `"`.model_vcetype'"' == "HAC" {
		.model_vcetype = "`e(vcetype)' `e(hac_kernel)' `e(hac_lag)'"
	}
	.is_svy = "`e(prefix)'" == "svy"
	if "`vce'" == "unconditional" {
		if `.is_svy' {
			.model_vce = "svy"
		}
		if "`.model_vce'" == "svy" {
			if `"`.wtype'"' != "" {
				di as err ///
"weights not allowed with survey estimation results"
				exit 101
			}
			quietly svyset
			if `"`r(settings)'"' == ", clear" {
				di as err ///
"data not set up for {bf:svy}, use {helpb svyset##|_new:svyset}"
				exit 459
			}
			if "`r(vce)'" != "linearized" {
				di as err "{bf:vce(`r(vce)')} is not supported"
				error 459
			}
			if "`e(vce)'" != "linearized" {
				di as err "{p}" ///
"option {bf:vce(unconditional)} is allowed only after estimation with "	///
"linearized standard errors{p_end}"
				exit 322
			}
			.posts		= "`r(poststrata)'"
			.postw		= "`r(postweight)'"
			.calmethod	= "`r(calmethod)'"
			.calmodel	= "`r(calmodel)'"
			.calopts	= "`r(calopts)'"
			.wtype		= "`r(wtype)'"
			.wexp		= "`r(wexp)'"
		}
		else if "`.model_vce'" == "cluster" {
			.clustvar = "`e(clustvar)'"
			.clopt = "cluster(`e(clustvar)')"
		}
		else if "`.model_vce'" == "robust" {
			if "`e(clustvar)'" != "" {
				.clustvar = "`e(clustvar)'"
			}
			else if "`e(group)'" != "" {
				.clustvar = "`e(group)'"
			}
			else if `.hascm' {
				.clustvar = "`.cm_casevar'"
			}
			if "`.clustvar'" != "" {
				.clopt = "cluster(`.clustvar')"
			}
		}
		else {
			di as err "{p}" ///
"option {bf:vce(unconditional)} is allowed only after estimation with "	///
"robust, semirobust, or linearized standard errors{p_end}"
			exit 322
		}
	}
	else {
		local vce delta
		if `.is_svy' {
			.posts		= "`e(poststrata)'"
			.postw		= "`e(postweight)'"
			.calmethod	= "`e(calmethod)'"
			.calmodel	= "`e(calmodel)'"
			.calopts	= "`e(calopts)'"
		}
	}
	.vce = "`vce'"
	if "`.model_vce'" == "svy" {
		.vcetype = "Linearized"
		.lin = 1
	}
	else if inlist("`vce'", "unconditional") {
		.vcetype = "Unconditional"
		.lin = 1
	}
	else {
		.vcetype = "Delta-method"
	}
	if `.lin' {
		._check_vce_not_supported "`e(cmd)'" "`e(cmd2)'"
		.gen = 1
		.use_in1 = 0
	}
end

program ._check_vce_not_supported
	// NOTE:  If your estimation command does not support
	// -margins, vce(unconditional)-, then it should put
	// "nolinearize" in macro -e(marginsprop)-.
	// Do not put your command in cmdlist.

	local cmdlist areg ivreg xtgee xtreg ivregress
	local cmd : list 0 & cmdlist
	gettoken cmd : cmd
	local err : length local cmd
	if `err' == 0 {
		local margprop `"`e(marginsprop)'"'
		if `:list posof "nolinearize" in margprop' {
			local err 1
			local cmd = e(cmd)
		}
	}
	if `err' {
		di as err ///
`"{bf:`cmd'} is not supported by margins with the "' ///
`"{bf:vce(unconditional)} option"'
		exit 322
	}
end

program ._check_esample
	quietly count if e(sample)
	if r(N) == 0 {
		di as err ///
		"{bf:e(sample)} does not identify the estimation sample"
		exit 322
	}
	.nobs = r(N)
	if "`.vce'" == "unconditional" {
		if inlist("`.wtype'", "", "aweight", "pweight") {
			if `.nobs' != e(N) {
				local msg0 ///
"unconditional standard errors derived assuming full estimation sample;"
				local msg1 ///
"{bf:e(sample)} does not identify the same number of observations as {bf:e(N)}"
				if `.force' {
					di as txt `"{p 0 7}(note: "' _c
					di as txt `"`msg0'{break}"' _c
					di as txt `"`msg1'){p_end}"'
				}
				else {
					di as err `"{p}`msg0'{break}"' _c
					di as err `"`msg1'{p_end}"'
					exit 459
				}
			}
		}
	}
end

program ._check_fweight
	if "`.vce'" == "unconditional" {
		sum `.t_touse' [fweight`.wexp'] if e(sample), mean
		if r(sum_w) != e(N) {
			local msg0 ///
"unconditional standard errors derived assuming full estimation sample;"
			local msg1 ///
"{bf:fweight}s do not sum to the number of observations posted in {bf:e(N)}"
			if `.force' {
				di as txt `"{p 0 7}(note: "' _c
				di as txt `"`msg0'{break}"' _c
				di as txt `"`msg1'){p_end}"'
			}
			else {
				di as err `"{p}`msg0'{break}"' _c
				di as err `"`msg1'{p_end}"'
				exit 459
			}
		}
	}
end

program ._check_touse
	if `.esample' & "`.vce'" == "unconditional" {
		local msg0 ///
"unconditional standard errors derived assuming full estimation sample;"
		local msg1 ///
`"`0' dropped observations from the estimation sample"'
		quietly count if `.t_touse'
		if `.nobs' != r(N) {
			if `.force' {
				.nobs = r(N)
				di as txt `"{p 0 7}(note: "' _c
				di as txt `"`msg0'{break}`msg1'){p_end}"'
				exit
			}
			di as err `"{p}`msg0'{break}"' `"`msg1'{p_end}"'
			exit 459
		}
	}
end

program ._check_svy_char
	assert `"`r(`0')'"' == `"`e(`0')'"'
end

program ._check_svyset
	quietly svyset
	capture {
		._check_svy_char stages
		if r(stages_wt) == 0 {
			._check_svy_char wtype
			._check_svy_char wexp
		}
		._check_svy_char poststrata
		._check_svy_char postweight
		._check_svy_char calmethod
		._check_svy_char calmodel
		._check_svy_char calopts
		._check_svy_char singleunit
		local k = e(stages)
		forval i = 1/`k' {
			._check_svy_char su`i'
			._check_svy_char fpc`i'
			._check_svy_char strata`i'
			._check_svy_char weight`i'
		}
	}
	if c(rc) {
		local msg ///
"{bf:svyset} characteristics disagree with the {bf:svy} estimation results"
		if `.force' {
			di as txt "{p 0 7}(note: `msg'){p_end}"
			exit
		}
		di as err "`msg'"
		exit 322
	}
end

program ._parse_expression
	version 11
	if `.hascm' {
		di as err "{p 0 0 2}"
		di as err "option {bf:expression()} not allowed with "
		di as err "estimation results from `e(cmd)'"
		di as err "{p_end}"
		exit 322
	}
	local exp : copy local 0
	local i 0
	local oexp : list retokenize exp
	if !`:length local exp' {
		local exp "predict()"
	}
	while `:length local exp' {
		version `.vv' : mata: _st_marg_exp_token("check", "exp")
		if `"`check'"' != "predict" & `"`check'"' != "xb" {
			local gexp `"`gexp'`check'"'
			continue
		}
		gettoken paren : exp, parse(" (")
		if `"`paren'"' != "(" {             /* False alarm */
			local gexp `"`gexp'`check'"'
			continue
		}
		local match 0
		gettoken args exp : exp, match(par)
		forval j = 1/`i' {
			._pred[`j'].match, `args'
			if r(match) == 1 {
				local gexp `"`gexp'`._pred[`j'].varname'"'
				local match 1
				continue, break
			}
		}
		if `match' {
			continue
		}
		local ++i
		version `.vv' : ._pred[`i'] = ._marg_predict.new
		if `"`check'"' == "xb" {
			local args : subinstr local args " " "", all
			local term `"xb(`args')"'
			if `:length local args' {
				local eqopt eq(`args')
			}
			else	local eqopt
			._pred[`i'].parse, xb `eqopt'
		}
		else {                     /* check == "predict" */
			local term `"predict(`args')"'
			._pred[`i'].parse, `args'
		}
		local gexp `"`gexp'`._pred[`i'].varname'"'
	}
	if `._pred.arrnels' == 0 {
		di as txt ///
"{p 0 0 2}Warning: expression() does not contain predict() or xb().{p_end}"
	}
	.oexp = `"`oexp'"'
	.gexp = `"`gexp'"'

	if `._pred.arrnels' == 1 & `"`.gexp'"' == "`._pred[1].varname'" {
		.is_pred = 1
	}
	.numeric = 1
end

program ._check_predict_markout
	version 11

	if !`.is_pred' {
		exit
	}
	local marg_nomarkout 1
	forval ip = 1/`._pred.arrnels' {
		if !`.force' {
			_check_e_margins_mark margins, `._pred[`ip'].opts'
			if r(markout) == 1 {
				local marg_nomarkout 0
			}
		}
	}
	if !`.force' {
		.markout = !`marg_nomarkout'
	}
end


program ._check_predict
	version 11

	if `._pred.arrnels' == 1	///
	 & inlist(`"`.gexp'"', "", "`._pred[1].varname'") {
		.is_pred = 1
	}
	local marg_ok 1
	forval ip = 1/`._pred.arrnels' {
		if `"`._pred[`ip'].opts'"' == "xb" {
			.is_xb[`ip'] = !`._pred[`ip'].notxb'
		}
		else {
			.is_xb[`ip'] = 0
		}
		if !`.force' {
			_check_e_margins margins, `._pred[`ip'].opts'
			if r(marginsok) == 0 {
				local marg_ok 0
			}
		}
		local hasoffset 0
		if `"`._pred[`ip'].offset'"' != "nooffset" {
			local coleq : coleq e(b), quote
			local coleq : list clean coleq
			local coleq : list uniq coleq
			local neq : list sizeof coleq
			local hasoffset = strlen("`e(offset)'")
			local done = `hasoffset'
			local i 1
			while !`done' {
				local hasoffset = strlen("`e(offset`i')'")
				local ++i
				local done = `i' > `neq' | `hasoffset'
			}
		}
		.offset[`ip'] = `hasoffset'
		if `.offset[`ip']' {
			.use_in1 = 0
		}
		if `.is_xb[`ip']' {
			local 0 `", `._pred[`ip'].eq'"'
			syntax [, EQuation(string)]
			if bsubstr("`equation'",1,1) == "#" {
				local eqno = bsubstr("`equation'",2,.)
				confirm integer number `eqno'
				.eqno[`ip'] = `eqno'
			}
			else if `:length local equation' {
				local coleq : coleq e(b), quote
				local coleq : list uniq coleq
				local eqno : list posof `"`equation'"' in coleq
				if `eqno' == 0 {
					di as err ///
					"equation `equation' not found"
					exit 303
				}
				.eqno[`ip'] = `eqno'
			}
			else {
				.eqno[`ip'] = 1
			}
		}
	}
	if !`.force' {
		.e_marginsok = `marg_ok'
	}
end

program ._parse_dydx
	syntax [,	dydx(string)		///
			eyex(string)		///
			dyex(string)		///
			eydx(string)		///
			continuous		///
	]

	.ey = "`eyex'" != "" | "`eydx'" != ""
	if `.ey' {
		local ey ey
	}
	.ex = "`eyex'" != "" | "`dyex'" != ""
	if `.ex' {
		local ex ex
	}
	if `:length local continuous' {
		.fvrestripe = "fvrestripe"
	}
	local matopt `"`.matopt'"'
	local XVARS `dydx' `eyex' `dyex' `eydx'
	dydx_unab `XVARS', `matopt'
	local XVARS "`r(varlist)'"
	_ms_dydx_parse `XVARS', `ey' `ex' `matopt'
	local XVARS "`r(varlist)'"
	fvexpand `XVARS'
	if `"`continuous'"' == "" {
		local xvars "`r(varlist)'"
	}
	else {
		local XVARS "`r(varlist)'"
		foreach x of local XVARS {
			_msparse `x', noomit
			local xvars `xvars' `r(stripe)'
		}
	}
	if `:list sizeof xvars' {
		if !`.cr_all' {
			.cr_use = 0
		}
	}
	.xvars = "`xvars'"
	.coefttl = cond(`.ey', "ey/", "dy/") + cond(`.ex', "ex", "dx")
	.dydxopt = cond(`.ey', "ey", "dy") + cond(`.ex', "ex", "dx")
	if `.hascm' & `.alt_seq' == 0 {
		local casevars `"`.casevars'"'
		fvrevar `xvars', list
		local altvars `"`r(varlist)'"'
		local altvars : list altvars - casevars
		gettoken name : altvars
		if `"`name'"' != "" {
			di as err "{p 0 0 2}"
			di as err "option {bf:alternative(simultaneous)}"
			di as err "is not allowed with"
			di as err "alternative-specific variable {bf:`name'}"
			di as err "in option {bf:`.dydxopt'()}"
			di as err "{p_end}"
			exit 198
		}
	}
	local old
	local k 0
	local note 0
	foreach x of local xvars {
		_ms_parse_parts `x'
		if r(type) == "factor" {
			if `.ex' {
				if `.ey' {
					local opt eyex
				}
				else	local opt dyex
				di as err ///
"factor variables not allowed in option {bf:`opt'()}"
				exit 198
			}
			local name `r(ts_op)'.`r(name)'
			if `"`name'"' != `"`old'"' {
				if `k' == 1 {
					.fvrestripe = "fvrestripe"
					local ++note
				}
				local old : copy local name
				local k 1
			}
			else {
				local ++k
			}
		}
	}
	if `k' == 1 {
		.fvrestripe = "fvrestripe"
		local ++note
	}
	if `note' & !`:length local continuous' {
		di as txt "{p 0 7}(note: " ///
"continuous option implied because a factor with only one level" ///
" was specified in the `.dydxopt'() option){p_end}"
	}
end

program .dydx_unab, rclass
	syntax [anything] [, matrix(passthru)]
	if "`matrix'" == "" {
		local matrix matrix(e(b))
	}
	_ms_lf_info, `matrix'
	forval i = 1/`r(k_lf)' {
		local COLNA `COLNA' `r(varlist`i')'
	}
	foreach spec of local COLNA {
		_ms_parse_parts `spec'
		if inlist(r(type), "variable", "factor") {
			if r(name) == "_cons" {
				continue
			}
			if "`r(ts_op)'" != "" {
				local name `"`r(ts_op)'.`r(name)'"'
			}
			else	local name `"`r(name)'"'
			if `:list name in _ALL' == 0 {
				local _ALL `_ALL' `name'
			}
		}
		else if r(type) == "interaction" {
		    local k = r(k_names)
		    forval i = 1/`k' {
			if "`r(ts_op`i')'" != "" {
				local name `"`r(ts_op`i')'.`r(name`i')'"'
			}
			else	local name `"`r(name`i')'"'
			if `:list name in _ALL' == 0 {
				local _ALL `_ALL' `name'
			}
		    }
		}
	}
	if `.esample' {
		local if "if e(sample)"
	}
	local ZERO : copy local anything
	while `:length local ZERO' {
		gettoken 0 ZERO : ZERO, bind
		local len : length local 0
		if inlist(`"`0'"', "*", "_all") {
			local 0 : copy local _ALL
		}
		if bsubstr("_continuous",1,max(2,`len')) == `"`0'"' {
			local xvars `xvars' `0'
		}
		else if bsubstr("_factor",1,max(2,`len')) == `"`0'"' {
			local xvars `xvars' `0'
		}
		else {
			capture _unab `0', `matrix'
			if c(rc) == 0 {
				local 0 `"`r(varlist)'"'
			}
			local xvars `xvars' `0'
		}
	}
	return local varlist `"`xvars'"'
end

program .get_dx_oname
	args c_dx COLON dx
	local i = `.dxnlist.arrindexof "`dx'"'
	if `i' == 0 {
		di as err "{bf:`dx'} not found in list of indepvars"
		error 198
	}
	c_local `c_dx' `.dxolist[`i']'
end

program ._check_marg_for_alt
	args name
	if `"`name'"' != `"`.altvar'"' {
		exit
	}
	local marg "{it:marginslist}"
	di as err ///
	"invalid `marg' variable;" _n ///
	"alternative variable {bf:`.altvar'} is not allowed in `marg'"
	exit 198
end

program ._parse_margins
	syntax [anything]
	.umargins = `"`anything'"'
	_strip_contrast `anything'
	if r(contrast) {
		.has_contrast = 1
	}
	local varlist `"`r(varlist)'"'
	_fv_term_info `varlist' if `.t_touse' `.wt', noc
	local k = r(k_terms)
	forval i = 1/`k' {
		._base[`i'] = r(base`i')
		.mlist[`i'] = "`.t_marg'`i'"
		matrix `.mlist[`i']' = r(level`i')
		if `.hascm' {
			local casevars `.casevars'
			local colna : colna `.mlist[`i']'
			.hasAltSpecMarg[`i'] = 0
			foreach name of local colna {
				._check_marg_for_alt `name'
				if `:list posof "`name'" in casevars' == 0 {
					.hasAltSpecMarg[`i'] = `.alt_seq'
					continue, break
				}
			}
		}
	}
	.k_m = `k'
	local 0 `"`r(varlist)'"'
	syntax varlist(fv ts)
	.margins = `"`varlist'"'
	if `"`.matopt'"' != "" {
		// ensures that the specified marginsvars are in the
		// list of factors variables in -e(covariates)-
		tempname tb
		matrix `tb' = `.t_altb'
		_fv_term_info `varlist' if `.t_touse' `.wt',	///
			noc					///
			matrix(`tb')				///
			tsrestripe				///
			individuals
	}
end

program ._get_common_subopts, sclass
	if `.has_contrast' {
		local noeffects NOEFFects
	}
	syntax [,			///
		CIeffects		///
		PVeffects		///
		`noeffects'		///
		EFFects			///
		SORT			///
		ATEQuations		///
		EQuation(passthru)	///
		post			///
		*			///
	]

	if "`noeffects'" != "" {
		opts_exclusive "`noeffects' `effects'"
		opts_exclusive "`noeffects' `cieffects'"
		opts_exclusive "`noeffects' `pveffects'"
	}
	local effects `cieffects' `pveffects' `effects' `noeffects'

	local equation `equation' `atequations'
	opts_exclusive `"`equation'"'
	if `"`equation'"' == "" {
		local equation atequations
	}

	if `:length local post' {
		.post = 1
	}
	else if `.post' {
		local post post
	}

	local opts `.commonopts' `effects' `sort' `post' `equation'
	local opts : list uniq opts
	.commonopts = `"`opts'"'
	sreturn clear
	sreturn local options `"`options'"'
end

program ._drop_common_subopts, sclass
	local 0 `", `.commonopts'"'
	syntax [, SORT *]
	.commonopts = `"`sort'"'
end

program ._parse_contrast_opts
	capture ._get_common_subopts `0'
	if c(rc) {
		local rc = c(rc)
		di as err "invalid {bf:contrast()} option;"
		._get_common_subopts `0'
		error `rc'	// [sic]
	}
	local 0 `", `s(options)'"'
	if `.hascm' {
		local ALTOPTS				///
			OUTcomejoint			///
			OUTcomecontrast(string)		///
			ALTernativejoint		///
			ALTernativecontrast(string)	///
							 // blank
	}
	local OPTS	nowald			/// display options
			NOATlevels		///
			lincom			/// other options
			overall			///
			ATjoint			/// margins options
			ATcontrast(string)	///
			PREDictjoint		///
			PREDictcontrast(string)	///
			OVERjoint		///
			WITHINjoint		///
			noSVYadjust		///
			MARGINSWithin		///
			`ALTOPTS'		///
						 // blank
	capture syntax [, `OPTS']
	if c(rc) {
		local rc = c(rc)
		di as err "invalid {bf:contrast()} option;"
		syntax [, `OPTS']
		error `rc'	// [sic]
	}
	if `.se' == 0 {
		local wald nowald
	}
	local COPTS `wald' `noatlevels' `lincom' `overall' `svyadjust'
	if `:length local COPTS' {
		.has_contrast = 1
	}
	.contrastopts = "`COPTS'"

	if `:length local predictcontrast' {
		local predictjoint predictjoint
		local ucon = bsubstr(`"`predictcontrast'"',1,1) == "{"
		local dot = strpos(`"`predictcontrast'"', ".")
		if !(`ucon' | `dot') {
			local predictcontrast `predictcontrast'._predict
		}
		capture _pred_strip_contrast `predictcontrast', ///
			notsops noint opt(predictcontrast)
		if c(rc) {
			local rc = c(rc)
			di as err "invalid {bf:predictcontrast()} suboption;"
			_pred_strip_contrast `predictcontrast', ///
				notsops noint opt(predictcontrast)
			exit `rc'
		}
		local var `"`r(varlist)'"'
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1, .)
		}
		if `"`var'"' != "_predict" {
			di as err "invalid {bf:predictcontrast()} suboption;"
			di as err ///
`"{p 0 0 2}`predictcontrast' found where {bf:_predict} with optional "'	///
"contrast operators expected{p_end}"
			exit 198
		}
		.pcontrast = `"`predictcontrast'"'
	}

	if `:length local atcontrast' {
		local atjoint atjoint
		local ucon = bsubstr(`"`atcontrast'"',1,1) == "{"
		local dot = strpos(`"`atcontrast'"', ".")
		if !(`ucon' | `dot') {
			local atcontrast `atcontrast'._at
		}
		capture _at_strip_contrast `atcontrast', ///
			notsops noint opt(atcontrast)
		if c(rc) {
			local rc = c(rc)
			di as err "invalid {bf:atcontrast()} suboption;"
			_at_strip_contrast `atcontrast', ///
				notsops noint opt(atcontrast)
			exit `rc'
		}
		local var `"`r(varlist)'"'
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1, .)
		}
		if `"`var'"' != "_at" {
			di as err "invalid {bf:atcontrast()} suboption;"
			di as err ///
`"{p 0 0 2}`atcontrast' found where {bf:_at} with optional contrast "'	///
"operators expected{p_end}"
			exit 198
		}
		.atcontrast = `"`atcontrast'"'
	}
	if `:length local outcomecontrast' {
		local outcomejoint outcomejoint
		local ucon = bsubstr(`"`outcomecontrast'"',1,1) == "{"
		local dot = strpos(`"`outcomecontrast'"', ".")
		if !(`ucon' | `dot') {
			local outcomecontrast `outcomecontrast'._outcome
		}
		capture _outcome_strip_contrast `outcomecontrast', ///
			notsops noint opt(outcomecontrast)
		if c(rc) {
			local rc = c(rc)
			di as err "invalid {bf:outcomecontrast()} suboption;"
			_outcome_strip_contrast `outcomecontrast', ///
				notsops noint opt(outcomecontrast)
			exit `rc'
		}
		local var `"`r(varlist)'"'
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1, .)
		}
		if `"`var'"' != "_outcome" {
			di as err "invalid {bf:outcomecontrast()} suboption;"
			di as err ///
`"{p 0 0 2}`outcomecontrast' found where {bf:_outcome} with optional "'	///
"contrast operators expected{p_end}"
			exit 198
		}
		.outcontrast = `"`outcomecontrast'"'
	}
	if `:length local alternativecontrast' {
		local alternativejoint alternativejoint
		local ucon = bsubstr(`"`alternativecontrast'"',1,1) == "{"
		local dot = strpos(`"`alternativecontrast'"', ".")
		if !(`ucon' | `dot') {
			local alternativecontrast `alternativecontrast'.`.altvar'
		}
		capture _strip_contrast `alternativecontrast', ///
			notsops noint opt(alternativecontrast)
		if c(rc) {
			local rc = c(rc)
			di as err "invalid {bf:alternativecontrast()} suboption;"
			_strip_contrast `alternativecontrast', ///
				notsops noint opt(alternativecontrast)
			exit `rc'
		}
		local var `"`r(varlist)'"'
		local pos = strpos("`var'",".")
		if `pos' {
			local var = bsubstr("`var'", `pos'+1, .)
		}
		if `"`var'"' != "`.altvar'" {
			di as err "invalid {bf:alternativecontrast()} suboption;"
			di as err ///
`"{p 0 0 2}`alternativecontrast' found where {bf:`.altvar'} with optional "'	///
"contrast operators expected{p_end}"
			exit 198
		}
		.altcontrast = `"`alternativecontrast'"'
	}

	if `:length local predictjoint' {
		.has_contrast = 1
		.has_pcontrast = 1
	}
	if `:length local atjoint' {
		.has_contrast = 1
		.has_atcontrast = 1
	}
	if `:length local overjoint' {
		.has_contrast = 1
		.has_ocontrast = 1
	}
	if `:length local withinjoint' {
		.has_contrast = 1
		.has_wcontrast = 1
	}
	if `:length local marginswithin' {
		.has_atmargins = 1
	}
	if `:length local outcomejoint' {
		.has_contrast = 1
		.has_outcontrast = 1
	}
	if `:length local alternativejoint' {
		.has_contrast = 1
		.has_altcontrast = 1
	}
end

program ._put_sharp, sclass
	while `:length local 0' {
		gettoken spec 0 : 0, parse(" {}")
		if "`spec'" == "{" {
			local result `result'`sharp'`spec'
			while "`spec'" != "}" {
				gettoken spec 0 : 0, parse(" {}")
				if "`spec'" == "" {
					error 198
				}
				local result `result' `spec'
			}
		}
		else {
			local result `result'`sharp'`spec'
		}
		local sharp "#"
	}
	sreturn local result `"`result'"'
end

program ._setup_contrast
	if `.has_contrast' == 0 {
		exit
	}

	local at_char
	local k_out 0
	local k_alt 0
	if `.hascm' {
		local k_out = `.noutsel'
		if `k_out' > 1 {
			local outcontrast `"`.outcontrast'"'
			if `:length local outcontrast' == 0 {
				local outcontrast _outcome
			}
			if `.has_outcontrast' {
				._put_sharp `outcontrast'
				loca prefix `"`s(result)'"'
				local sharp0 "#"
			}
			else {
				loca postfix `"_outcome"'
				local sharp1 "#"
				local at_char "@"
			}
		}
		local k_alt = `.naltsel'
		if `.hasAltSpec' & `k_alt' > 1 {
			local altcontrast `"`.altcontrast'"'
			if `:length local altcontrast' == 0 {
				local altcontrast `.altvar'
			}
			if `.has_altcontrast' {
				._put_sharp `altcontrast'
				local prefix `"`prefix'`sharp0'`s(result)'"'
				local sharp0 "#"
			}
			else {
				loca postfix `"`postfix'`sharp1'`.altvar'"'
				local sharp1 "#"
				local at_char "@"
			}
		}
	}

	if `.is_pred' == 2 {
		local k_pred = `._pred.arrnels'
		local pcontrast `"`.pcontrast'"'
		if `:length local pcontrast' == 0 {
			local pcontrast _predict
		}
		if `.has_pcontrast' {
			._put_sharp `pcontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			local postfix "`postfix'`sharp1'_predict"
			local sharp1 "#"
		}
	}
	else	local k_pred 0

	local atrows `.atrows'
	if `.hascm' {
		// NOTE: .atrows includes the by-levels in
		// this case, but not in the standard case
		if `.hasby' {
			local atrows = `atrows'/`.k_by'
		}
	}
	local k_at = `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'
	if `.hascm' {
		local k_xvars = `.altSpecXvar.arrnels'
		if `k_xvars' {
			local hasAltSpecXvar `.altSpecXvar[1]'
			forval i = 2/`k_xvars' {
				if `hasAltSpecXvar' != `.altSpecXvar[`i']' {
		di as err "{p 0 0 2}"
		di as err "contrasts not allowed;{break}"
		di as err "contrasts are only allowed with option"
		di as err "{bf:`.dydxopt'(}{it:varlist}{bf:)}"
		di as err "when all the variables in {it:varlist} are"
		di as err "alternative-specific"
		di as err "or none of them are"
		di as err "{p_end}"
		exit 198
				}
			}
		}
		local hasAltSpecAt 0
		if `k_at' {
			local hasAltSpecAt `.hasAltSpecAt[1]'
			forval i = 2/`k_at' {
				if `hasAltSpecAt' != `.hasAltSpecAt[`i']' {
		di as err "{p 0 0 2}"
		di as err "contrasts not allowed;{break}"
		di as err "contrasts are only allowed with multiple"
		di as err "{bf:at()} options"
		di as err "when all of them specify changes to"
		di as err "an alternative-specific variable"
		di as err "or none of them do"
		di as err "{p_end}"
		exit 198
				}
			}
		}
		local hasAltSpecMarg 0
		if `k_marg' {
			local hasAltSpecMarg `.hasAltSpecMarg[1]'
			forval i = 2/`k_marg' {
				if `hasAltSpecMarg' != `.hasAltSpecMarg[`i']' {
		di as err "{p 0 0 2}"
		di as err "contrasts not allowed;{break}"
		di as err "contrasts are only allowed with multiple"
		di as err "margins variables"
		di as err "when all of them are"
		di as err "alternative-specific variables"
		di as err "or none of them are"
		di as err "{p_end}"
		exit 198
				}
			}
		}
		if `hasAltSpecAt' | `hasAltSpecMarg' {
			local atrows = `atrows'/`.naltsel'
		}
	}
	if `atrows' > 1 {
		local atcontrast `"`.atcontrast'"'
		if `:length local atcontrast' == 0 {
			local atcontrast _at
		}
		if `.has_atcontrast' {
			._put_sharp `atcontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			local postfix "`postfix'`sharp1'_at"
			local sharp1 "#"
		}
	}

	local ocontrast `"`.ocontrast'"'
	if `:length local ocontrast' {
		if `.has_ocontrast' {
			._put_sharp `ocontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			._put_sharp `ocontrast'
			local postfix `"`postfix'`sharp1'`s(result)'"'
			local sharp1 "#"
			local at_char "@"
		}
	}

	local wcontrast `"`.wcontrast'"'
	if `:length local wcontrast' {
		if `.has_wcontrast' {
			._put_sharp `wcontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			._put_sharp `wcontrast'
			local postfix `"`postfix'`sharp1'`s(result)'"'
			local sharp1 "#"
			if "`at_char'" == "" {
				local at_char "|"
			}
		}
	}

	local umargins `"`.umargins'"'
	if `k_pred' | `k_at' {
		local umargins : subinstr local umargins "|" "@", all
		.umargins = `"`umargins'"'
		local at_char "@"
	}
	else if "`at_char'" == "" {
		local at_char "@"
	}
	if `.has_atmargins' {
		if `"`umargins'"' != "" {
			local postfix "(`umargins')`sharp1'`postfix'"
			local umargins
		}
	}
	if `:length local postfix' {
		local postfix "`at_char'`postfix'"
	}
	if `:length local prefix' {
		if `"`umargins'"' == "" {
			.contrast = `"`prefix'`postfix'"'
		}
		else {
			.contrast = `"`prefix'#(`umargins')`postfix'"'
		}
	}
	else if `"`umargins'"' != "" {
		.contrast = `"(`umargins')`postfix'"'
	}
	if `"`.contrast'"' == "" {
		.contrast = `"`umargins'"'
	}
	if `"`.contrast'"' == "" {
		di as txt ///
"{p 0 6 2}note: ignoring contrast options because there are no "	///
"margins for applying contrasts{p_end}"
		.has_contrast = 0
		._drop_common_subopts
	}
end

program ._parse_pwcompare_opts
	if `.has_contrast' {
		di as err ///
"option {bf:pwcompare} is not allowed with contrast operators"
		exit 198
	}
	capture ._get_common_subopts `0'
	if c(rc) {
		local rc = c(rc)
		di as err "invalid {bf:pwcompare()} option;"
		._get_common_subopts `0'
		error `rc'	// [sic]
	}
	local 0 `", `s(options)'"'
	local OPTS	CIMargins		/// display opts
			GROUPs			///
						 // blank
	capture syntax [, `OPTS']
	if c(rc) {
		local rc = c(rc)
		di as err "invalid {bf:pwcompare()} option;"
		syntax [, `OPTS']
		error `rc'	// [sic]
	}
	if `"`.mc_all'"' != "" & `"`groups'"' != "" {
		opts_exclusive "mcompare(`.mcall') pwcompare(`groups')"
	}

	.pwcompareopts = "`cimargins' `groups'"
end

program ._setup_pwcompare
	if `.has_pwcompare' == 0 {
		exit
	}

	if `.hascm' {
		local k_out = `.noutsel'
		if `k_out' > 1 {
			loca prefix `"_outcome"'
			local sharp "#"
		}
		local k_alt = `.naltsel'
		if `.hasAltSpec' & `k_alt' > 1 {
			loca prefix `"`prefix'`sharp'`.altvar'"'
			local sharp "#"
		}
	}

	if `.is_pred' == 2 {
		local prefix `"`prefix'`sharp'_predict"'
		local sharp "#"
	}

	local atrows `.atrows'
	if `.hasby' {
		local atrows = `atrows'/`.k_by'
	}
	if `.hascm' {
		local k_at = `.atlist.arrnels'
		local hasAltSpecAt 0
		if `k_at' {
			local hasAltSpecAt `.hasAltSpecAt[1]'
			forval i = 2/`k_at' {
				if `hasAltSpecAt' != `.hasAltSpecAt[`i']' {
		di as err "{p 0 0 2}"
		di as err "pairwise comparisons are not allowed when one"
		di as err "{bf:at()} option changes the values of"
		di as err "alternative-specific variables but another"
		di as err "{bf:at()} option does not"
		exit 198
				}
			}
		}
		local k_marg	= `.mlist.arrnels'
		local hasAltSpecMarg 0
		if `k_marg' {
			local hasAltSpecMarg `.hasAltSpecMarg[1]'
			forval i = 2/`k_marg' {
				if `hasAltSpecMarg' != `.hasAltSpecMarg[`i']' {
		di as err "{p 0 0 2}"
		di as err "pairwise comparisons are not allowed when"
		di as err "some of the margins variables are"
		di as err "alternative-specific but others"
		di as err "are not"
		exit 198
				}
			}
		}
		if `hasAltSpecAt' | `hasAltSpecMarg' {
			local atrows = `atrows'/`.naltsel'
		}
	}
	if `atrows' > 1 {
		local prefix `prefix'`sharp'_at
		local sharp "#"
	}

	local over `"`.over'"'
	if `:length local over' {
		._put_sharp `over'
		local prefix `prefix'`sharp'`s(result)'
		local sharp "#"
	}

	local within `"`.within'"'
	if `:length local within' {
		._put_sharp `within'
		local prefix `prefix'`sharp'`s(result)'
		local sharp "#"
	}

	if `:length local prefix' {
		if `"`.umargins'"' == "" {
			.pwcompare = `"`prefix'"'
		}
		else {
			.pwcompare = `"`prefix'#(`.umargins')"'
		}
	}
	else {
		.pwcompare = `"`.umargins'"'
	}
	if `"`.pwcompare'"' == "" {
		di as txt ///
"{p 0 6 2}note: ignoring pwcompare options because there are no "	///
"margins for making pairwise comparisons{p_end}"
		.has_pwcompare = 0
		._drop_common_subopts
	}
end

program ._check_by_and_at
	local k_at	= `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'

	forval i = 1/`k_marg' {
		local mvars : colna `.mlist[`i']'
		local mlist `mlist' `mvars'
	}
	local mlist : list uniq mlist

	local over `"`.over'"'
	local common : list mlist & over
	if `:length local common' {
		gettoken x : common
		di as err ///
"factor {bf:`x'} not allowed in {bf:over()} option if it is specified as a margin"
		exit 198
	}
	local within `"`.within'"'
	local common : list mlist & within
	if `:length local common' {
		gettoken x : common
		di as err ///
"factor {bf:`x'} not allowed in {bf:within()} option if it is specified as a margin"
		exit 198
	}

	if `k_marg' == 1 {
		local checkopt singlemargin
	}

	local k 0
	local noasobs 1
	forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		forval j = 1/`k_at' {
			local ++k
			._mstat[`k'] = ._marg_stat.new
			._mstat[`k'].set_parent	`.objkey'
			._mstat[`k'].set_at	`.atlist[`j']' `.atstat[`j']'
			._mstat[`k'].set_margin	`marg' `mlist'
			._mstat[`k'].check_at, `checkopt'
			if `noasobs' {
				local noasobs = r(noasobs)
			}
		}
	}
	.noasobs = `noasobs'
end

program ._check_by_and_at_cm
	local k_at	= `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'
	local k_alt	= `.altlist.arrnels'

	forval i = 1/`k_marg' {
		local mvars : colna `.mlist[`i']'
		local mlist `mlist' `mvars'
	}
	local mlist : list uniq mlist

	local over `"`.over'"'
	local common : list mlist & over
	if `:length local common' {
		gettoken x : common
		di as err ///
"factor {bf:`x'} not allowed in {bf:over()} option if it is specified as a margin"
		exit 198
	}
	local within `"`.within'"'
	local common : list mlist & within
	if `:length local common' {
		gettoken x : common
		di as err ///
"factor {bf:`x'} not allowed in {bf:within()} option if it is specified as a margin"
		exit 198
	}

	if `k_marg' == 1 {
		local checkopt singlemargin
	}

	forval o = 1/`k_alt' {
		if `.outsel[`o']' {
			.outfirst = `o'
			continue, break
		}
	}
	forval a = 1/`k_alt' {
		if `.altsel[`a']' {
			.altfirst = `a'
			continue, break
		}
	}

	local anyAltSpecAt 0
	local k 0
	local noasobs 1
	forval o = 1/`k_alt' {
		if `.outsel[`o']' == 0 {
			continue
		}
		local cmj 0
	forval a = 1/`k_alt' {
		if `.altsel[`a']' == 0 {
			continue
		}
	forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		forval j = 1/`k_at' {
			if `.hasAltSpecMarg[`i']' {
				.hasAltSpec = 1
			}
			else if `.hasAltSpecAt[`j']' {
				.hasAltSpec = 1
			}
			else {
				continue
			}
			local mat `.atlist[`j']'
			local ++k
			._mstat[`k'] = ._marg_stat.new
			._mstat[`k'].set_parent	`.objkey'
			local mat `mat'_`a'_`i'
			matrix `mat' = `.atlist[`j']'
			local ++cmj
			if `o' == `.outfirst' {
				.cm_atlist[`cmj'] = "`mat'"
				.cm_atstat[`cmj'] = `"`.atstat[`j']'"'
				.cm_at_filled[`cmj'] = 0
			}
			._mstat[`k'].set_at `mat' `.atstat[`j']'
			._mstat[`k'].set_margin	`marg' `mlist'
			._mstat[`k'].set_cminfo	`"`.altvar'"'	///
						`"`.myaltvar'"'	///
						`.altlist[`a']'	///
						`a'		///
						`.altlist[`o']'	///
						1		///
						`cmj'
			._mstat[`k'].check_at, `checkopt'
			if `noasobs' {
				local noasobs = r(noasobs)
			}
		} // j
	} // i
	} // a
		local cmj0 `cmj'
	} // o
	forval o = 1/`k_alt' {
		if `.outsel[`o']' == 0 {
			continue
		}
		local cmj `cmj0'
	forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		forval j = 1/`k_at' {
			if `.hasAltSpecMarg[`i']' {
				continue
			}
			else if `.hasAltSpecAt[`j']' {
				continue
			}
			local mat `.atlist[`j']'
			local ++k
			._mstat[`k'] = ._marg_stat.new
			._mstat[`k'].set_parent	`.objkey'
			local ++cmj
			if `o' == `.outfirst' {
				.cm_atlist[`cmj'] = "`mat'"
				.cm_atstat[`cmj'] = `"`.atstat[`j']'"'
				.cm_at_filled[`cmj'] = 0
			}
			._mstat[`k'].set_at `mat' `.atstat[`j']'
			._mstat[`k'].set_margin	`marg' `mlist'
			._mstat[`k'].set_cminfo	`"`.altvar'"'	///
						`"`.myaltvar'"'	///
						-1		///
						-1		///
						`.altlist[`o']'	///
						0		///
						`cmj'
			._mstat[`k'].check_at, `checkopt'
			if `noasobs' {
				local noasobs = r(noasobs)
			}
		} // j
	} // i
	} // o
	.noasobs = `noasobs'
end

program ._check_exp, eclass
	syntax [if] [in] [fw iw pw aw] [, NOSE pred(passthru)]

	tempname ehold b V
	_est hold `ehold', copy restore

	marksample t_if, novarlist zero
	local wgt "[`weight'`exp']"
	.compute `if' `in' `wgt', check `pred'
	scalar `b' = r(b)
	local constant = r(constant)
	local n = r(N)

	sum `t_if' `wgt' if `t_if', mean
	local N = r(N)

	if `N' > `n' {
		di as err "{p 0 0 2}"
		di as err ///
"missing predicted values encountered within the estimation sample"
		di as err "{p_end}"
		exit 322
	}
	if `constant' {
		di as txt ///
"{p 0 0 2}Warning: prediction constant over observations.{p_end}"
	}

	if `"`nose'"' != "" | `.e_marginsok' {
		exit
	}

	preserve

	// reset e(V) to identity matrix
	matrix `V' = e(V)
	matrix `V' = I(colsof(`V'))
	ereturn repost V=`V'

	// remove all non-integer scalars in e()
	local scalars : e(scalars)
	foreach s of local scalars {
		if e(`s') != floor(e(`s')) {
			if "`s'" != "version" {
				ereturn local `s'
			}
		}
	}

	// set all depvars to zero
	local vlist `"`e(depvar)'"'
	local vlist : list uniq vlist
	local atvars `"`.atvarsopt'"'
	foreach var of local vlist {
		capture fvrevar `var', list
		if !c(rc) {
			local var `r(varlist)'
			if !`:list var in atvars' {
				capture replace `r(varlist)' = 0
			}
		}
	}
	capture {
		.compute `if' `in' `wgt', check `pred'
		assert reldif(`b', r(b)) < 1e-12
	}
	if c(rc) {
		if `"`.oexp'"' != "" {
			if `.is_pred' {
				local msg0 "prediction"
			}
			else {
				local msg0 "expression"
			}
		}
		else {
			local msg0 "prediction"
			if `._pred.arrnels' == 1 {
				if `"`._pred[1].opts'"' == "" {
					local msg0 "default prediction"
				}
			}
		}
		local msg1 ///
" is a function of possibly stochastic quantities other than {bf:e(b)}"
		if `.force' {
			di as txt `"{p 0 7}(note: `msg0' `msg1'){p_end}"'
			exit
		}
		di as err `"{p}`msg0' `msg1'{p_end}"'
		exit 498
	}
end

// subroutines for .compute -------------------------------------------------

program .copyvar
	syntax [varname(default=none)] [, next rename zero]
	local next : length local next
	if `next' {
		local next = `.gen'
	}
	if `next' {
		local rename : length local rename
		local zero : length local zero
		local n = `._phat.arrnels' + 1
		local phat "`.t_phat'`n'"
		._phat[`n'] = "`phat'"
		if `zero' {
			quietly gen byte `phat' = 0
		}
		else if `rename' {
			rename `varlist' `phat'
		}
		else {
			quietly gen double `phat' = `varlist'
		}
	}
end

// subroutines for .estimate ------------------------------------------------

program ._make_group, sort
	local by `.t_sub' `.by'
	sort `by'
	quietly by `by': gen `.t_grp' = _n == 1 & `.t_sub'
	mata: st__marg_make_group("`.t_gmat'", "`.by'", "`.t_grp'")
	.k_by = rowsof(`.t_gmat')
	if `.k_by' > 1 {
		local nby = colsof(`.t_gmat')
		quietly replace `.t_grp' = sum(`.t_grp') if `.t_sub'
		local GVARS "`.by'"
		forval i = 1/`.k_by' {
			local stripe
			local cross
			local gvars : copy local GVARS
			forval j = 1/`nby' {
				gettoken gvar gvars : gvars
				local level = `.t_gmat'[`i',`j']
				local stripe `stripe'`cross'`level'.`gvar'
				local cross "#"
			}
			.bylist[`i'] = "`stripe'"
		}
		if `.hascm' {
			sort `.t_sub' `.cm_casevar' `.cm_panelvar' `.t_grp'
			capture ///
			by `.t_sub' `.cm_casevar' `.cm_panelvar': ///
				assert `.t_grp' == `.t_grp'[1] if `.t_sub'
			if c(rc) {
				local opt "option"
				if "`.over'" != "" & "`.within'" != "" {
				    local opt "options"
				    local msg "{bf:over()} and {bf:within()}"
				}
				else if "`.over'" != "" {
				    local msg "{bf:over()}"
				}
				else {
				    local msg "{bf:within()}"
				}
				di as err "invalid `opt' `msg';"
				di as err "{p 0 0 2}"
				di as err "case id variable"
				di as err "{bf:`.cm_casevar'}"
				di as err "is not nested within groups"
				di as err "defined by"
				di as err "`opt' `msg'"
				di as err "{p_end}"
				exit 459
			}
		}
	}
	else {
		.hasby = 0
		drop `.t_grp'
		matrix drop `.t_gmat'
	}
end

program ._fill_at
	local k_at = `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'
	local k 1
	forval i = 1/`k_marg' {
		local idx 0
		forval j = 1/`k_at'{
			._mstat[`k'].set_at_idx0 `idx'
			local idx = `idx' + rowsof(`.atlist[`j']')
			local ++k
		}
	}
	local r_at 0
	forval i = 1/`k_at' {
		local r_at = `r_at' + rowsof(`.atlist[`i']')
		._mstat[`i'].fill_at
		.atstat[`i'] = `"`._mstat[`i'].atstat'"'
	}
	.atrows = `r_at'
end

program ._fill_at_cm
	local k_at = `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'
	local k_alt	= `.altlist.arrnels'
	local k 0
	forval o = 1/`k_alt' {
		if `.outsel[`o']' == 0 {
			continue
		}
	forval a = 1/`k_alt' {
		if `.altsel[`a']' == 0 {
			continue
		}
	forval i = 1/`k_marg' {
		local idx 0
		forval j = 1/`k_at'{
			if `.hasAltSpecMarg[`i']' {
				.hasAltSpec = 1
			}
			else if `.hasAltSpecAt[`j']' {
				.hasAltSpec = 1
			}
			else {
				continue
			}
			local ++k
			._mstat[`k'].set_at_idx0 `idx'
			local idx = `idx' + rowsof(`._mstat[`k'].at')
			._mstat[`k'].fill_at
		}
		local idx0 `idx'
	} // i
	} // a
	} // o
	forval o = 1/`k_alt' {
		if `.outsel[`o']' == 0 {
			continue
		}
	forval i = 1/`k_marg' {
		local idx `idx0'
		forval j = 1/`k_at'{
			if `.hasAltSpecMarg[`i']' {
				continue
			}
			else if `.hasAltSpecAt[`j']' {
				continue
			}
			local ++k
			._mstat[`k'].set_at_idx0 `idx'
			local idx = `idx' + rowsof(`._mstat[`k'].at')
			._mstat[`k'].fill_at
		}
	} // i
	} // o
	local k_at = `.cm_atlist.arrnels'
	local r_at 0
	forval i = 1/`k_at' {
		local r_at = `r_at' + rowsof(`.cm_atlist[`i']')
		.atstat[`i'] = `"`._mstat[`i'].atstat'"'
	}
	.atrows = `r_at'
end

program ._setup_cm, sort
	local casevars `.casevars'
	local xvars `.xvars'
	local oldname
	local kk 0
	foreach x of local xvars {
		_ms_parse_parts `x'
		if r(type) == "factor" {
			if "`r(ts_op)'" != "" {
				local x `r(ts_op)'.`r(name)'
			}
			else {
				local x `r(name)'
			}
			if `"`x'"' != "`oldname'" {
				local ++kk
				local oldname : copy local x
			}
		}
		else {
			local ++kk
			local oldname
		}
		if `:list x in casevars' {
			.altSpecXvar[`kk'] = 0
		}
		else {
			.altSpecXvar[`kk'] = `.alt_seq'
			if `.alt_seq' {
				.hasAltSpec = 1
			}
		}
	}
	tempname t
	quietly gen `t' = . in 1
	if `.hasby' {
		local by `.t_sub' `.cm_panelvar' `.cm_casevar' `.t_grp'
		sort `by'
		forval g = 1/`.k_by' {
			quietly by `by' : ///
				replace `t' = cond(`.t_grp'==`g',_n==1,0)
			sum `.t_sub' `.wt' if `t', mean
			.cm_sumw[`g'] = r(sum_w)
			.cm_N[`g'] = r(N)
		}
	}
	else {
		local by `.t_sub' `.cm_panelvar' `.cm_casevar'
		sort `by'
		quietly by `by' : replace `t' = cond(`.t_sub',_n==1,0)
		sum `.t_sub' `.wt' if `t', mean
		.cm_sumw[1] = r(sum_w)
		.cm_N[1] = r(N)
	}
	by `by' : gen byte `.t_cm1' = cond(`.t_sub',_n==1,0)
end

program ._linearize
	args p J V
	tempname sc D u v b

	local cmdname `"`e(cmd)'"'
	if "`cmdname'" == "cox" {
		local cmdname stcox
	}
	// NOTE: If your estimation command's -predict, scores- logic
	// returns parameter-level scores, then it should put "allcons"
	// in macro -e(marginsprop)-.  Do not put your command in the
	// list with -mixed-.
	local allcons 0
	local margprop `"`e(marginsprop)'"'
	local cmdprops : properties `cmdname'
	if `:list posof "allcons" in margprop' {
		local allcons 1
	}
	else if inlist("`e(cmd)'","mixed","xtmixed", "gmm") {
		local allcons 1
	}
	else if `:list posof "svylb" in cmdprops' {
		local allcons 1
	}
	else if `:list posof "svyg" in cmdprops' {
		local allcons 1
	}
	if "`e(V_modelbased)'" == "matrix" {
		matrix `D' = e(V_modelbased)
	}
	else {
		if "`e(cmd)'" == "regress" {
			matrix `D' = e(V)/(e(rmse))^2
		}
		else {
			matrix `D' = e(V)
		}
	}
	local minus 1
        if `: list posof "minus" in margprop' & !`.is_svy' {
		_ms_omit_info e(b)
		local minus = colsof(r(omit))
		if r(k_omit) {
			local minus = `minus' - r(k_omit)
		}
	}

	capture predict double `sc'* if `.t_touse', scores
	if c(rc) {
		di as err "{p}cannot compute {bf:vce(unconditional)};{break}"
		di as err "predict after {bf:`.ecmd'} could not compute scores"
		di as err "{p_end}"
		exit 322
	}
	unab sclist : `sc'*
	local k_scores : list sizeof sclist
	local t_esub "`.t_esub'"
	if `:length local t_esub' {
		foreach s of local sclist {
			quietly replace `s' = 0 if !`t_esub'
		}
	}

	local dim = colsof(`p')
	matrix `v' = J(`dim', `dim', 0)
	local eq 0

	// build the list of subpop indicator variables

	if !`.hasby' {
		tempname touse2
		quietly gen byte `touse2' = `.t_sub'
	}

	local k_by = `.k_by'
	forval g = 1/`k_by' {
		tempname wdot`g'
		if `.hasby' {
			tempname sub`g'
			quietly gen byte `sub`g'' = `.t_grp' == `g'
		}
		else {
			local sub`g' : copy local touse2
		}
		sum `sub`g'' if `sub`g'' `.wt', mean
		scalar `wdot`g'' = r(sum_w)
		local slist `slist' `sub`g''
		local ++eq
		local stripe `stripe' `eq':_cons
	}

	// add the list of predictions

	if "`.xvars'" != "" {
		local xvars `"`.xvars'"'
	}
	else {
		local xvars _cons
	}

	local k_marg	= `.mlist.arrnels'
	local k_at	= `.atlist.arrnels'
	if `.is_pred' {
		local k_predict	= `._pred.arrnels'
		if `k_predict' == 0 {
			local k_predict = 1
		}
	}
	else	local k_predict = 1
	matrix `u' = J(`dim', `k_by', 0)
	local k 0
	foreach x of local xvars {
	    forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		local k_l = rowsof(`marg')
		forval j = 1/`k_at' {
		    local at `.atlist[`j']'
		    local r_at = rowsof(`at')
		    local g 1
		    forval r = 1/`r_at' {
			forval l = 1/`k_l' {
			  forval predict = 1/`k_predict' {
			    local ++k
			    local phat `._phat[`k']'
			    quietly replace `phat' = 0 if !`sub`g''
			    local PLIST `PLIST' `phat'
			    local SLIST `SLIST' `sub`g''
			    local slist `slist' `phat'
			    local ++eq
			    local stripe `stripe' `eq':_cons
			    matrix `u'[`k',`g'] = -`p'[1,`k']/`wdot`g''
			    matrix `v'[`k',`k'] = 1/`wdot`g''
			  }
			}
			if `.hasby' {
			    local g = mod(`g',`k_by') + 1
			}
		    }
		}
	    }
	}

	matrix `v' = `u', `v' , `J'*`D'

	// NOTE: For SRS designs '_robust2' assumes the variables are
	// centered at zero (an easy assumption to make for scores),
	// so we may need to center the variables.

	if `.is_svy' {
		quietly svyset
		local no_strata = "`r(strata1)'" == ""
		local no_psu = "`r(su1)'" == ""
		local stages = r(stages)
		local center = `stages' == 1
		if `center' {
			local center = `no_strata' & `no_psu'
		}
		local svy svy
	}
	else {
		local center = "`.clopt'" == ""
		local linwgt "`.wt'"
		if "`e(wexp_robust)'" != "" {
			local linwgt `"[`.wtype'`e(wexp_robust)']"'
		}
	}
	if `center' {
		local ulist : list uniq slist
		foreach u of local ulist {
			sum `u' if `.t_touse' `.wt', mean
			quietly replace `u' = `u' - r(mean)
		}
	}

	matrix `D' = I(colsof(`v'))

nobreak {

	local epilog "*"
	if `"`e(robust_prolog)'"' != "" {
		`e(robust_prolog)'
		local epilog `"`e(robust_epilog)'"'
	}

	if `allcons' {
		forval i = 1/`k_scores' {
			local ++eq
			local stripe `stripe' `eq':_cons
		}
	}
	else {
		matrix `b' = e(b)
		_ms_lf_info
		if r(k_lf) != `k_scores' {
			exit 322
		}
		forval i = 1/`k_scores' {
			local ++eq
			if r(freeparm`i') {
				local lf /`eq'
			}
			else {
				local lf `eq'
			}
			local cn`i' `"`r(varlist`i')'"'
			foreach x of local cn`i' {
				local stripe `stripe' `lf':`x'
			}
			if r(cons`i') {
				local stripe `stripe' `lf':_cons
			}
		}
	}
	matrix colna `D' = `stripe'
	matrix rowna `D' = `stripe'

capture noisily break {

	_robust2 `slist' `sclist'		///
		if `.t_touse' `linwgt',		///
		v(`D')				///
		minus(`minus')			///
		`svy'				///
		`.clopt'

	if "`r(N_clust)'" != "" {
		.nclust = r(N_clust)
	}
	if `.is_svy' {
		.npop	= r(sum_w)
		.npsu	= r(N_clust)
		.nstr	= r(N_strata)
		.df_r	= r(df_r)
		if !missing(r(N_poststrata)) {
			.npost = r(N_poststrata)
		}
	}

} // capture noisily break
	local rc = c(rc)
	`epilog'

} // nobreak
	if `rc' {
		exit `rc'
	}

	if "`.genstub'" != "" {
		local dim : list sizeof PLIST
		forval i = 1/`dim' {
			gettoken phat PLIST : PLIST
			gettoken subg SLIST : SLIST
			quietly replace `phat' = . if !`subg'
		}
	}

	matrix `V' = `v' * `D' * `v''
end

program ._linearize_cm
	args p J V
	tempname sc D u v b

	local cmdname `"`e(cmd)'"'
	local cmdprops : properties `cmdname'
	if "`e(V_modelbased)'" == "matrix" {
		matrix `D' = e(V_modelbased)
	}
	else {
		// should have been cause in ._parse_vce
		error 332
	}

	capture predict double `sc'* if `.t_touse', scores
	if c(rc) {
		di as err "{p}cannot compute {bf:vce(unconditional)};{break}"
		di as err "predict after {bf:`.ecmd'} could not compute scores"
		di as err "{p_end}"
		exit 322
	}
	unab sclist : `sc'*
	local k_scores : list sizeof sclist
	local t_esub "`.t_esub'"
	if `:length local t_esub' {
		foreach s of local sclist {
			quietly replace `s' = 0 if !`t_esub'
		}
	}

	local dim = colsof(`p')
	matrix `v' = J(`dim', `dim', 0)
	local eq 0

	// build the list of outcome/subpop indicator variables

	local k_alt = `.altlist.arrnels'
	local k_by = `.k_by'
	local og 0
	forval o = 1/`k_alt' {
		if `.outsel[`o']' == 0 {
			continue
		}
	forval g = 1/`k_by' {
		local ++og
		local col`o'_`g' = `og'
		tempname sub`og'
		if `.hasby' {
			quietly gen byte `sub`og'' = `.t_grp' == `g' ///
				& `.myaltvar'==`.altlist[`o']'
		}
		else {
			quietly gen byte `sub`og'' = `.t_sub' ///
				& `.myaltvar'==`.altlist[`o']'
		}
		local slist `slist' `sub`og''
		local ++eq
		local stripe `stripe' `eq':_cons
	} // g
	} // o
	local k_og = `og'

	// add the list of predictions

	if "`.xvars'" != "" {
		local xvars `"`.xvars'"'
	}
	else {
		local xvars _cons
	}

	local k_marg	= `.mlist.arrnels'
	local k_at	= `.atlist.arrnels'
	if `.is_pred' {
		local k_predict	= `._pred.arrnels'
		if `k_predict' == 0 {
			local k_predict = 1
		}
	}
	else	local k_predict = 1
	matrix `u' = J(`dim', `k_og', 0)
	local k 0
	local kk 0
	local oldname
	foreach x of local xvars {
		_ms_parse_parts `x'
		if r(type) == "variable" {
			local ++kk
		}
		else {
			local name `r(ts_op)'.`r(name)'
			if "`name'" != "`oldname'" {
				local ++kk
				local oldname : copy local name
			}
		}
		local i_mstat 0
	forval o = 1/`k_alt' {
		if `.outsel[`o']' == 0 {
			continue
		}
		local cmj 0
	forval a = 1/`k_alt' {
		if `.altsel[`a']' == 0 {
			continue
		}
	forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		local k_l = rowsof(`marg')
	forval j = 1/`k_at' {
		if `.hasAltSpecMarg[`i']'==0 & `.hasAltSpecAt[`j']'==0 {
			continue
		}
		local ++cmj
		local at `.cm_atlist[`cmj']'
		local r_at = rowsof(`at')
		local g 1
	forval r = 1/`r_at' {
	forval l = 1/`k_l' {
	forval predict = 1/`k_predict' {
		local og = `col`o'_`g''
		local ++k
		local phat `._phat[`k']'
		quietly replace `phat' = 0 if !`sub`og''
		sum `phat' `.wt' if `sub`og'' , mean
		quietly replace `phat' = `phat' - r(mean) if `sub`og''
		local PLIST `PLIST' `phat'
		local SLIST `SLIST' `sub`og''
		local slist `slist' `phat'
		local ++eq
		local stripe `stripe' `eq':_cons
		if `.cm_rescale' {
			local denom = `.cm_sumw[`g']'
		}
		else {
			local denom = r(sum_w)
		}
		matrix `u'[`k',`og'] = -`p'[1,`k']/`denom'
		matrix `v'[`k',`k'] = 1/`denom'
	} // predict
	} // l
		if `.hasby' {
		    local g = mod(`g',`k_by') + 1
		}
	} // r
	} // j
	} // i
	} // a
		local cmj0 `cmj'
	} // o
	forval o = 1/`k_alt' {
		if `.outsel[`o']' == 0 {
			continue
		}
		if `.altSpecXvar[`kk']' {
			local arange 1/`k_alt'
		}
		else {
			local arange `.altfirst'/`.altfirst'
		}
	forval a = `arange' {
		if `.altsel[`a']' == 0 {
			continue
		}
		local cmj `cmj0'
	forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		local k_l = rowsof(`marg')
	forval j = 1/`k_at' {
		if `.hasAltSpecMarg[`i']' | `.hasAltSpecAt[`j']' {
			continue
		}
		local ++cmj
		local at `.cm_atlist[`cmj']'
		local r_at = rowsof(`at')
		local g 1
	forval r = 1/`r_at' {
	forval l = 1/`k_l' {
	forval predict = 1/`k_predict' {
		local og = `col`o'_`g''
		local ++k
		local phat `._phat[`k']'
		quietly replace `phat' = 0 if !`sub`og''
		sum `phat' `.wt' if `sub`og'' , mean
		quietly replace `phat' = `phat' - r(mean) if `sub`og''
		local PLIST `PLIST' `phat'
		local SLIST `SLIST' `sub`og''
		local slist `slist' `phat'
		local ++eq
		local stripe `stripe' `eq':_cons
		matrix `u'[`k',`og'] = -`p'[1,`k']/r(sum_w)
		matrix `v'[`k',`k'] = 1/r(sum_w)
	} // predict
	} // l
		if `.hasby' {
			local g = mod(`g',`k_by') + 1
		}
	} // r
	} // j
	} // i
	} // a
	} // o
	} // x

	// recenter the outcome/group indicators
	local og 0
	forval o = 1/`k_alt' {
		if `.outsel[`o']' == 0 {
			continue
		}
	forval g = 1/`k_by' {
		local ++og
		if `.hasby' {
			local IF if `.t_touse' & `.myaltvar'==`.altlist[`o']'
			sum `sub`og'' `.wt' `IF' , mean
			quietly replace `sub`og'' = `sub`og''-r(mean) `IF'
		}
		else {
			quietly replace `sub`og'' = 0 if `sub`og''
		}
	} // g
	} // o

	matrix `v' = `u', `v' , `J'*`D'

	matrix `D' = I(colsof(`v'))

nobreak {

	local epilog "*"
	if `"`e(robust_prolog)'"' != "" {
		`e(robust_prolog)'
		local epilog `"`e(robust_epilog)'"'
	}

	forval i = 1/`k_scores' {
		local ++eq
		local stripe `stripe' `eq':_cons
	}
	matrix colna `D' = `stripe'
	matrix rowna `D' = `stripe'

capture noisily break {

	_robust2 `slist' `sclist'		///
		if `.t_touse' `linwgt',		///
		allcons				///
		v(`D')				///
		`svy'				///
		`.clopt'

	if "`r(N_clust)'" != "" {
		.nclust = r(N_clust)
	}
	if `.is_svy' {
		.npop	= r(sum_w)
		.npsu	= r(N_clust)
		.nstr	= r(N_strata)
		.df_r	= r(df_r)
		if !missing(r(N_poststrata)) {
			.npost = r(N_poststrata)
		}
	}

} // capture noisily break
	local rc = c(rc)
	`epilog'

} // nobreak
	if `rc' {
		exit `rc'
	}

	if "`.genstub'" != "" {
		local dim : list sizeof PLIST
		forval i = 1/`dim' {
			gettoken phat PLIST : PLIST
			gettoken subg SLIST : SLIST
			quietly replace `phat' = . if !`subg'
		}
	}

	matrix `V' = `v' * `D' * `v''
end

program ._est1_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_compute(`"`.objkey' `0'"')
end

program ._est1_db_cr
	syntax [if] [in] [fw pw iw aw/] [, pred(int 1) *]

	local deriv 0
	local j1 0
	if `.is_pred' & `.numeric' == 0 {
		local deriv = `._pred[`pred'].deriv'
		if `.ey' == 0 {
			local j1 = `._pred[`pred'].j1'
		}
		// JSP: eventually check/support factor Jacobian when .ey is 1
	}

	if `j1' {
		._est1_db_j `0'
	}
	else if `deriv' {
		.cr_a = 1
		._est1_db_cr_a `0'
	}
	else {
		capture drop `._pred[`pred'].varname'
		._est1_db_cr_n `0'
	}
end

program ._est1_db_cr_n
	syntax [if/] [in] [fw pw iw aw/] [, NONEXT pred(passthru)]
	tempname ehold
	_est hold `ehold', copy restore
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	mata: st__marg_cr_compute(`"`.objkey' `wgt'"', `"`if'"', `"`pred'"', "`.t_cr'")
end

program ._est1_db_cr_a, rclass
	syntax [if] [in] [fw pw iw aw] [, NONEXT pred(int 1)]
	if `"`nonext'"' == "" {
		local next next
	}

	local pvar `._pred[`pred'].varname'
	if `:length local weight' {
		local wgt [`weight'`exp']
	}

	_ms_lf_info
	local keq = r(k_lf)
	forval i = 1/`keq' {
		local k`i' = r(k`i')
	}

	if `.ey' {
		tempvar y
		._pred[`pred'].Predict `if' `in'
		rename `pvar' `y'
		quietly replace `y' = . if `y' <= 0 `in'
	}

	tempname sumw db
	sum `.t_touse' `if' `in' `wgt', meanonly
	scalar `sumw' = r(sum_w)

	forval i = 1/`keq' {
		._pred[`pred'].Predict `if' `in', d1(#`i')
		if `.ey' {
			quietly replace `pvar' = `pvar'/`y' `if' `in'
		}
		if `"`weight'"' != "" {
			local xwgt [iweight`exp'*`pvar']
		}
		else {
			local xwgt [iweight=`pvar']
		}
		if `sumw' {
			_ms_means b `if' `in' `xwgt', eclass eq(#`i') sumonly
			matrix `db' = nullmat(`db'), r(means)/`sumw'
		}
		else {
			matrix `db' = nullmat(`db'), J(1,`k`i'',0)
		}
	}

	.compute `if' `in' `wgt', `next' pred(`pred')
	if "`next'" == "" {
		sum `pvar' `if' `in' `wgt', mean
	}
	else {
		local pvar "`._phat[`._phat.arrnels']'"
		sum `pvar' `if' `in' `wgt', mean
	}
	return scalar b = r(mean)
	return scalar N = r(N)
	return scalar sum_w = r(sum_w)
	return matrix db `db'
end

program ._est1_db_j, rclass
	if `.hascm' {
		local outcome outcome(int -1)
	}
	syntax [if] [in] [fw pw iw aw] [, NONEXT pred(int 1) `outcome']
	if `"`nonext'"' == "" {
		local next next
	}

	if `.hascm' {
		if `outcome' > -1 {
			local ifxtra "&`.myaltvar'==`outcome'"
			local outopt outcome(`outcome')
		}
	}

	local pvar `._pred[`pred'].varname'
	if `:length local weight' {
		local wgt [`weight'`exp']
	}

	tempname db

	.compute `if' `in' `wgt', `next' pred(`pred') j1(`db') `outopt'
	if "`next'" == "" | `.gen' == 0 {
		sum `pvar' `if' `ifxtra' `in' `wgt', mean
	}
	else {
		local pvar "`._phat[`._phat.arrnels']'"
		sum `pvar' `if' `ifxtra' `in' `wgt', mean
	}
	if r(sum_w) != 0 {
		matrix `db' = `db'/r(sum_w)
	}
	else	matrix `db' = J(1,colsof(`db'),0)
	return scalar b = r(mean)
	return scalar N = r(N)
	return scalar sum_w = r(sum_w)
	return matrix db `db'
end

program ._est2_c, rclass
	if `.hascm' {
		local outcome outcome(passthru)
		local alternative alternative(passthru)
		local altidx altidx(passthru)
	}
	syntax [if] [in], xvar(string) `outcome' ///
		[mult(passthru) pred(int 1) `alternative' `altidx']
	tempvar b nobs sumw db

	if `.est_chk' {
		._check_est `if' `in' `.wt', `mult' pred(`pred')
		if r(not_estimable) {
			return add
			exit
		}
	}

	local xopt xvar(`xvar')

	local deriv 0
	local j2 0
	if `.is_pred' & `.numeric' == 0 {
		local deriv = `._pred[`pred'].deriv'
		local j2 = `._pred[`pred'].j2'
	}

	local cr_use = `.cr_use'
	if `cr_use' {
		if `.cr_cons' == 0 {
			_ms_chainrule b `if' `in', eclass
			if r(any) == 0 {
				local cr_use = 0
			}
			else {
				tempname crhold
				matrix `crhold' = `.t_cr'
				matrix `.t_cr' = r(chainrule)
			}
		}
	}

nobreak {

capture noisily break {

	if `deriv' & `j2' == 0 {
		.cr_a = 1
		._est2_c_cr_a `if' `in', pred(`pred') `outcome' `alternative'
	}
	else if !`cr_use' | `j2' {
		tempvar hold
		local tschar : char `xvar'[tsrevar]
		local fvchar : char `xvar'[fvrevar]
		rename `xvar' `hold'
		quietly gen double `xvar' = `hold'
		char `xvar'[tsrevar] `"`tschar'"'
		char `xvar'[fvrevar] `"`fvchar'"'
	}
	else {
		.xvar = "1"
		._est2_c_cr_n `if' `in', pred(`pred') `outcome' `alternative'
	}

} // capture noisily break
	local rc = c(rc)

	if !`rc' {

capture noisily break {

	.h	= 0
	.scale	= 0
	.xvar	= "`hold'"
	if `j2' {
		._est2_c_j `if' `in' `.wt',	///
			`xopt'			///
			`outcome'		///
			`altidx'		///
			next			///
			pred(`pred')
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		scalar `sumw'	= r(sum_w)
		matrix `db'	= r(db)
	}
	else if `deriv' | `cr_use' {
		_marg_dydx_ccompute_cr `.objkey' `if' `in' `.wt', ///
			`xopt' `.nose' next `outcome' `alternative'
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		scalar `sumw'	= r(sum_w)
		if `.se' {
			matrix `db' = r(db)
		}
	}
	else if "`.nose'" != "" {
		_marg_dydx_ccompute `.objkey' `if' `in' `.wt', ///
			`xopt' pred(`pred') `outcome' `alternative'
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		scalar `sumw'	= r(sum_w)
		._est2_c_phat `if' `in', ///
			`xopt' next pred(`pred') ///
			`outcome' `alternative'
	}
	else {
		._est2_c_db `.objkey' `if' `in' `.wt', ///
			`xopt' pred(`pred') ///
			`outcome' `alternative' `altidx'
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		scalar `sumw'	= r(sum_w)
		matrix `db'	= r(db)
		._est2_c_phat `if' `in', ///
			`xopt' next pred(`pred') ///
			`outcome' `alternative'
	}

} // capture noisily break
	local rc = c(rc)

	}

	if !`deriv' & !`cr_use' {
		capture drop `xvar'
		rename `hold' `xvar'
	}
	if `"`crhold'"' != "" {
		matrix drop `.t_cr'
		matrix rename `crhold' `.t_cr'
	}

} // nobreak
	if `rc' {
		exit `rc'
	}

	return scalar b = `b'
	return scalar N = `nobs'
	return scalar sum_w = `sumw'
	if `.se' {
		return matrix db `db'
	}
end

program ._est2_c_j, rclass
	if `.hascm' {
		local outcome outcome(int -1)
		local altidx altidx(passthru)
	}
	syntax [if] [in] [fw pw iw aw] ,	///
		xvar(passthru)			///
	[					///
		`outcome'			///
		`altidx'			///
		NEXT				///
		pred(int 1)			///
	]

	if `.hascm' {
		if `outcome' > -1 {
			local ifxtra "&`.myaltvar'==`outcome'"
			local outopt outcome(`outcome')
		}
	}

	local pvar `._pred[`pred'].varname'
	if `:length local weight' {
		local wgt [`weight'`exp']
	}

	tempname db

	.compute `if' `in' `wgt',	///
		`xvar'			///
		`next'			///
		`outopt'		///
		`altidx'		///
		pred(`pred')		///
		j2(`db')
	if "`next'" == "" | `.gen' == 0 {
		sum `pvar' `if' `ifxtra' `in' `wgt', mean
	}
	else {
		local pvar "`._phat[`._phat.arrnels']'"
		sum `pvar' `if' `ifxtra' `in' `wgt', mean
	}
	if r(sum_w) != 0 {
		matrix `db' = `db'/r(sum_w)
	}
	else	matrix `db' = J(1,colsof(`db'),0)
	return scalar b = r(mean)
	return scalar N = r(N)
	return scalar sum_w = r(sum_w)
	return matrix db `db'
end

program ._est2_c_cr_a
	syntax [if] [in] [, pred(int 1)]

	capture drop `.t_dzb'*

	local y `._pred[`pred'].varname'
	local neq = rowsof(`.t_cr')
	tempname t
	forval i = 1/`neq' {
		// dpdxb
		._pred[`pred'].Predict `if' `in', d1(#`i')
		local d`i' `.t_dzb'_`i'
		rename `y' `d`i''
		forval j = 1/`i' {
			// d2pdxbdxb
			._pred[`pred'].Predict `if' `in', d1(#`i') d2(#`j')
			local d`i'_`j' `.t_dzb'_`i'_`j'
			rename `y' `d`i'_`j''
		}
	}
	if `.ey' == 0 {
		exit
	}
	._pred[`pred'].Predict `if' `in'
	quietly replace `y' = . if `y' <= 0 `in'
	forval i = 1/`neq' {
		quietly replace `d`i'' = `d`i''/`y' `if' `in'
		forval j = 1/`i' {
			quietly replace `d`i'_`j'' =		///
				-`d`i''*`d`j''			///
				+`d`i'_`j''/`y'			///
				`if' `in'
		}
	}
end

program ._est2_c_cr_n
	syntax [if] [in] [, pred(int 1)]

	capture drop `.t_dzb'*

	local cmd _est2_c_cr1
	if `.cr_use2' {
		local cmd _est2_c_cr2
	}

	local neq = rowsof(`.t_cr')
	tempname t
	local is_xb = `.is_xb[`pred']' & !`.numeric'
	if `is_xb' {
		if `.ey' {
			.ey = 0
			.compute `if' `in' `.wt', gen(`t') pred(`pred')
			.ey = 1
			local vt_i 1/`t'
			local vt_ij -1/`t'^2
			local ttype double
		}
		else {
			local vt_i 1
			local vt_ij 0
			local ttype byte
		}
		local eqno = `.eqno[`pred']'
	}
	forval i = 1/`neq' {
		local ti `.t_dzb'_`i'
		// dpdxb
		if !`is_xb' {
			quietly gen double `ti' = . in 1
		}
		else if `eqno' == `i' {
			quietly gen `ttype' `ti' = `vt_i'
		}
		else {
			quietly gen byte `ti' = 0
		}
		forval j = 1/`i' {
			// d2pdxbdxb
			local tij `.t_dzb'_`i'_`j'
			if !`is_xb' {
				quietly gen double `tij' = . in 1
			}
			else if `eqno' == `i' & `eqno' == `j' {
				quietly gen `ttype' `tij' = `vt_ij'
			}
			else {
				quietly gen byte `tij' = 0
			}

		}
	}
	if !`is_xb' {
		.`cmd' `.t_dzb' `if' `in' `.wt', pred(`pred')
	}
end

program ._est2_c_cr1
	tempname ehold
	_est hold `ehold', copy restore
	syntax name(name=t) [fw pw iw aw/] [if/] [in] [, pred(passthru)]
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	local cr `.t_cr'
	mata: st__marg_dydx_cr_compute(`"`.objkey' `wgt'"', `"`if'"', `"`pred'"', `.se')
end

program ._est2_c_cr2
	tempname ehold
	_est hold `ehold', copy restore
	syntax name(name=t) [fw pw iw aw/] [if/] [in] [, pred(passthru)]
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	local cr `.t_cr'
	mata: st__marg_dydx_cr2_compute(`"`.objkey' `wgt'"', `"`if'"', `"`pred'"', `.se')
end

program ._est2_c_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_dydx_ccompute(`"`0'"')
end

program ._est2_c_phat
	if `.hascm' {
		local outcome outcome(int)
		local alternative alternative(string asis)
	}
	syntax [if] [in], xvar(string) `outcome' ///
		[next pred(passthru) `alternative']
	local next : length local next

	if `next' == 0 {
		exit
	}
	if `.gen' == 0 {
		exit
	}

	if `.hascm' {
		local outcond "`.myaltvar'==`outcome'"
		local outcome outcome(`outcome')
	}
	tempname d hold p1 p2
	scalar `d' = float(`.h'*`.scale')
	local tschar : char `xvar'[tsrevar]
	local fvchar : char `xvar'[fvrevar]
	rename `xvar' `hold'
	local minus	`hold' - `d'
	local plus	`hold' + `d'
	if `"`alternative'"' != "" {
		local minus	cond(`alternative',`minus',`hold')
		local plus	cond(`alternative',`plus', `hold')
	}
	quietly gen double `xvar' = `minus'
	char `xvar'[tsrevar] `"`tschar'"'
	char `xvar'[fvrevar] `"`fvchar'"'
	.compute `if' `in' `.wt', gen(`p1') `pred' `outcome'
	quietly replace `xvar' = `plus'
	.compute `if' `in' `.wt', gen(`p2') `pred' `outcome'
	local exp (`p2' - `p1')/(2*`d')
	if `.hascm' {
		local exp cond(`outcond',`exp',.)
	}
	quietly replace `xvar' = `exp'
	if `.hascm' {
		capture assert `xvar' == . if `outcond'
		if c(rc) == 0 {
			quietly replace `xvar' = 0 if `outcond'
		}
	}
	.copyvar `xvar', next rename
	rename `hold' `xvar'
end

program ._est2_d, rclass
	if `.hascm' {
		local outcome outcome(passthru)
		local alternative alternative(passthru)
	}
	syntax [if] [in], xvar(string) `outcome' ///
		[mult(name) pred(passthru) `alternative']
	tempvar b nobs sumw db

	_ms_parse_parts `xvar'
	local var `r(name)'
	local k = r(level)
	.get_dx_base `var'
	if `k' == r(base) {
		scalar `b'	= 0
		scalar `nobs'	= 0
		scalar `sumw'	= 0
		if `:length local mult' {
			matrix `mult' = 0*e(b)
		}
		if `.se' {
			matrix `db' = 0*e(b)
		}
		.copyvar, next zero
	}
	else {
		._est2_d1 `0'
		if r(not_estimable)==1 {
			return add
			exit
		}
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		scalar `sumw'	= r(sum_w)
		if `.se' {
			matrix `db' = r(db)
		}
	}

	return scalar b = `b'
	return scalar N = `nobs'
	return scalar sum_w = `sumw'
	if `.se' {
		return matrix db `db'
	}
	return scalar not_estimable = 0
end

program ._est2_d1
	if `.hascm' {
		local outcome outcome(passthru)
		local alternative alternative(passthru)
	}
	syntax [if] [in], xvar(passthru) `outcome' ///
		[mult(passthru) pred(int 1) `alternative']

	local predo pred(`pred')

	local j1 0
	if `.is_pred' & `.numeric' == 0 {
		if `.ey' == 0 {
			local j1 = `._pred[`pred'].j1'
		}
	}

	if `.est_chk' | !`.se' | `:length local mult' | "`.vce'" == "unconditional" {
		if `.cr_use' | !`.se' | `j1' {
			local next next
		}
		local estchk = cond(`.est_chk', "estimcheck", "")
		_marg_dydx_dcompute `.objkey' `if' `in' `.wt',	///
			`xvar' `next' `mult' `estchk' `predo'	///
			`outcome' `alternative'
		if r(not_estimable) == 1 {
			exit
		}
	}
	if `.se' {
		local cr_use = `.cr_use'
		if `cr_use' {
			if `.cr_cons' == 0 {
				_ms_chainrule b `if' `in', eclass
				if r(any) == 0 {
					local cr_use = 0
				}
				else {
					tempname crhold
					matrix `crhold' = `.t_cr'
					matrix `.t_cr' = r(chainrule)
				}
			}
		}
		if `j1' | `cr_use' {
			._est2_d1_db_cr `if' `in' `.wt', ///
				`xvar' `mult' `predo' `outcome' `alternative'
		}
		else {
			._est2_d1_db `.objkey' `if' `in' `.wt', ///
				`xvar' `predo' `outcome' `alternative'
		}
		if `"`crhold'"' != "" {
			matrix drop `.t_cr'
			matrix rename `crhold' `.t_cr'
		}
	}
end

program ._est2_d1_db_cr, rclass
	if `.hascm' {
		local outcome outcome(passthru)
		local alternative alternative(passthru)
	}
	syntax [fw pw iw aw] [if] [in],	///
		xvar(string) `outcome'	///
		[ mult(name) pred(passthru) `alternative']

	tempname p0 p1 n0 n1 sumw

	_ms_parse_parts `xvar'
	* xvar should NOT have tsops
	assert "`r(ts_op)'" == ""
	local var `r(name)'
	local k = r(level)
	.get_dx_base `var'
	local base = r(base)

	local BALVARS `"`.BALVARS'"'
	if `:length local BALVARS' {
		tempname mult0 mult1
		if "`.empty'" != "rweight" & `:length local mult' {
			local mult1 : copy local mult
		}
		local balopt balvars(`BALVARS')
	}
	if `.se' {
		tempname db0 db1
	}

	._compute1 `if' `in' [`weight'`exp'], xvar(`var') k(`base')	///
		`balopt' mult(`mult0') `pred' `outcome' `alternative'
	scalar `p0' = r(b)
	scalar `n0' = r(N)
	scalar `sumw' = r(sum_w)
	if `.se' {
		matrix `db0' = r(db)
		if `:length local mult0' {
			mata: st_matrix("`db0'",	///
					st_matrix("`db0'") :* ///
					abs(st_matrix("`mult0'")))
		}
	}

	._compute1 `if' `in' [`weight'`exp'], xvar(`var') k(`k')	///
		`balopt' mult(`mult1') `pred' `outcome' `alternative'
	scalar `p1' = r(b)
	scalar `n1' = r(N)
	if `.se' {
		matrix `db1' = r(db)
		if `:length local mult1' {
			mata: st_matrix("`db1'",	///
					st_matrix("`db1'") :* ///
					abs(st_matrix("`mult1'")))
		}
	}

	if `n0' != `n1' {
		di as err "{p}" ///
"inconsistent estimation sample levels `base' and `k' of factor {bf:`var'}" ///
		"{p_end}"
		exit 459
	}

	return scalar b = `p1' - `p0'
	return scalar N = `n1'
	return scalar sum_w = `sumw'
	return scalar not_estimable = 0
	if `.se' {
		matrix `db1' = `db1' - `db0'
		return matrix db `db1'
	}
	if `:length local mult' & "`.empty'" == "reweight" {
		local c = colsof(`mult1')
		matrix `mult' = `mult1' - `mult0'
		forval i = 1/`c' {
			if `mult0'[1,`i'] == 1 {
				matrix `mult'[1,`i'] = 1
			}
		}
	}
end

program ._balance, eclass
	gettoken mult balvars : 0
	tempname b
	_ms_balance `balvars', `.empty' consvar(`.t_touse')
	matrix `b' = r(b)
	ereturn repost b=`b', rename
	matrix `mult' = r(mult)
end

program ._compute1
	if `.hascm' {
		local outcome outcome(passthru)
		local alternative alternative(string asis)
	}
	syntax [fw pw iw aw] [if] [in],				///
		xvar(varname)					///
		k(integer)					///
		`outcome'					///
		[	GENerate(passthru)			///
			mult(name)				///
			BALVARS(string)				///
			pred(passthru)				///
			`alternative'				///
		]
	local wgt [`weight'`exp']

	if `:length local balvars' {
		tempname ehold
		_est hold `ehold', copy restore
		._balance `mult' `balvars' `k'.`xvar'
	}

nobreak {

capture noisily break {

	tempvar hold
	rename `xvar' `hold'
	if `"`alternative'"' != "" {
		quietly gen `xvar' = cond(`alternative',`k',`hold')
	}
	else {
		quietly gen `xvar' = `k'
	}

} // capture noisily break
	local rc = c(rc)

	if !`rc' {

capture noisily quietly break {

		._est1_db_cr `if' `in' `wgt', nonext `pred' `outcome'

} // capture noisily quietly break
	local rc = c(rc)

	}

	capture confirm var `hold'
	if !c(rc) {
		capture drop `xvar'
		rename `hold' `xvar'
	}

} // nobreak
	exit `rc'
end

program ._est2_d1_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_dydx_dcompute(`"`0'"')
end

program ._rename4generate, rclass
	args b

	local stub `"`.genstub'"'

	if `"`stub'"' == "" {
		exit
	}

	local colna : colfullnames `b'
	if "`.xvars'" != "" {
		local xvars `"`.xvars'"'
	}
	else {
		local xvars _cons
	}

	local k_marg	= `.mlist.arrnels'
	local k_at	= `.atlist.arrnels'
	local k_predict	= `._pred.arrnels'
	if `k_predict' == 0 {
		local k_predict = 1
	}
	local vidx 0
	local k 0
	foreach x of local xvars {
	    forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		local k_l = rowsof(`marg')
		forval j = 1/`k_at' {
		    local at `.atlist[`j']'
		    local r_at = rowsof(`at')
		    local g 1
		    forval r = 1/`r_at' {
			forval l = 1/`k_l' {
			  forval predict = 1/`k_predict' {
			    local ++k
			    local phat `._phat[`k']'

			    local ++vidx
			    capture confirm new variable `stub'`vidx'
			    while c(rc) {
				local ++vidx
				capture confirm new variable `stub'`vidx'
			    }
			    gettoken bname colna : colna
			    _msparse `bname', noomit
			    local bname `"`r(stripe)'"'
			    label variable `phat' ///
			    	"margins generate variable for `bname'"
			    rename `phat' `stub'`vidx'

			    local vlist `vlist' `stub'`vidx'
			  }
			}
			if `.hasby' {
			    local g = mod(`g',`k_by') + 1
			}
		    }
		}
	    }
	}
	return local varlist `"`vlist'"'
end

exit

Special considerations:

-margins- is aware of the following -e()- macros:

	e(wtype)	weight type
	e(wexp)		weight expression

	e(marginswtype)	weight type, overrides e(wtype)
	e(marginswexp)	weight expression, overrides e(wexp)

	e(subpop)	subpopulation specification used to fit the -svy-
			model

	e(prefix)	check for "svy"

	e(vce)		VCE used by the estimation command
	e(vcetype)	VCE type reported above "Std. Err." in coef table

	e(clustvar)	cluster variable

	e(group)	identifies the cluster variable when
			-vce(unconditional)- option is specified, the
			model VCE type is "Robust", but there is nothing
			in -e(clustvar)-

	e(covariates)	list of covariate variables

	e(marginsprop)	signals to the -margins- command

	e(marginsok)	-predict- options certified as supported

	e(marginsnotok)	-predict- options certified NOT supported

	e(marginsderiv)	-predict- options certified to allow options
			-d1()- and -d2()- that modifies the predict
			command to return partial derivatives with
			respect to the specified equations

	e(marginsj1)	-predict- options certified to allow option
			-j1()- that modifies the predict command
			to return the Jacobian vector for the sum of the
			prediction

			-predict- must allow the following syntax:

				<newvarname> [if] [in] [iweight],
					j1(<new_matrix_name>)
					[<j1options>]

			the matrix named in option -j1()- is to be
			filled with the derivatives of the iweighted sum
			of the values in <newvarname>, taken with
			respect to the elements of -e(b)-

			For the [CM] commands, <j1options> includes
			option -outcome(#)-.  -outcome(#)- identifies
			which outcome to compute the statistic
			(probability), # corresponds to an outcome level
			value not an index.

	e(marginsj2)	-predict- options certified to allow option
			-j2()- that modifies the predict syntax and
			behavior in the following ways:

			Syntax 1

				<newvarname> [if] [in] [iweight],
					j2(<new_matrix_name>)
					dydx(<varname>)
					[<j2options>]

				Return in <newvarname> the partial
				derivatives of the statistic specified
				in <j2options>, taken with respect to
				<varname>.

			Syntax 2

				<newvarname> [if] [in] [iweight],
					j2(<new_matrix_name>)
					dyex(<varname>)
					[<j2options>]

				Return in <newvarname> the partial
				derivatives of the statistic specified
				in <j2options>, taken with respect to
				log(<varname>).

			Syntax 3

				<newvarname> [if] [in] [iweight],
					j2(<new_matrix_name>)
					eydx(<varname>)
					[<j2options>]

				Return in <newvarname> the partial
				derivatives of the natural log of
				statistic specified in <j2options>,
				taken with respect to <varname>.

			Syntax 4

				<newvarname> [if] [in] [iweight],
					j2(<new_matrix_name>)
					eyex(<varname>)
					[<j2options>]

				Return in <newvarname> the partial
				derivatives of the natural log of
				statistic specified in <j2options>,
				taken with respect to log(<varname>).

			The matrix named in option -j2()- is to be
			filled with the derivatives of the iweighted sum
			of the values in <newvarname>, taken with
			respect to the elements of -e(b)-

			For the [CM] commands, <j2options> includes
			option -outcome(#)- and -altidx(#)-.
			-outcome(#)- identifies which outcome to compute
			the statistic (probability), # corresponds to an
			outcome level value not an index.  -altidx(#)-
			is present when -dydx(<varname>)- is an
			alternative specific predictor, and identifies
			the index of the alternative for which the
			derivative is to be computed.

	e(marginsfootnote)
			contains a command to be run after -margins-
			reports the coefficient table, it is assumed
			that the developer of the -e(marginsfootnote)-
			command is aware of the contents of -e()-, set
			by -margins-, and will report the proper
			footnote based on the contents of -margins-'
			-e()- results

	e(marginsnomarkout)
			-predict- options certified so that -margins-
			should NOT mark out the same using any of the
			"at" variables

	e(marginsmark)	stand-in for -marksample- when -noesample- is
			specified; see below

-e(marginsprop)- signals:

	noeb		do not use -e(b)- for getting covariate term
			information or for restriping

	nochainrule	make -nochainrule- the default

	nolinearize	-vce(unconditional)- is not supported

	addcons		add '_cons' to all equations without one

	allcons		-predict, scores- returns parameter-level scores
			instead of equation-level scores

	atslow		always use calculations across observations even
			when all 'at' variables and 'margin' variables
			are fixed/constant

-e(marginsmark)- contains the name of a program to use instead of
-marksample- when the -noesample- option is specified.  The syntax for
this command must be

		new_touse new_sub [if] [in] [weight] [,
			ZEROweight
			subpop(...)
			over(varlist)
			within(varlist)
		]

	This command needs to use -svymarkout- when -e(prefix)- is
	"svy".

	This command needs to use -_svy_subpop- to parse -subpop()-
	option, which also will create an identifier for the subpop.
	You need to decide if that is to be the "new_sub" or something
	else.

	Regarding -over()- and -within()-, your program can perform a
	sanity check on the specified variable; specific to the needs of
	your estimation command/results.

-margins- also adds variables to the following -c()- macros using the
-set- command of the same subcommand:

	c(marginsatvars)	variables changed for -at()- option
	c(marginsdxvars)	variables changed for -dydx()- options
	c(marginsmvars)		factor variables changed for <marglist>
	c(marginsrevars)	time-series operated variables changed
				for various reasons

